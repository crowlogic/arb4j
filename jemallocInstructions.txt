Starting your JVM with jemalloc

Normally one would link directly with the jemalloc.so file when compiling, but we don't have that luxury since we are running the jvm. 
Luckily, there is a trick for making the .so get loaded automatically when the process starts. To do this, modify your start script 
to set this environment variable:

export LD_PRELOAD=/usr/local/lib/libjemalloc.so

This results in your executable automatically loading the shared library up front before anything else gets resolved. 
If you do pmap on your running executable after it is up, you'll see libjemalloc.so is loaded at the very top of memory. 
As a result, when the jvm gets loaded any references to malloc are already resolved to our profiling-enabled .so.


Configuring the profiler

We're not ready to fire it up yet! First we need to define what kind of output jemalloc will output in terms of profiling. 
Here is a sample of what I have used. Again, in a native application one can modify these settings via global variables in 
the library, however we are able to set them via an environment variable instead:

export MALLOC_CONF=prof:true,lg_prof_interval:31,lg_prof_sample:17,prof_prefix:/my/output/directory/jeprof

Some explanation of the numbers here. The 31 in this case is the log base 2 of the interval in bytes between allocations 
that we want jemalloc to report. Whaaaa?! That's right, log base 2, as though profiling native memory allocation weren't 
already difficult enough without requiring us to do math. In this case 2^31 is about 2GB, so every 2GB of memory allocation, 
we'll get a .heap output file specified in the prof_prefix location. Make sure /my/output/directory exists and is writable 
by your process and you'll get a lot of files named /my/output/directory/jeprof*.heap These are the haystacks that jeprof 
will dig through to find our needle.
