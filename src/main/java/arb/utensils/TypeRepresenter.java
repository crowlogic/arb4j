package arb.utensils;

import java.util.List;

import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.introspector.Property;
import org.yaml.snakeyaml.nodes.Node;
import org.yaml.snakeyaml.nodes.NodeTuple;
import org.yaml.snakeyaml.nodes.Tag;
import org.yaml.snakeyaml.representer.Represent;
import org.yaml.snakeyaml.representer.Representer;

import arb.Fraction;
import arb.Integer;
import arb.Named;
import arb.RationalFunction;
import arb.Real;
import arb.RealPolynomial;
import arb.applications.expressor.ExpressionTreeView;
import arb.documentation.BusinessSourceLicenseVersionOnePointOne;
import arb.documentation.TheArb4jLibrary;
import arb.expressions.Context;
import arb.expressions.context.SerializedContextVariable;

/**
 * A custom {@link Representer} implementation for serializing various Arb4j
 * types into YAML. This class ensures that objects are serialized efficiently
 * using SnakeYAML's automatic anchoring and aliasing mechanism, while allowing
 * for custom representations of specific types such as {@link Real},
 * {@link Fraction}, and {@link Integer}.
 *
 * Synthetic classes (lambdas, method references) are handled via the
 * {@code multiRepresenters} fallback mechanism since
 * {@code BaseRepresenter.representData} is final and cannot be overridden.
 *
 * @see BusinessSourceLicenseVersionOnePointOne © terms of the
 *      {@link TheArb4jLibrary}
 */
public class TypeRepresenter extends
                                Representer
{

  public TypeRepresenter(DumperOptions options)
  {
    super(options);
    var namedStringRepresentation = new NamedStringRepresentation();
    representers.put(Context.class, new ContextRepresentation());
    representers.put(Integer.class, namedStringRepresentation);
    representers.put(Real.class, namedStringRepresentation);
    representers.put(Fraction.class, namedStringRepresentation);
    representers.put(RealPolynomial.class, namedStringRepresentation);
    representers.put(RationalFunction.class, namedStringRepresentation);

    representers.put(ExpressionTreeView.class, data ->
    {
      return representData(((ExpressionTreeView<?, ?, ?>) data).expressionInput.getText());
    });

    representers.put(SerializedContextVariable.class, data ->
    {
      SerializedContextVariable contextVariable = (SerializedContextVariable) data;
      return representSequence(getTag(String.class, Tag.SEQ),
                               List.of(contextVariable.type, contextVariable.value),
                               defaultFlowStyle);
    });

    /*
     * Register a fallback representer keyed on Object.class in the
     * multiRepresenters map. SnakeYAML's BaseRepresenter.representData checks
     * multiRepresenters by walking the class hierarchy when no exact match is found
     * in the representers map. Keying on Object.class makes this the last-resort
     * fallback, which intercepts synthetic classes (lambdas, method references)
     * before the default RepresentJavaBean attempts to introspect them.
     */
    Represent defaultJavaBeanRepresent = multiRepresenters.get(Object.class);
    multiRepresenters.put(Object.class, data ->
    {
      if (data != null && data.getClass().isSynthetic())
      {
        return representScalar(Tag.STR, data.toString());
      }
      if (defaultJavaBeanRepresent != null)
      {
        return defaultJavaBeanRepresent.representData(data);
      }
      return representJavaBean(getProperties(data.getClass()), data);
    });
  }

  /**
   * Skip properties whose runtime values are synthetic classes (lambdas, method
   * references, anonymous inner classes generated by the compiler). This is a
   * belt-and-suspenders guard — if a synthetic value is a direct bean property,
   * we omit the entire property rather than emitting a placeholder.
   */
  @Override
  protected NodeTuple representJavaBeanProperty(Object javaBean,
                                                Property property,
                                                Object propertyValue,
                                                Tag customTag)
  {
    if (propertyValue != null && propertyValue.getClass().isSynthetic())
    {
      return null;
    }
    return super.representJavaBeanProperty(javaBean, property, propertyValue, customTag);
  }

  public class NamedStringRepresentation implements
                                         Represent
  {

    @Override
    public Node representData(Object data)
    {
      return TypeRepresenter.this.representData(new SerializedContextVariable((Named) data));
    }

  }

  public class ContextRepresentation implements
                                     Represent
  {
    @Override
    public Node representData(Object data)
    {
      Context context = (Context) data;
      return TypeRepresenter.this.representMapping(getTag(data.getClass(), Tag.MAP),
                                                      context.variables,
                                                      defaultFlowStyle);
    }
  }
}
