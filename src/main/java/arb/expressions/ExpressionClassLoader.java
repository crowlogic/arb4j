package arb.expressions;

import java.util.HashMap;
import java.util.concurrent.atomic.AtomicReference;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import arb.functions.Function;

/**
 * Custom {@link ClassLoader} for arb4j dynamically-compiled {@link Expression}
 * implementations.
 *
 * <p>Bytecodes produced by {@link Expression#generate()} are registered via
 * {@link #registerBytecodes(String, byte[])} before {@link #loadClass(String)}
 * is called. The standard {@link ClassLoader#loadClass} contract applies:
 * parent delegation runs first, so any class already present on the classpath
 * (e.g. pre-compiled by the arb4j Maven plugin) is returned directly without
 * ever calling {@link #findClass}, preventing duplicate class definition.
 *
 * @author Stephen Crowley ©2024-2025
 * @see arb.documentation.BusinessSourceLicenseVersionOnePointOne © terms
 */
public class ExpressionClassLoader extends
                                   ClassLoader
{

  private final static Logger log = LoggerFactory.getLogger(ExpressionClassLoader.class);

  /**
   * Bytecodes waiting to be defined. Populated by
   * {@link #registerBytecodes(String, byte[])} and consumed (removed) the first
   * time {@link #findClass(String)} is called for that name.
   */
  private final HashMap<String, byte[]> pendingBytecodes = new HashMap<>();

  /**
   * Classes that have been defined by this loader, keyed by binary name.
   */
  public final HashMap<String, Class<?>> compiledClasses = new HashMap<>();

  public final Context context;

  public ExpressionClassLoader(Context context)
  {
    assert context != null : "context shan't be null";
    this.context = context;
  }

  /**
   * Registers bytecodes for a class so that the next {@link #loadClass(String)}
   * call for that name can define it if — and only if — the class is not already
   * findable via parent delegation. If the class is already on the classpath,
   * the registered bytecodes are never consumed.
   *
   * @param className binary class name
   * @param bytecodes ASM-generated bytecodes from {@link Expression#generate()}
   */
  public void registerBytecodes(String className, byte[] bytecodes)
  {
    pendingBytecodes.put(className, bytecodes);
  }

  /**
   * Called by {@link ClassLoader#loadClass} only after parent delegation has
   * already failed to locate the class. Defines the class from
   * {@link #pendingBytecodes} if present, then falls back to searching the
   * {@link Context} function mappings.
   *
   * @throws ClassNotFoundException if the class cannot be found by any means
   */
  @Override
  @SuppressWarnings("unchecked")
  protected Class<?> findClass(String name) throws ClassNotFoundException
  {
    if (Expression.trace)
    {
      log.debug("findClass('{}') in Context#{}", name, System.identityHashCode(context));
    }

    byte[] bytecodes = pendingBytecodes.remove(name);
    if (bytecodes != null)
    {
      Class<?> defined = defineClass(name, bytecodes, 0, bytecodes.length);
      compiledClasses.put(name, defined);
      return defined;
    }

    FunctionMapping<Object,
                    Object,
                    Function<? extends Object,
                             ? extends Object>> functionMapping =
                                                                context.getFunctionMapping(name);
    if (functionMapping != null)
    {
      return functionMapping.type();
    }

    AtomicReference<Class<?>> mappedClassReference = new AtomicReference<Class<?>>();
    context.functions.values().forEach(mapping ->
    {
      if (name.equals(mapping.functionName) || name.equals(mapping.functionClass.getName()))
      {
        assert mappedClassReference.get()
                                   == null : "mappedClassReference is already mapped to " + mapping;
        mappedClassReference.set(mapping.functionClass);

        if (Expression.trace)
        {
          log.debug("Mapped {} to {}", mapping, name);
        }
      }
    });

    Class<?> mappedClass = mappedClassReference.get();
    if (mappedClass != null)
    {
      return mappedClass;
    }

    throw new ClassNotFoundException(name);
  }

  @Override
  public String toString()
  {
    return String.format("ExpressionClassLoader[compiledClasses=%s, context=%s]",
                         compiledClasses,
                         context);
  }
}
