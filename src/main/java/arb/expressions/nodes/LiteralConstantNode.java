package arb.expressions.nodes;

import static arb.expressions.Compiler.*;
import static org.objectweb.asm.Opcodes.*;

import java.util.*;
import java.util.function.Consumer;

import org.objectweb.asm.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import arb.*;
import arb.Integer;
import arb.domains.Domain;
import arb.exceptions.UnsupportedTypeConversionException;
import arb.expressions.*;
import arb.functions.Function;

/**
 * Represents a literal constant within an arithmetic expression. This class is
 * used to encapsulate specific constant values, such as mathematical constants
 * (π, ½), within the expression tree of the {@link arb.expressions.Expression}
 * framework. It extends the generic {@link Node} to fit within the structure of
 * an expression tree, allowing arithmetic and symbolic operations to be
 * performed on constants.
 * <p>
 * The {@code LiteralConstant} node dynamically identifies and handles constants
 * defined at runtime and supports the declaration of such constants in
 * generated bytecode. This dynamic nature enables the flexible integration of
 * constants into expressions, supporting operations like addition,
 * multiplication, and notably, integration, in a mathematically sound manner.
 * </p>
 * <p>
 * This class also interacts with the {@link Expression} context to ensure
 * constants are correctly identified, managed, and reused where applicable,
 * enhancing performance and memory efficiency within the evaluation of
 * {@link Expression}s
 * </p>
 *
 * Room for improvement: memoization(caching) of repeated subexpressions within
 * an {@link Expression}
 * 
 * 
 * @param <D> type of {@link Domain} of the function, representing the set of
 *            values the {@link Function} takes as input.
 * @param <R> the type Range type of the function, representing the set of
 *            values the function can output.
 * @param <F> A functional interface extending {@link Function}, indicating the
 *            nature of the operation this node represents within an expression
 *            tree.
 * 
 * @see arb.documentation.BusinessSourceLicenseVersionOnePointOne © terms
 */
public class LiteralConstantNode<D, R, F extends Function<? extends D, ? extends R>> extends
                                Node<D, R, F>
{
  /**
   * Evaluates this literal constant at compile-timis not yet supportede,
   * returning a Java object representing its value.
   *
   * @return {@link java.lang.Integer} for integer literals, {@link Double} for
   *         decimal literals, {@link Fraction} for fraction literals (e.g. ½),
   *         {@link Double#POSITIVE_INFINITY} for infinity symbols,
   *         {@link Math#PI} for π
   * @throws UnsupportedOperationException if the constant cannot be evaluated at
   *                                       compile-time (e.g. ⅈ)
   */
  @Override
  @SuppressWarnings(
  { "unchecked", "resource" })
  public <T extends Field<T>> T evaluate(Class<T> resultType, int bits)
  {
    if (resultType.equals(Integer.class))
    {
      if (!isInt)
      {
        throw new UnsupportedTypeConversionException("literal '" + value + "' is not an Integer");
      }
      return (T) new Integer(value);
    }

    if (resultType.equals(Fraction.class))
    {
      if (fractionValue != null)
      {
        return (T) fractionValue;
      }
      if (isInt)
      {
        Fraction frac = new Fraction().set(value);
        return (T) frac;
      }
      throw new UnsupportedTypeConversionException("cannot convert literal '"
                                                   + value
                                                   + "' to Fraction");
    }

    if (resultType.equals(Real.class))
    {
      Real r = new Real();

      if (isDecimal)
      {
        r.set(value, bits);
        return (T) r;
      }

      if (fractionValue != null)
      {
        r.set(fractionValue);
        return (T) r;
      }

      if (isInt)
      {
        Integer intVal = new Integer(value);
        r.set(intVal);
        return (T) r;
      }

      throw new UnsupportedTypeConversionException("compile-time Real evaluation not implemented for literal '"
                                                   + value
                                                   + "'");
    }

    if (resultType.equals(Complex.class))
    {
      throw new UnsupportedTypeConversionException("compile-time Complex evaluation not implemented for literal '"
                                                   + value
                                                   + "'");
    }

    throw new UnsupportedTypeConversionException("unsupported requested type "
                                                 + resultType.getName()
                                                 + " for literal '"
                                                 + value
                                                 + "'");
  }

  @Override
  public boolean isConstant()
  {
    return true;
  }

  public static final Logger logger = LoggerFactory.getLogger(LiteralConstantNode.class);

  /**
   * Đ^(α)(c) = 0 for any constant c
   */
  @Override
  public Node<D, R, F> fractionalDerivative(VariableNode<D, R, F> variable, Node<D, R, F> α)
  {
    return zero();
  }

  @Override
  public Logger getLogger()
  {
    return logger;
  }

  @Override
  public boolean isNonNegativeIntegerConstant()
  {
    // TODO: improve this
    if (isInt)
    {
      try
      {
        int val = java.lang.Integer.parseInt(value);
        return val >= 0;
      }
      catch (NumberFormatException e)
      {
        return false;
      }
    }
    return false;
  }

  @Override
  public boolean isPositiveInfinity()
  {
    if (super.isPositiveInfinity())
    {
      return true;
    }
    switch (value)
    {
    case "inf":
    case "infty":
    case "infinity":
      return true;
    default:
      return false;
    }
  }

  @Override
  public boolean isHalf()
  {
    String str = toString();
    return str.equals("½") || str.equals("0.5");
  }

  @Override
  public int hashCode()
  {
    return Objects.hash(value);
  }

  @Override
  public boolean equals(Object obj)
  {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    LiteralConstantNode<?, ?, ?> other = (LiteralConstantNode<?, ?, ?>) obj;
    return Objects.equals(value, other.value);
  }

  @Override
  public boolean isPossiblyNegative()
  {
    return value.contains("-");
  }

  static final String BITLESS_METHOD_DESCRIPTOR = Compiler.getMethodDescriptor(Void.class,
                                                                               String.class);

  static final String METHOD_DESCRIPTOR         = Compiler.getMethodDescriptor(Void.class,
                                                                               String.class,
                                                                               int.class);

  @Override
  public boolean dependsOn(VariableNode<D, R, F> variable)
  {
    return false;
  }

  public static HashSet<String> constantSymbols = new HashSet<String>();

  static
  {
    constantSymbols.add("pi");
    constantSymbols.add("π");
    constantSymbols.add("ⅈ");
    constantSymbols.add("∞");
    constantSymbols.add("infinity");
    constantSymbols.add("infty");
    constantSymbols.add("inf");
  }

  public static boolean isPredefinedConstant(String var)
  {
    return constantSymbols.contains(var);
  }

  public final boolean  isInt;

  public final String   value;

  public final boolean  isImaginary;

  public final Fraction fractionValue;

  public final boolean  isDecimal;

  public final boolean  isFraction;

  public LiteralConstantNode(Expression<D, R, F> expression, String constantValueString)
  {
    this(expression,
         constantValueString,
         null);

  }

  public LiteralConstantNode(Expression<D, R, F> expression,
                             String constantValueString,
                             String name)
  {
    super(expression);
    assert Integer.class.equals(arb.Integer.class) : "an import statement for arb.Integer is probably missing";
    value       = Parser.subscriptAndSuperscriptsToRegular(constantValueString.trim());

    isDecimal   = value.contains(".");
    isImaginary = "ⅈ".equals(value);
    char firstCharOfValue = value.charAt(0);
    fractionValue = Parser.fractions.get(firstCharOfValue);
    if (fractionValue != null)
    {
      fieldName  = Parser.fractionFieldNames.get(firstCharOfValue);
      isFraction = true;
      isInt      = false;
      return;
    }
    else
    {
      isFraction = false;
    }
    isInt = !((isDecimal || constantSymbols.contains(value)) || isFraction);

    if ("pi".equals(constantValueString))
    {
      constantValueString = "π";
    }
    if (isPredefinedConstant(constantValueString) || fractionValue != null)
    {
      fieldName = constantValueString;
      return;
    }

    /**
     * Maintain a reverse-hashmap of values to LiteralConstantNodes
     */
    for (var existingConstant : expression.literalConstants.values())
    {
      if (existingConstant.value.equals(value))
      {
        fieldName = existingConstant.fieldName;
        return;
      }
    }

    if (name != null)
    {
      fieldName = name;
    }

    boolean fieldNameConflicts = expression.literalConstants.get(fieldName) != null;
    boolean needsNewFieldName  = fieldName == null || fieldNameConflicts;
    if (needsNewFieldName)
    {
      fieldName = expression.getNextConstantFieldName(type());
    }

    expression.literalConstants.put(fieldName, this);
  }

  public ClassVisitor declareField(ClassVisitor classVisitor)
  {

    Class<?> type           = type();
    String   typeDescriptor = type.descriptorString();
    if (Expression.trace)
    {
      logger.debug("declareField: fieldName={} type={} value={}", fieldName, type, toString());
    }
    classVisitor.visitField(ACC_PUBLIC | ACC_FINAL, fieldName, typeDescriptor, null, null);
    return classVisitor;
  }

  @Override
  public MethodVisitor generate(MethodVisitor mv, Class<?> resultType)
  {
    generatedType = type();
    switch (fieldName)
    {
    case "π":
      loadRealConstantOntoStack(mv, "π");
      break;
    case "∞":
    case "infinity":
    case "inf":
    case "infty":
      loadRealConstantOntoStack(mv, "infinity");
      break;
    case "ⅈ":
      loadComplexConstantOntoStack(mv, "ⅈ");
      break;
    default:
      if (fractionValue != null)
      {
        loadLiteralFractionConstantOntoStack(mv);
      }
      else
      {
        loadLiteralConstantOntoStack(mv);
      }
    }

    var typeBefore = generatedType;
    if (!resultType.equals(generatedType))
    {
      generateCastTo(mv, resultType);
    }

    if (isResult)
    {
      expression.generateSetResultInvocation(mv, generatedType);
    }

    return mv;
  }

  public MethodVisitor loadLiteralConstantOntoStack(MethodVisitor mv)
  {
    expression.loadFieldOntoStack(loadThisOntoStack(mv),
                                  fieldName,
                                  generatedType.descriptorString());
    return mv;
  }

  public MethodVisitor loadLiteralFractionConstantOntoStack(MethodVisitor mv)
  {
    loadConstantOntoStack(mv, fieldName, Fraction.class, FractionConstants.class);
    return mv;
  }

  public MethodVisitor generateLiteralConstantInitializer(MethodVisitor methodVisitor)
  {
    Class<?> type = type();

    duplicateTopOfTheStack(generateNewObjectInstruction(loadThisOntoStack(methodVisitor), type));

    if (fractionValue != null)
    {
      generateFractionConstructor(methodVisitor);
    }
    else
    {
      generateConstructor(methodVisitor, type);
    }

    return expression.setThisField(methodVisitor, fieldName, type);
  }

  protected MethodVisitor generateConstructor(MethodVisitor methodVisitor, Class<?> type)
  {
    methodVisitor.visitLdcInsn(value);
    boolean needsBitsPassedToStringConstructor = type.equals(Real.class);
    if (needsBitsPassedToStringConstructor)
    {
      methodVisitor.visitIntInsn(SIPUSH, bits);
    }
    String constructorDescriptor = needsBitsPassedToStringConstructor ? METHOD_DESCRIPTOR
                                                                      : BITLESS_METHOD_DESCRIPTOR;
    methodVisitor.visitMethodInsn(INVOKESPECIAL,
                                  Type.getInternalName(type),
                                  "<init>",
                                  constructorDescriptor,
                                  false);
    return methodVisitor;
  }

  protected MethodVisitor generateFractionConstructor(MethodVisitor methodVisitor)
  {
    methodVisitor.visitLdcInsn(fractionValue.getNumerator());
    methodVisitor.visitLdcInsn(fractionValue.getDenominator());
    methodVisitor.visitMethodInsn(INVOKESPECIAL,
                                  Type.getInternalName(Fraction.class),
                                  "<init>",
                                  "(JJ)V",
                                  false);
    return methodVisitor;
  }

  @Override
  public String toString()
  {
    return value.startsWith("-") ? "(" + value + ")" : value;
  }

  public String toString(int depth)
  {
    return String.format("%s[fieldName=%s, value=%s, depth=%s]",
                         getClass().getSimpleName(),
                         fieldName,
                         value,
                         depth);
  }

  @Override
  public Class<?> type()
  {
    return fractionValue != null ? Fraction.class : isInt ? Integer.class
                         : isImaginary ? Complex.class : Real.class;
  }

  @Override
  public String typeset()
  {
    if ("π".equals(value))
    {
      return "\\pi";
    }
    else if (fractionValue != null)
    {
      return String.format("\\frac{%s}{%s}",
                           fractionValue.getNumerator(),
                           fractionValue.getDenominator());
    }
    else
    {
      return value;
    }
  }

  @Override
  public boolean isLeaf()
  {
    return true;
  }

  @Override
  public List<Node<D, R, F>> getBranches()
  {
    return List.of();
  }

  @Override
  public Node<D, R, F> integral(VariableNode<D, R, F> variable)
  {
    return mul(variable);
  }

  public <E, S, G extends Function<? extends E, ? extends S>>
         Node<D, R, F>
         substitute(String variable, Node<E, S, G> arg)
  {
    return this;
  }

  @Override
  public <E, S, G extends Function<? extends E, ? extends S>>
         Node<E, S, G>
         spliceInto(Expression<E, S, G> newExpression)
  {
    return new LiteralConstantNode<E, S, G>(newExpression,
                                            value,
                                            fieldName);
  }

  @Override
  public void accept(Consumer<Node<D, R, F>> t)
  {
    t.accept(this);
  }

  @Override
  public Node<D, R, F> differentiate(VariableNode<D, R, F> variable)
  {
    return expression.newConstant(0);
  }

  @Override
  public boolean isScalar()
  {
    return true;
  }

  @Override
  public char symbol()
  {
    return '#';
  }

  @Override
  public boolean isZero()
  {
    return "0".equals(value) || (fractionValue != null && fractionValue.isZero());
  }

  @Override
  public boolean isOne()
  {
    return "1".equals(value) || (fractionValue != null && fractionValue.isOne());
  }

  @Override
  public boolean isNegOne()
  {
    return "-1".equals(value);
  }

  public Integer asInteger()
  {
    assert isInt : this + " is not an integer";
    return new Integer(value);
  }

}
