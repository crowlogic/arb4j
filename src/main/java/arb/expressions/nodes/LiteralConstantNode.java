package arb.expressions.nodes;

import static arb.expressions.Compiler.duplicateTopOfTheStack;
import static arb.expressions.Compiler.loadThisOntoStack;
import static org.objectweb.asm.Opcodes.ACC_FINAL;
import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
import static org.objectweb.asm.Opcodes.INVOKESPECIAL;
import static org.objectweb.asm.Opcodes.NEW;
import static org.objectweb.asm.Opcodes.SIPUSH;

import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.function.Consumer;

import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

import arb.*;
import arb.Integer;
import arb.documentation.BusinessSourceLicenseVersionOnePointOne;
import arb.documentation.TheArb4jLibrary;
import arb.domains.Domain;
import arb.expressions.Compiler;
import arb.expressions.Expression;
import arb.expressions.Parser;
import arb.functions.Function;

/**
 * Represents a literal constant within an arithmetic expression. This class is
 * used to encapsulate specific constant values, such as mathematical constants
 * (π, ½), within the expression tree of the {@link arb.expressions.Expression}
 * framework. It extends the generic {@link Node} to fit within the structure of
 * an expression tree, allowing arithmetic and symbolic operations to be
 * performed on constants.
 * <p>
 * The {@code LiteralConstant} node dynamically identifies and handles constants
 * defined at runtime and supports the declaration of such constants in
 * generated bytecode. This dynamic nature enables the flexible integration of
 * constants into expressions, supporting operations like addition,
 * multiplication, and notably, integration, in a mathematically sound manner.
 * </p>
 * <p>
 * This class also interacts with the {@link Expression} context to ensure
 * constants are correctly identified, managed, and reused where applicable,
 * enhancing performance and memory efficiency within the evaluation of
 * {@link Expression}s
 * </p>
 *
 * Room for improvement: memoization(caching) of repeated subexpressions within
 * an {@link Expression}
 * 
 * 
 * @param <D> type of {@link Domain} of the function, representing the set of
 *            values the {@link Function} takes as input.
 * @param <R> the type Range type of the function, representing the set of
 *            values the function can output.
 * @param <F> A functional interface extending {@link Function}, indicating the
 *            nature of the operation this node represents within an expression
 *            tree.
 * 
 * @see BusinessSourceLicenseVersionOnePointOne © terms of the
 *      {@link TheArb4jLibrary}
 */
public class LiteralConstantNode<D, R, F extends Function<? extends D, ? extends R>> extends
                                Node<D, R, F>
{

  @Override
  public int hashCode()
  {
    return Objects.hash(value);
  }

  @Override
  public boolean equals(Object obj)
  {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    LiteralConstantNode<?, ?, ?> other = (LiteralConstantNode<?, ?, ?>) obj;
    return Objects.equals(value, other.value);
  }

  @Override
  public boolean isPossiblyNegative()
  {
    return value.contains("-");
  }

  static final String METHOD_DESCRIPTOR_WITHOUT_BITS = Compiler.getMethodDescriptor(Void.class, String.class);

  static final String METHOD_DESCRIPTOR_WITH_BITS    =
                                                  Compiler.getMethodDescriptor(Void.class, String.class, int.class);

  @Override
  public boolean dependsOn(VariableNode<D, R, F> variable)
  {
    return false;
  }

  public static final String    infinity        = "∞";

  public static final String    π               = "π";

  public static final String    ⅈ               = "ⅈ";

  public static HashSet<String> constantSymbols = new HashSet<String>();
  static
  {
    constantSymbols.add(π);
    constantSymbols.add(ⅈ);
    constantSymbols.add(infinity);
  }

  public static boolean isPredefinedConstant(String var)
  {
    return constantSymbols.contains(var);
  }

  public boolean       isInt       = false;

  public final String  value;

  public boolean       isImaginary = false;

  public Fraction      fractionValue;

  public final boolean isDecimal;

  public final boolean isFraction;

  public LiteralConstantNode(Expression<D, R, F> expression, String constantValueString)
  {
    this(expression,
         constantValueString,
         null);

  }

  public LiteralConstantNode(Expression<D, R, F> expression, String constantValueString, String name)
  {
    super(expression);
    assert Integer.class.equals(arb.Integer.class) : "an import statement for arb.Integer is probably missing";
    value       = Parser.subscriptToRegular(constantValueString.trim());

    isDecimal   = value.contains(".");
    isImaginary = ⅈ.equals(value);
    char firstCharOfValue = value.charAt(0);
    fractionValue = Parser.fractions.get(firstCharOfValue);
    if (fractionValue != null)
    {
      fieldName  = Parser.fractionFieldNames.get(firstCharOfValue);
      isFraction = true;
      return;
    }
    else
    {
      isFraction = false;
    }
    isInt = !((isDecimal || constantSymbols.contains(value)) || isFraction);

    if (isPredefinedConstant(constantValueString) || fractionValue != null)
    {
      fieldName = constantValueString;
      return;
    }

    for (var existingConstant : expression.literalConstants.values())
    {
      if (existingConstant.value.equals(value))
      {
        fieldName = existingConstant.fieldName;
        return;
      }
    }

    if (name != null)
    {
      fieldName = name;
    }

    boolean fieldNameConflicts = expression.literalConstants.get(fieldName) != null;
    boolean needsNewFieldName  = fieldName == null || fieldNameConflicts;
    if (needsNewFieldName)
    {
      fieldName = expression.getNextConstantFieldName(type());
    }

    expression.literalConstants.put(fieldName, this);
  }

  public ClassVisitor declareField(ClassVisitor classVisitor)
  {
    classVisitor.visitField(ACC_PUBLIC | ACC_FINAL, fieldName, type().descriptorString(), null, null);
    return classVisitor;
  }

  @Override
  public MethodVisitor generate(MethodVisitor mv, Class<?> resultType)
  {
    generatedType = type();
    if (fractionValue != null)
    {
      loadConstantOntoStack(mv, fieldName, Fraction.class, FractionConstants.class);
    }
    else if (π.equals(fieldName))
    {
      loadRealConstantOntoStack(mv, π);
    }
    else if (infinity.equals(fieldName))
    {
      loadRealConstantOntoStack(mv, "infinity");
    }
    else if (ⅈ.equals(fieldName))
    {
      loadImaginaryUnitConstantOntoStack(mv, ⅈ);
    }
    else
    {
      expression.loadFieldOntoStack(loadThisOntoStack(mv), fieldName, generatedType.descriptorString());
    }

    if (!resultType.equals(generatedType))
    {
      if (Expression.trace)
      {
        System.err.format("generateCastTo(resultType=%s) from generatedType=%s\n", resultType, generatedType);
      }
      generateCastTo(mv, resultType);
    }

    if (isResult)
    {
      expression.generateSetResultInvocation(mv, generatedType);
    }

    return mv;
  }

  public MethodVisitor generateLiteralConstantInitializerWithString(MethodVisitor methodVisitor)
  {
    Class<?> type = type();
    loadThisOntoStack(methodVisitor);
    methodVisitor.visitTypeInsn(NEW, Type.getInternalName(type));
    duplicateTopOfTheStack(methodVisitor);

    if (fractionValue != null)
    {
      methodVisitor.visitLdcInsn(fractionValue.getNumerator());
      methodVisitor.visitLdcInsn(fractionValue.getDenominator());
      methodVisitor.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(Fraction.class), "<init>", "(JJ)V", false);
    }
    else
    {
      methodVisitor.visitLdcInsn(value);
      boolean needsBitsPassedToStringConstructor = type.equals(Real.class);
      if (needsBitsPassedToStringConstructor)
      {
        methodVisitor.visitIntInsn(SIPUSH, bits);
      }
      String constructorDescriptor = needsBitsPassedToStringConstructor ? METHOD_DESCRIPTOR_WITH_BITS
                                                                        : METHOD_DESCRIPTOR_WITHOUT_BITS;
      methodVisitor.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(type), "<init>", constructorDescriptor, false);
    }

    expression.putField(methodVisitor, fieldName, type);
    return methodVisitor;
  }

  public void loadRealConstantOntoStack(MethodVisitor mv, String fn)
  {
    loadConstantOntoStack(mv, fn, Real.class, RealConstants.class);
  }

  public void loadImaginaryUnitConstantOntoStack(MethodVisitor mv, String fn)
  {
    loadConstantOntoStack(mv, fn, Complex.class, ComplexConstants.class);
  }

  public void
         loadConstantOntoStack(MethodVisitor mv, String fieldName, Class<?> typeClass, Class<?> staticConstantsClass)
  {
    mv.visitFieldInsn(Opcodes.GETSTATIC,
                      Type.getInternalName(staticConstantsClass),
                      fieldName,
                      typeClass.descriptorString());
  }

  @Override
  public String toString()
  {
    return value;
  }

  public String toString(int depth)
  {
    return String.format("%s[fieldName=%s, value=%s, depth=%s]", getClass().getSimpleName(), fieldName, value, depth);
  }

  @Override
  public Class<?> type()
  {
    if (fractionValue != null)
    {
      return Fraction.class;
    }
    return isInt ? Integer.class : isImaginary ? Complex.class : Real.class;
  }

  @Override
  public String typeset()
  {
    if (π.equals(value))
    {
      return "\\pi";
    }
    else if (fractionValue != null)
    {
      return String.format("\\frac{%s}{%s}", fractionValue.getNumerator(), fractionValue.getDenominator());
    }
    else
    {
      return value;
    }
  }

  @Override
  public boolean isLeaf()
  {
    return true;
  }

  @Override
  public List<Node<D, R, F>> getBranches()
  {
    return List.of();
  }

  @Override
  public Node<D, R, F> integrate(VariableNode<D, R, F> variable)
  {
    return mul(variable);
  }

  public <E, S, G extends Function<? extends E, ? extends S>> Node<D, R, F> substitute(String variable,
                                                                                       Node<E, S, G> arg)
  {
    return this;
  }

  @Override
  public <E, S, G extends Function<? extends E, ? extends S>>
         Node<E, S, G>
         spliceInto(Expression<E, S, G> newExpression)
  {
    return new LiteralConstantNode<E, S, G>(newExpression,
                                            value,
                                            fieldName);
  }

  @Override
  public void accept(Consumer<Node<D, R, F>> t)
  {
    t.accept(this);
  }

  @Override
  public Node<D, R, F> differentiate(VariableNode<D, R, F> variable)
  {
    return new LiteralConstantNode<>(expression,
                                     "0");
  }

  @Override
  public boolean isScalar()
  {
    return true;
  }

  @Override
  public char symbol()
  {
    return '#';
  }

  @Override
  public boolean isLiteralConstant()
  {
    return true;
  }

  public static <D, R, F extends Function<? extends D, ? extends R>> Node<D, R, F> of(Expression<D, R, F> expr, int i)
  {
    return new LiteralConstantNode<>(expr,
                                     java.lang.Integer.toString(i));
  }
}