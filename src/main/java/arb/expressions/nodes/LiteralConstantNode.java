package arb.expressions.nodes;

import static arb.expressions.Compiler.*;
import static org.objectweb.asm.Opcodes.*;

import java.util.*;
import java.util.function.Consumer;

import org.objectweb.asm.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import arb.*;
import arb.Integer;
import arb.domains.Domain;
import arb.exceptions.UnsupportedTypeConversionException;
import arb.expressions.*;
import arb.functions.Function;

/**
 * Represents a literal constant within an arithmetic expression. This class is
 * used to encapsulate specific constant values, such as mathematical constants
 * (π, ½), within the expression tree of the {@link arb.expressions.Expression}
 * framework. It extends the generic {@link Node} to fit within the structure of
 * an expression tree, allowing arithmetic and symbolic operations to be
 * performed on constants.
 * <p>
 * The {@code LiteralConstant} node dynamically identifies and handles constants
 * defined at runtime and supports the declaration of such constants in
 * generated bytecode. This dynamic nature enables the flexible integration of
 * constants into expressions, supporting operations like addition,
 * multiplication, and notably, integration, in a mathematically sound manner.
 * </p>
 * <p>
 * This class also interacts with the {@link Expression} context to ensure
 * constants are correctly identified, managed, and reused where applicable,
 * enhancing performance and memory efficiency within the evaluation of
 * {@link Expression}s
 * </p>
 *
 * Room for improvement: memoization(caching) of repeated subexpressions within
 * an {@link Expression}
 * 
 * 
 * @param <D> type of {@link Domain} of the function, representing the set of
 *            values the {@link Function} takes as input.
 * @param <R> the type Range type of the function, representing the set of
 *            values the function can output.
 * @param <F> A functional interface extending {@link Function}, indicating the
 *            nature of the operation this node represents within an expression
 *            tree.
 * 
 * @see arb.documentation.BusinessSourceLicenseVersionOnePointOne © terms
 */
public class LiteralConstantNode<D, R, F extends Function<? extends D, ? extends R>> extends
                                Node<D, R, F>
{
  @Override
  @SuppressWarnings(
  { "unchecked", "resource" })
  public <T> T evaluate(Class<T> resultType, T result)
  {
    if (resultType.equals(Integer.class))
    {
      Integer res = (Integer) result;
      if (integerValue != null)
      {
        res.set(integerValue);
        return (T) res;
      }
      if (!isInt)
      {
        throw new UnsupportedTypeConversionException("literal '" + value + "' is not an Integer");
      }
      res.set(value);
      return (T) res;
    }

    if (resultType.equals(Fraction.class))
    {
      Fraction res = (Fraction) result;
      if (fractionValue != null)
      {
        res.set(fractionValue);
        return (T) res;
      }
      if (integerValue != null)
      {
        res.set(integerValue);
        return (T) res;
      }
      if (isInt)
      {
        res.set(value);
        return (T) res;
      }
      throw new UnsupportedTypeConversionException("cannot convert literal '"
                                                   + value
                                                   + "' to Fraction");
    }

    if (resultType.equals(Real.class))
    {
      Real res = (Real) result;

      if (isDecimal)
      {
        res.set(value, bits);
        return (T) res;
      }

      if (fractionValue != null)
      {
        res.set(fractionValue);
        return (T) res;
      }

      if (integerValue != null)
      {
        res.set(integerValue);
        return (T) res;
      }

      if (isInt)
      {
        try ( Integer intVal = new Integer(value))
        {
          res.set(intVal);
        }
        return (T) res;
      }

      throw new UnsupportedTypeConversionException("compile-time Real evaluation not implemented for literal '"
                                                   + value
                                                   + "'");
    }

    if (resultType.equals(Complex.class))
    {
      throw new UnsupportedTypeConversionException("compile-time Complex evaluation not implemented for literal '"
                                                   + value
                                                   + "'");
    }

    throw new UnsupportedTypeConversionException("unsupported requested type "
                                                 + resultType.getName()
                                                 + " for literal '"
                                                 + value
                                                 + "'");
  }

  @Override
  public boolean isConstant()
  {
    return true;
  }

  public static final Logger logger = LoggerFactory.getLogger(LiteralConstantNode.class);

  /**
   * Đ^(α)(c) = 0 for any constant c
   */
  @Override
  public Node<D, R, F> fractionalDerivative(VariableNode<D, R, F> variable, Node<D, R, F> α)
  {
    return zero();
  }

  @Override
  public Logger getLogger()
  {
    return logger;
  }

  @Override
  public boolean isNonNegativeIntegerConstant()
  {
    if (integerValue != null)
    {
      return integerValue.sign() >= 0;
    }
    if (isInt)
    {
      try
      {
        int val = java.lang.Integer.parseInt(value);
        return val >= 0;
      }
      catch (NumberFormatException e)
      {
        return false;
      }
    }
    return false;
  }

  @Override
  public boolean isPositiveInfinity()
  {
    if (super.isPositiveInfinity())
    {
      return true;
    }
    switch (value)
    {
    case "inf":
    case "infty":
    case "infinity":
      return true;
    default:
      return false;
    }
  }

  @Override
  public boolean isHalf()
  {
    if (fractionValue != null)
    {
      return fractionValue.getNumerator().getSignedValue() == 1
                    && fractionValue.getDenominator().getSignedValue() == 2;
    }
    String str = toString();
    return str.equals("½") || str.equals("0.5");
  }

  @Override
  public int hashCode()
  {
    return Objects.hash(value);
  }

  @Override
  public boolean equals(Object obj)
  {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    LiteralConstantNode<?, ?, ?> other = (LiteralConstantNode<?, ?, ?>) obj;
    return Objects.equals(value, other.value);
  }

  @Override
  public boolean isPossiblyNegative()
  {
    if (integerValue != null)
    {
      return integerValue.sign() < 0;
    }
    if (fractionValue != null)
    {
      return fractionValue.sign() < 0;
    }
    return value.contains("-");
  }

  static final String BITLESS_METHOD_DESCRIPTOR = Compiler.getMethodDescriptor(Void.class,
                                                                               String.class);

  static final String METHOD_DESCRIPTOR         = Compiler.getMethodDescriptor(Void.class,
                                                                               String.class,
                                                                               int.class);

  @Override
  public boolean dependsOn(VariableNode<D, R, F> variable)
  {
    return false;
  }

  public static HashSet<String> constantSymbols = new HashSet<String>();

  static
  {
    constantSymbols.add("pi");
    constantSymbols.add("π");
    constantSymbols.add("ⅈ");
    constantSymbols.add("∞");
    constantSymbols.add("infinity");
    constantSymbols.add("infty");
    constantSymbols.add("inf");
  }

  public static boolean isPredefinedConstant(String var)
  {
    return constantSymbols.contains(var);
  }

  public final boolean  isInt;

  public final String   value;

  public final boolean  isImaginary;

  public final Fraction fractionValue;

  public final Integer  integerValue;

  public final boolean  isDecimal;

  public final boolean  isFraction;

  public LiteralConstantNode(Expression<D, R, F> expression, String constantValueString)
  {
    this(expression,
         constantValueString,
         null);
  }

  public LiteralConstantNode(Expression<D, R, F> expression,
                             String constantValueString,
                             String name)
  {
    super(expression);
    assert Integer.class.equals(arb.Integer.class) : "an import statement for arb.Integer is probably missing";
    value       = Parser.subscriptAndSuperscriptsToRegular(constantValueString.trim());

    isDecimal   = value.contains(".");
    isImaginary = "ⅈ".equals(value);
    char firstCharOfValue = value.charAt(0);
    fractionValue = Parser.fractions.get(firstCharOfValue);
    integerValue  = null;
    if (fractionValue != null)
    {
      fieldName  = Parser.fractionFieldNames.get(firstCharOfValue);
      isFraction = true;
      isInt      = false;
      return;
    }
    else
    {
      isFraction = false;
    }
    isInt = !((isDecimal || constantSymbols.contains(value)) || isFraction);

    if ("pi".equals(constantValueString))
    {
      constantValueString = "π";
    }
    if (isPredefinedConstant(constantValueString) || fractionValue != null)
    {
      fieldName = constantValueString;
      return;
    }

    for (var existingConstant : expression.literalConstants.values())
    {
      if (existingConstant.value.equals(value))
      {
        fieldName = existingConstant.fieldName;
        return;
      }
    }

    if (name != null)
    {
      fieldName = name;
    }

    boolean fieldNameConflicts = expression.literalConstants.get(fieldName) != null;
    boolean needsNewFieldName  = fieldName == null || fieldNameConflicts;
    if (needsNewFieldName)
    {
      fieldName = expression.getNextConstantFieldName(type());
    }

    expression.literalConstants.put(fieldName, this);
  }

  /**
   * Constructs a LiteralConstantNode directly from an arb.Integer value,
   * bypassing string parsing.
   */
  public LiteralConstantNode(Expression<D, R, F> expression, Integer intValue)
  {
    super(expression);
    this.integerValue  = intValue;
    this.value         = intValue.toString();
    this.isInt         = true;
    this.isDecimal     = false;
    this.isImaginary   = false;
    this.isFraction    = false;
    this.fractionValue = null;

    for (var existingConstant : expression.literalConstants.values())
    {
      if (existingConstant.value.equals(value))
      {
        fieldName = existingConstant.fieldName;
        return;
      }
    }
    fieldName = expression.getNextConstantFieldName(type());
    expression.literalConstants.put(fieldName, this);
  }

  /**
   * Constructs a LiteralConstantNode directly from a Fraction value. If the
   * denominator is 1, this is stored as an integer literal. Otherwise stored as a
   * fraction literal with the Fraction object carried directly, no string parsing
   * involved.
   */
  public LiteralConstantNode(Expression<D, R, F> expression, Fraction fraction)
  {
    super(expression);
    long num = fraction.getNumerator().getSignedValue();
    long den = fraction.getDenominator().getSignedValue();
    if (den == 1)
    {
      this.value         = Long.toString(num);
      this.isInt         = true;
      this.isFraction    = false;
      this.fractionValue = null;
      this.integerValue  = new Integer(num);
    }
    else if (den == -1)
    {
      this.value         = Long.toString(-num);
      this.isInt         = true;
      this.isFraction    = false;
      this.fractionValue = null;
      this.integerValue  = new Integer(-num);
    }
    else
    {
      this.value         = num + "/" + den;
      this.isInt         = false;
      this.isFraction    = true;
      this.fractionValue = new Fraction();
      this.fractionValue.set(fraction);
      this.integerValue = null;
    }
    this.isDecimal   = false;
    this.isImaginary = false;

    for (var existingConstant : expression.literalConstants.values())
    {
      if (existingConstant.value.equals(value))
      {
        fieldName = existingConstant.fieldName;
        return;
      }
    }
    fieldName = expression.getNextConstantFieldName(type());
    expression.literalConstants.put(fieldName, this);
  }

  public ClassVisitor declareField(ClassVisitor classVisitor)
  {
    Class<?> type           = type();
    String   typeDescriptor = type.descriptorString();
    if (Expression.trace)
    {
      logger.debug("declareField: fieldName={} type={} value={}", fieldName, type, toString());
    }
    classVisitor.visitField(ACC_PUBLIC | ACC_FINAL, fieldName, typeDescriptor, null, null);
    return classVisitor;
  }

  @Override
  public MethodVisitor generate(MethodVisitor mv, Class<?> resultType)
  {
    generatedType = type();
    switch (fieldName)
    {
    case "π":
      loadRealConstantOntoStack(mv, "π");
      break;
    case "∞":
    case "infinity":
    case "inf":
    case "infty":
      loadRealConstantOntoStack(mv, "infinity");
      break;
    case "ⅈ":
      loadComplexConstantOntoStack(mv, "ⅈ");
      break;
    default:
      if (fractionValue != null)
      {
        loadLiteralFractionConstantOntoStack(mv);
      }
      else
      {
        loadLiteralConstantOntoStack(mv);
      }
    }

    var typeBefore = generatedType;
    if (!resultType.equals(generatedType))
    {
      generateCastTo(mv, resultType);
    }

    if (isResult)
    {
      expression.generateSetResultInvocation(mv, generatedType);
    }

    return mv;
  }

  public MethodVisitor loadLiteralConstantOntoStack(MethodVisitor mv)
  {
    expression.loadFieldOntoStack(loadThisOntoStack(mv),
                                  fieldName,
                                  generatedType.descriptorString());
    return mv;
  }

  public MethodVisitor loadLiteralFractionConstantOntoStack(MethodVisitor mv)
  {
    loadConstantOntoStack(mv, fieldName, Fraction.class, FractionConstants.class);
    return mv;
  }

  public MethodVisitor generateLiteralConstantInitializer(MethodVisitor methodVisitor)
  {
    Class<?> type = type();

    duplicateTopOfTheStack(generateNewObjectInstruction(loadThisOntoStack(methodVisitor), type));

    if (fractionValue != null)
    {
      generateFractionConstructor(methodVisitor);
    }
    else
    {
      generateConstructor(methodVisitor, type);
    }

    return expression.setThisField(methodVisitor, fieldName, type);
  }

  protected MethodVisitor generateConstructor(MethodVisitor methodVisitor, Class<?> type)
  {
    methodVisitor.visitLdcInsn(value);
    boolean needsBitsPassedToStringConstructor = type.equals(Real.class);
    if (needsBitsPassedToStringConstructor)
    {
      methodVisitor.visitIntInsn(SIPUSH, bits);
    }
    String constructorDescriptor = needsBitsPassedToStringConstructor ? METHOD_DESCRIPTOR
                                                                      : BITLESS_METHOD_DESCRIPTOR;
    methodVisitor.visitMethodInsn(INVOKESPECIAL,
                                  Type.getInternalName(type),
                                  "<init>",
                                  constructorDescriptor,
                                  false);
    return methodVisitor;
  }

  protected MethodVisitor generateFractionConstructor(MethodVisitor methodVisitor)
  {
    methodVisitor.visitLdcInsn(fractionValue.getNumerator().getSignedValue());
    methodVisitor.visitLdcInsn(fractionValue.getDenominator().getSignedValue());
    methodVisitor.visitMethodInsn(INVOKESPECIAL,
                                  Type.getInternalName(Fraction.class),
                                  "<init>",
                                  "(JJ)V",
                                  false);
    return methodVisitor;
  }

  @Override
  public String toString()
  {
    return value.startsWith("-") ? "(" + value + ")" : value;
  }

  public String toString(int depth)
  {
    return String.format("%s[fieldName=%s, value=%s, depth=%s]",
                         getClass().getSimpleName(),
                         fieldName,
                         value,
                         depth);
  }

  @Override
  public Class<?> type()
  {
    return fractionValue != null ? Fraction.class : isInt ? Integer.class
                         : isImaginary ? Complex.class : Real.class;
  }

  @Override
  public String typeset()
  {
    if ("π".equals(value))
    {
      return "\\pi";
    }
    else if (fractionValue != null)
    {
      return String.format("\\frac{%s}{%s}",
                           fractionValue.getNumerator(),
                           fractionValue.getDenominator());
    }
    else
    {
      return value;
    }
  }

  @Override
  public boolean isLeaf()
  {
    return true;
  }

  @Override
  public List<Node<D, R, F>> getBranches()
  {
    return List.of();
  }

  @Override
  public Node<D, R, F> integral(VariableNode<D, R, F> variable)
  {
    return mul(variable);
  }

  public <E, S, G extends Function<? extends E, ? extends S>>
         Node<D, R, F>
         substitute(String variable, Node<E, S, G> arg)
  {
    return this;
  }

  @Override
  public <E, S, G extends Function<? extends E, ? extends S>>
         Node<E, S, G>
         spliceInto(Expression<E, S, G> newExpression)
  {
    return new LiteralConstantNode<E, S, G>(newExpression,
                                            value,
                                            fieldName);
  }

  @Override
  public void accept(Consumer<Node<D, R, F>> t)
  {
    t.accept(this);
  }

  @Override
  public Node<D, R, F> differentiate(VariableNode<D, R, F> variable)
  {
    return expression.newLiteralConstant(0);
  }

  @Override
  public boolean isScalar()
  {
    return true;
  }

  @Override
  public char symbol()
  {
    return '#';
  }

  @Override
  public boolean isZero()
  {
    if (integerValue != null)
    {
      return integerValue.isZero();
    }
    return "0".equals(value) || (fractionValue != null && fractionValue.isZero());
  }

  @Override
  public boolean isOne()
  {
    if (integerValue != null)
    {
      return integerValue.isOne();
    }
    return "1".equals(value) || (fractionValue != null && fractionValue.isOne());
  }

  @Override
  public boolean isNegOne()
  {
    if (integerValue != null)
    {
      return integerValue.getSignedValue() == -1;
    }
    return "-1".equals(value);
  }

  public Integer asInteger()
  {
    if (integerValue != null)
    {
      return integerValue;
    }
    assert isInt : this + " is not an integer";
    return new Integer(value);
  }

}
