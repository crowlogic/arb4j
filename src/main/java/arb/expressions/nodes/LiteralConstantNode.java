package arb.expressions.nodes;

import static arb.expressions.Compiler.duplicateTopOfTheStack;
import static arb.expressions.Compiler.generateNewObjectInstruction;
import static arb.expressions.Compiler.loadComplexConstantOntoStack;
import static arb.expressions.Compiler.loadConstantOntoStack;
import static arb.expressions.Compiler.loadRealConstantOntoStack;
import static arb.expressions.Compiler.loadThisOntoStack;
import static org.objectweb.asm.Opcodes.ACC_FINAL;
import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
import static org.objectweb.asm.Opcodes.INVOKESPECIAL;
import static org.objectweb.asm.Opcodes.SIPUSH;

import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.function.Consumer;

import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Type;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import arb.Complex;
import arb.Fraction;
import arb.FractionConstants;
import arb.Integer;
import arb.Real;
import arb.domains.Domain;
import arb.expressions.Compiler;
import arb.expressions.Expression;
import arb.expressions.Parser;
import arb.functions.Function;

/**
 * Represents a literal constant within an arithmetic expression. This class is
 * used to encapsulate specific constant values, such as mathematical constants
 * (π, ½), within the expression tree of the {@link arb.expressions.Expression}
 * framework. It extends the generic {@link Node} to fit within the structure of
 * an expression tree, allowing arithmetic and symbolic operations to be
 * performed on constants.
 * <p>
 * The {@code LiteralConstant} node dynamically identifies and handles constants
 * defined at runtime and supports the declaration of such constants in
 * generated bytecode. This dynamic nature enables the flexible integration of
 * constants into expressions, supporting operations like addition,
 * multiplication, and notably, integration, in a mathematically sound manner.
 * </p>
 * <p>
 * This class also interacts with the {@link Expression} context to ensure
 * constants are correctly identified, managed, and reused where applicable,
 * enhancing performance and memory efficiency within the evaluation of
 * {@link Expression}s
 * </p>
 *
 * Room for improvement: memoization(caching) of repeated subexpressions within
 * an {@link Expression}
 * 
 * 
 * @param <D> type of {@link Domain} of the function, representing the set of
 *            values the {@link Function} takes as input.
 * @param <R> the type Range type of the function, representing the set of
 *            values the function can output.
 * @param <F> A functional interface extending {@link Function}, indicating the
 *            nature of the operation this node represents within an expression
 *            tree.
 * 
 * @see arb.documentation.BusinessSourceLicenseVersionOnePointOne for © terms
 */
public class LiteralConstantNode<D, R, F extends Function<? extends D, ? extends R>> extends
                                Node<D, R, F>
{

  @Override
  public boolean isHalf()
  {
    String str = toString();
    return str.equals("½") || str.equals("0.5");
  }

  @Override
  public int hashCode()
  {
    return Objects.hash(value);
  }

  @Override
  public boolean equals(Object obj)
  {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    LiteralConstantNode<?, ?, ?> other = (LiteralConstantNode<?, ?, ?>) obj;
    return Objects.equals(value, other.value);
  }

  @Override
  public boolean isPossiblyNegative()
  {
    return value.contains("-");
  }

  static final String BITLESS_METHOD_DESCRIPTOR = Compiler.getMethodDescriptor(Void.class,
                                                                               String.class);

  static final String METHOD_DESCRIPTOR         = Compiler.getMethodDescriptor(Void.class,
                                                                               String.class,
                                                                               int.class);

  @Override
  public boolean dependsOn(VariableNode<D, R, F> variable)
  {
    return false;
  }

  public static final String    infinity        = "∞";

  public static final String    π               = "π";

  public static final String    ⅈ               = "ⅈ";

  public static HashSet<String> constantSymbols = new HashSet<String>();

  static
  {
    constantSymbols.add("pi");
    constantSymbols.add(π);
    constantSymbols.add(ⅈ);
    constantSymbols.add(infinity);
    constantSymbols.add("infinity");

  }

  public static boolean isPredefinedConstant(String var)
  {
    return constantSymbols.contains(var);
  }

  public final boolean  isInt;

  public final String   value;

  public final boolean  isImaginary;

  public final Fraction fractionValue;

  public final boolean  isDecimal;

  public final boolean  isFraction;

  public LiteralConstantNode(Expression<D, R, F> expression, String constantValueString)
  {
    this(expression,
         constantValueString,
         null);

  }

  public LiteralConstantNode(Expression<D, R, F> expression,
                             String constantValueString,
                             String name)
  {
    super(expression);
    assert Integer.class.equals(arb.Integer.class) : "an import statement for arb.Integer is probably missing";
    value       = Parser.subscriptAndSuperscriptsToRegular(constantValueString.trim());

    isDecimal   = value.contains(".");
    isImaginary = ⅈ.equals(value);
    char firstCharOfValue = value.charAt(0);
    fractionValue = Parser.fractions.get(firstCharOfValue);
    if (fractionValue != null)
    {
      fieldName  = Parser.fractionFieldNames.get(firstCharOfValue);
      isFraction = true;
      isInt      = false;
      return;
    }
    else
    {
      isFraction = false;
    }
    isInt = !((isDecimal || constantSymbols.contains(value)) || isFraction);

    if ("pi".equals(constantValueString))
    {
      constantValueString = "π";
    }
    if (isPredefinedConstant(constantValueString) || fractionValue != null)
    {
      fieldName = constantValueString;
      return;
    }

    for (var existingConstant : expression.literalConstants.values())
    {
      if (existingConstant.value.equals(value))
      {
        fieldName = existingConstant.fieldName;
        return;
      }
    }

    if (name != null)
    {
      fieldName = name;
    }

    boolean fieldNameConflicts = expression.literalConstants.get(fieldName) != null;
    boolean needsNewFieldName  = fieldName == null || fieldNameConflicts;
    if (needsNewFieldName)
    {
      fieldName = expression.getNextConstantFieldName(type());
    }

    expression.literalConstants.put(fieldName, this);
  }

  public ClassVisitor declareField(ClassVisitor classVisitor)
  {
    classVisitor.visitField(ACC_PUBLIC
                  | ACC_FINAL, fieldName, type().descriptorString(), null, null);
    return classVisitor;
  }

  @Override
  public MethodVisitor generate(MethodVisitor mv, Class<?> resultType)
  {
    generatedType = type();
    switch (fieldName)
    {
    case π:
      loadRealConstantOntoStack(mv, π);
      break;
    case infinity:
    case "infinity":
      loadRealConstantOntoStack(mv, "infinity");
      break;
    case ⅈ:
      loadComplexConstantOntoStack(mv, ⅈ);
      break;
    default:
      if (fractionValue != null)
      {
        loadLiteralFractionConstantOntoStack(mv);
      }
      else
      {
        loadLiteralConstantOntoStack(mv);
      }
    }

    if (!resultType.equals(generatedType))
    {
      generateCastTo(mv, resultType);
    }

    if (isResult)
    {
      expression.generateSetResultInvocation(mv, generatedType);
    }

    return mv;
  }

  public MethodVisitor loadLiteralConstantOntoStack(MethodVisitor mv)
  {
    expression.loadFieldOntoStack(loadThisOntoStack(mv),
                                  fieldName,
                                  generatedType.descriptorString());
    return mv;
  }

  public MethodVisitor loadLiteralFractionConstantOntoStack(MethodVisitor mv)
  {
    loadConstantOntoStack(mv, fieldName, Fraction.class, FractionConstants.class);
    return mv;
  }

  public MethodVisitor generateLiteralConstantInitializer(MethodVisitor methodVisitor)
  {
    Class<?> type = type();

    duplicateTopOfTheStack(generateNewObjectInstruction(loadThisOntoStack(methodVisitor), type));

    if (fractionValue != null)
    {
      generateFractionConstructor(methodVisitor);
    }
    else
    {
      generateConstructor(methodVisitor, type);
    }

    return expression.setThisField(methodVisitor, fieldName, type);
  }

  protected MethodVisitor generateConstructor(MethodVisitor methodVisitor, Class<?> type)
  {
    methodVisitor.visitLdcInsn(value);
    boolean needsBitsPassedToStringConstructor = type.equals(Real.class);
    if (needsBitsPassedToStringConstructor)
    {
      methodVisitor.visitIntInsn(SIPUSH, bits);
    }
    String constructorDescriptor = needsBitsPassedToStringConstructor ? METHOD_DESCRIPTOR
                                                                      : BITLESS_METHOD_DESCRIPTOR;
    methodVisitor.visitMethodInsn(INVOKESPECIAL,
                                  Type.getInternalName(type),
                                  "<init>",
                                  constructorDescriptor,
                                  false);
    return methodVisitor;
  }

  protected MethodVisitor generateFractionConstructor(MethodVisitor methodVisitor)
  {
    methodVisitor.visitLdcInsn(fractionValue.getNumerator());
    methodVisitor.visitLdcInsn(fractionValue.getDenominator());
    methodVisitor.visitMethodInsn(INVOKESPECIAL,
                                  Type.getInternalName(Fraction.class),
                                  "<init>",
                                  "(JJ)V",
                                  false);
    return methodVisitor;
  }

  @Override
  public String toString()
  {
    return value.startsWith("-") ? "(" + value + ")" : value;
  }

  public String toString(int depth)
  {
    return String.format("%s[fieldName=%s, value=%s, depth=%s]",
                         getClass().getSimpleName(),
                         fieldName,
                         value,
                         depth);
  }

  @Override
  public Class<?> type()
  {
    return fractionValue != null ? Fraction.class : isInt ? Integer.class
                         : isImaginary ? Complex.class : Real.class;
  }

  @Override
  public String typeset()
  {
    if (π.equals(value))
    {
      return "\\pi";
    }
    else if (fractionValue != null)
    {
      return String.format("\\frac{%s}{%s}",
                           fractionValue.getNumerator(),
                           fractionValue.getDenominator());
    }
    else
    {
      return value;
    }
  }

  @Override
  public boolean isLeaf()
  {
    return true;
  }

  @Override
  public List<Node<D, R, F>> getBranches()
  {
    return List.of();
  }

  @Override
  public Node<D, R, F> integrate(VariableNode<D, R, F> variable)
  {
    return mul(variable);
  }

  public <E, S, G extends Function<? extends E, ? extends S>>
         Node<D, R, F>
         substitute(String variable, Node<E, S, G> arg)
  {
    return this;
  }

  @Override
  public <E, S, G extends Function<? extends E, ? extends S>>
         Node<E, S, G>
         spliceInto(Expression<E, S, G> newExpression)
  {
    return new LiteralConstantNode<E, S, G>(newExpression,
                                            value,
                                            fieldName);
  }

  @Override
  public void accept(Consumer<Node<D, R, F>> t)
  {
    t.accept(this);
  }

  @Override
  public Node<D, R, F> differentiate(VariableNode<D, R, F> variable)
  {
    return expression.newLiteralConstant(0);
  }

  @Override
  public boolean isScalar()
  {
    return true;
  }

  @Override
  public char symbol()
  {
    return '#';
  }

  @Override
  public boolean isZero()
  {
    return "0".equals(value) || (fractionValue != null && fractionValue.isZero());
  }

  public boolean isOne()
  {
    return "1".equals(value) || (fractionValue != null && fractionValue.isOne());
  }

  public Integer asInteger()
  {
    assert isInt : this + " is not an integer";
    return new Integer(value);
  }

}