package arb.expressions.nodes;

import static arb.expressions.Compiler.duplicateTopOfTheStack;
import static arb.expressions.Compiler.loadThisOntoStack;
import static org.objectweb.asm.Opcodes.ACC_FINAL;
import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
import static org.objectweb.asm.Opcodes.INVOKESPECIAL;
import static org.objectweb.asm.Opcodes.NEW;
import static org.objectweb.asm.Opcodes.SIPUSH;

import java.util.HashSet;
import java.util.List;
import java.util.function.Consumer;

import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

import arb.*;
import arb.Integer;
import arb.documentation.BusinessSourceLicenseVersionOnePointOne;
import arb.documentation.TheArb4jLibrary;
import arb.domains.Domain;
import arb.exceptions.ArbException;
import arb.expressions.Compiler;
import arb.expressions.Expression;
import arb.expressions.Parser;
import arb.expressions.nodes.binary.Multiplication;
import arb.functions.Function;
import arb.utensils.Utensils;

/**
 * Represents a literal constant within an arithmetic expression. This class is
 * used to encapsulate specific constant values, such as mathematical constants
 * (π, ½), within the expression tree of the {@link arb.expressions.Expression}
 * framework. It extends the generic {@link Node} to fit within the structure of
 * an expression tree, allowing arithmetic and symbolic operations to be
 * performed on constants.
 * <p>
 * The {@code LiteralConstant} node dynamically identifies and handles constants
 * defined at runtime and supports the declaration of such constants in
 * generated bytecode. This dynamic nature enables the flexible integration of
 * constants into expressions, supporting operations like addition,
 * multiplication, and notably, integration, in a mathematically sound manner.
 * </p>
 * <p>
 * This class also interacts with the {@link Expression} context to ensure
 * constants are correctly identified, managed, and reused where applicable,
 * enhancing performance and memory efficiency within the evaluation of
 * {@link Expression}s
 * </p>
 *
 * Room for improvement: memoization(caching) of repeated subexpressions within
 * an {@link Expression}
 * 
 * 
 * @param <D> type of {@link Domain} of the function, representing the set of
 *            values the {@link Function} takes as input.
 * @param <R> the type Range type of the function, representing the set of
 *            values the function can output.
 * @param <F> A functional interface extending {@link Function}, indicating the
 *            nature of the operation this node represents within an expression
 *            tree.
 * 
 * @see BusinessSourceLicenseVersionOnePointOne © terms of the
 *      {@link TheArb4jLibrary}
 */
public class LiteralConstantNode<D, R, F extends Function<? extends D, ? extends R>>
                                extends
                                Node<D, R, F>
{
  static final String METHOD_DESCRIPTOR_WITHOUT_BITS = Compiler.getMethodDescriptor(Void.class, String.class);

  static final String METHOD_DESCRIPTOR_WITH_BITS    = Compiler.getMethodDescriptor(Void.class,
                                                                                    String.class,
                                                                                    int.class);

  @Override
  public boolean dependsOn(Variable<D, R, F> variable)
  {
    return false;
  }

  public static final String    infinity        = "∞";

  public static final String    π               = "π";

  public static final String    ⅈ               = "ⅈ";

  public static HashSet<String> constantSymbols = new HashSet<String>();
  static
  {
    constantSymbols.add(π);
    constantSymbols.add(ⅈ);
    constantSymbols.add(infinity);
  }

  public static boolean isConstant(String var)
  {
    return constantSymbols.contains(var);
  }

  public boolean      isInt     = false;

  public final String value;

  public String       fieldName;

  public boolean      isComplex = false;

  public Fraction     fractionValue;

  public LiteralConstantNode(Expression<D, R, F> expression, String constantValueString)
  {
    this(expression,
         constantValueString,
         null);

  }

  public LiteralConstantNode(Expression<D, R, F> expression, String constantValueString, String name)
  {
    super(expression);
    assert Integer.class.equals(arb.Integer.class) : "an import statement for arb.Integer is probably missing";
    value = Utensils.subscriptToRegular(constantValueString.trim());

    if (value.contains("/"))
    {
      String[] parts = value.split("/");

      if (parts.length == 2)
      {
        fractionValue = new Fraction();
        fractionValue.getNumerator().set(parts[0]);
        fractionValue.getDenominator().set(parts[1]);
        isInt     = false;
        isComplex = false;
      }
      else
      {
        throw new ArbException("invalid literal constant '" + value + "'");
      }
    }
    else
    {
      isInt     = !((value.contains(".") || constantSymbols.contains(value)));
      isComplex = ⅈ.equals(value);
      char firstCharOfValue = value.charAt(0);
      fractionValue = Parser.fractions.get(firstCharOfValue);
      if (fractionValue != null)
      {
        fieldName = Parser.fractionFieldNames.get(firstCharOfValue);
        return;
      }
    }

    if (isConstant(constantValueString) || fractionValue != null)
    {
      fieldName = constantValueString;
      return;
    }

    for (var existingConstant : expression.literalConstants.values())
    {
      if (existingConstant.value.equals(value))
      {
        fieldName = existingConstant.fieldName;
        return;
      }
    }

    if (name != null)
    {
      fieldName = name;
    }

    boolean fieldNameConflicts = expression.literalConstants.get(fieldName) != null;
    boolean needsNewFieldName  = fieldName == null || fieldNameConflicts;
    if (needsNewFieldName)
    {
      fieldName = expression.getNextConstantFieldName(type());
    }

    expression.literalConstants.put(fieldName, this);
  }

  public ClassVisitor declareField(ClassVisitor classVisitor)
  {
    classVisitor.visitField(ACC_PUBLIC & ACC_FINAL, fieldName, type().descriptorString(), null, null);
    return classVisitor;
  }

  @Override
  public MethodVisitor generate(MethodVisitor mv, Class<?> resultType)
  {
    generatedType = type();
    if (fractionValue != null)
    {
      loadConstantOntoStack(mv, fieldName, Fraction.class, FractionConstants.class);
    }
    else if (π.equals(fieldName))
    {
      loadRealConstantOntoStack(mv, π);
    }
    else if (infinity.equals(fieldName))
    {
      loadRealConstantOntoStack(mv, "infinity");
    }
    else if (ⅈ.equals(fieldName))
    {
      loadComplexConstantOntoStack(mv, ⅈ);
    }
    else
    {
      expression.loadFieldOntoStack(loadThisOntoStack(mv), fieldName, generatedType.descriptorString());
    }

    if (!resultType.equals(generatedType))
    {
      if (Expression.trace)
      {
        System.err.format("generateCastTo(resultType=%s) from generatedType=%s\n", resultType, generatedType);
      }
      generateCastTo(mv, resultType);
    }

    if (isResult)
    {
      expression.generateSetResultInvocation(mv, generatedType);
    }

    return mv;
  }

  public MethodVisitor generateLiteralConstantInitializerWithString(MethodVisitor methodVisitor)
  {
    Class<?> type = type();
    loadThisOntoStack(methodVisitor);
    methodVisitor.visitTypeInsn(NEW, Type.getInternalName(type));
    duplicateTopOfTheStack(methodVisitor);

    if (fractionValue != null)
    {
      methodVisitor.visitLdcInsn(fractionValue.getNumerator());
      methodVisitor.visitLdcInsn(fractionValue.getDenominator());
      methodVisitor.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(Fraction.class), "<init>", "(JJ)V", false);
    }
    else
    {
      methodVisitor.visitLdcInsn(value);
      boolean needsBitsPassedToStringConstructor = type.equals(Real.class);
      if (needsBitsPassedToStringConstructor)
      {
        methodVisitor.visitIntInsn(SIPUSH, bits);
      }
      String constructorDescriptor = needsBitsPassedToStringConstructor ? METHOD_DESCRIPTOR_WITH_BITS : METHOD_DESCRIPTOR_WITHOUT_BITS;
      methodVisitor.visitMethodInsn(INVOKESPECIAL,
                                    Type.getInternalName(type),
                                    "<init>",
                                    constructorDescriptor,
                                    false);
    }

    expression.putField(methodVisitor, fieldName, type);
    return methodVisitor;
  }

  public void loadRealConstantOntoStack(MethodVisitor mv, String fn)
  {
    loadConstantOntoStack(mv, fn, Real.class, RealConstants.class);
  }

  public void loadComplexConstantOntoStack(MethodVisitor mv, String fn)
  {
    loadConstantOntoStack(mv, fn, Complex.class, ComplexConstants.class);
  }

  /**
   * Calls {@link MethodVisitor#visitFieldInsn(int, String, String, String)} with
   * {@link Opcodes#GETSTATIC}
   * 
   * @param mv
   * @param fieldName
   * @param typeClass            the {@link Class#descriptorString()}
   * @param staticConstantsClass the {@link Class} that has the static field with
   *                             the given fieldName
   * 
   */
  public void
         loadConstantOntoStack(MethodVisitor mv, String fieldName, Class<?> typeClass, Class<?> staticConstantsClass)
  {
    mv.visitFieldInsn(Opcodes.GETSTATIC,
                      Type.getInternalName(staticConstantsClass),
                      fieldName,
                      typeClass.descriptorString());
  }

  @Override
  public boolean isReusable()
  {
    return false;
  }

  @Override
  public MethodVisitor prepareStackForReuse(MethodVisitor mv)
  {
    assert false : "a constant is never reusable";
    return null;
  }

  @Override
  public String toString()
  {
    return value;
  }

  public String toString(int depth)
  {
    return String.format("%s[fieldName=%s, value=%s, depth=%s]",
                         getClass().getSimpleName(),
                         fieldName,
                         value,
                         depth);
  }

  @Override
  public Class<?> type()
  {
    if (fractionValue != null)
    {
      return Fraction.class;
    }
    return isInt ? Integer.class : isComplex ? Complex.class : Real.class;
  }

  @Override
  public String typeset()
  {
    if (π.equals(value))
    {
      return "\\pi";
    }
    else if (fractionValue != null)
    {
      return String.format("\\frac{%s}{%s}", fractionValue.getNumerator(), fractionValue.getDenominator());
    }
    else
    {
      return value;
    }
  }

  @Override
  public boolean isLeaf()
  {
    return true;
  }

  @Override
  public boolean hasSingleLeaf()
  {
    return false;
  }

  @Override
  public List<Node<D, R, F>> getBranches()
  {
    return List.of();
  }

  @Override
  public Node<D, R, F> integral(Variable<D, R, F> variable)
  {
    return new Multiplication<>(expression,
                                this,
                                variable);
  }

  public <E, S, G extends Function<? extends E, ? extends S>> Node<D, R, F> substitute(String variable,
                                                                                       Node<E, S, G> arg)
  {
    return this;
  }

  @Override
  public <E, S, G extends Function<? extends E, ? extends S>>
         Node<E, S, G>
         spliceInto(Expression<E, S, G> newExpression)
  {
    return new LiteralConstantNode<E, S, G>(newExpression,
                                            value,
                                            fieldName);
  }

  @Override
  public void accept(Consumer<Node<D, R, F>> t)
  {
    t.accept(this);
  }

  @Override
  public Node<D, R, F> derivative(Variable<D, R, F> variable)
  {
    return new LiteralConstantNode<>(expression,
                                     "0");
  }

  @Override
  public boolean isScalar()
  {
    return true;
  }

  @Override
  public char symbol()
  {
    return '#';
  }

  @Override
  public boolean isConstant()
  {
    return true;
  }

  @Override
  public String getIntermediateValueFieldName()
  {
    assert fieldName != null;
    return fieldName;
  }
}