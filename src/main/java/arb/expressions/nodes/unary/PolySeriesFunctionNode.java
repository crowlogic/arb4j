package arb.expressions.nodes.unary;

import static arb.expressions.Compiler.*;

import org.objectweb.asm.*;

import arb.*;
import arb.expressions.Compiler;
import arb.expressions.Expression;
import arb.expressions.nodes.Node;
import arb.expressions.nodes.VariableNode;
import arb.functions.Function;

/**
 * Generates bytecode to evaluate polynomial series functions and return all derivatives
 * up to a specified order simultaneously. This is a refactoring of the original implementation
 * that used {@link PolySeriesFunctionDerivativeNode}.
 * 
 * The generated code follows this pattern:
 * 
 * <code>
public [ResultType] evaluate([ScalarType] t, int order, int bits, [ResultType] result)
{
    // Create input polynomial: h(x) = t + x
    [PolyType] h = new [PolyType](order);
    h.fitLength(order);
    h.setLength(order);
    h.get(0).set(t);           // constant term = t
    h.get(1).one();            // linear coefficient = 1
    
    // Create output polynomial for results
    [PolyType] out = new [PolyType](order);
    out.fitLength(order);
    out.setLength(order);
    
    // Call ARB/FLINT series function to compute all derivatives at once
    // Example: arblib.arb_poly_riemann_siegel_theta_series(out, h, order, bits);
    [LIBRARY_FUNCTION_NAME](out, h, order, bits);
    
    // Extract result at the requested derivative order
    result.set(out.getCoeff(order));
    
    // Clean up polynomial resources
    h.clear();
    out.clear();
    
    return result;
}
 * </code>
 * 
 * This approach is significantly more efficient than computing individual derivatives
 * sequentially, as it leverages the ARB library's highly optimized polynomial series
 * evaluation routines that compute the full series in a single pass.
 * 
 * @author Stephen Crowley ©2024-2025
 * @see arb.documentation.BusinessSourceLicenseVersionOnePointOne for © terms
 */
abstract class PolySeriesFunctionNode<D, C, F extends Function<? extends D, ? extends C>>
                                     extends
                                     FunctionNode<D, C, F>
{
  // ============================================================================
  // Class Constants - Polymorphic Type Names
  // ============================================================================
  
  private static final String ACB_ONE                = "acb_one";
  private static final String ACB_POLY_CLEAR         = "acb_poly_clear";
  private static final String ACB_POLY_FIT_LENGTH    = "acb_poly_fit_length";
  private static final String ACB_POLY_GET_COEFF_ACB = "acb_poly_get_coeff_acb";
  private static final String ACB_POLY_INIT          = "acb_poly_init";
  private static final String ACB_POLY_SET_COEFF_ACB = "acb_poly_set_coeff_acb";
  private static final String ACB_POLY_SET_LENGTH    = "acb_poly_set_length";
  private static final String ARB_COMPLEX            = Type.getInternalName(Complex.class);
  private static final String ARB_COMPLEX_POLYNOMIAL = Type.getInternalName(ComplexPolynomial.class);
  private static final String ARB_ONE                = "arb_one";
  private static final String ARB_POLY_CLEAR         = "arb_poly_clear";
  private static final String ARB_POLY_FIT_LENGTH    = "arb_poly_fit_length";
  private static final String ARB_POLY_GET_COEFF_ARB = "arb_poly_get_coeff_arb";
  private static final String ARB_POLY_INIT          = "arb_poly_init";
  private static final String ARB_POLY_SET_COEFF_ARB = "arb_poly_set_coeff_arb";
  private static final String ARB_POLY_SET_LENGTH    = "arb_poly_set_length";
  private static final String ARB_REAL               = Type.getInternalName(Real.class);
  private static final String ARB_REAL_POLYNOMIAL    = Type.getInternalName(RealPolynomial.class);
  private static final String ARG_POLY               = "arg";
  private static final String INIT                   = "<init>";
  private static final String RESULT_POLY            = "resultPoly";
  private static final String VOID_NOARG_SIGNATURE   = "()V";
  private static final String VOID_INT_SIGNATURE     = "(I)V";

  // ============================================================================
  // Instance Variables
  // ============================================================================
  
  /**
   * The derivative order to compute. Allows partial computation of derivatives
   * when only lower-order terms are needed. Default is 0 (function value only).
   */
  protected int derivativeOrder = 0;
  
  /**
   * Tracks the next available local variable slot in the generated bytecode.
   * Used to ensure proper JVM local variable allocation without conflicts.
   */
  private int nextLocalSlot     = 20;

  // ============================================================================
  // Constructors
  // ============================================================================
  
  /**
   * Constructs a PolySeriesFunctionNode with basic initialization.
   * Derivative order defaults to 0 (function value only).
   *
   * @param name the function name
   * @param expr the expression defining the function
   */
  protected PolySeriesFunctionNode(String name, Expression<D, C, F> expr)
  {
    super(name,
          expr.resolve(),
          expr.require(')'));
    this.derivativeOrder = 0;
  }

  /**
   * Constructs a PolySeriesFunctionNode with explicit derivative order specification.
   *
   * @param name  the function name
   * @param expr  the expression defining the function
   * @param arg   the argument node
   * @param order the maximum derivative order to compute (0 = function value only)
   */
  protected PolySeriesFunctionNode(String name, Expression<D, C, F> expr, Node<D, C, F> arg, int order)
  {
    super(name,
          arg,
          expr);
    this.derivativeOrder = Math.max(0, order);
  }

  // ============================================================================
  // Differentiation and Integration Support
  // ============================================================================
  
  @Override
  public Node<D, C, F> differentiate(VariableNode<D, C, F> variable)
  {
    return super.differentiate(variable);
  }

  @Override
  public Node<D, C, F> integrate(VariableNode<D, C, F> variable)
  {
    return super.integrate(variable);
  }

  // ============================================================================
  // Primary Code Generation Method
  // ============================================================================
  
  /**
   * Generates bytecode that evaluates the polynomial series function and returns
   * all derivatives up to the specified order simultaneously.
   * 
   * Generated bytecode flow:
   * 1. Create output scalar variable slot
   * 2. Register intermediate polynomial variables
   * 3. Initialize result polynomial
   * 4. Initialize argument polynomial
   * 5. Set polynomial lengths to accommodate derivatives
   * 6. Construct h(x) = t + x:
   *    - h[0] = t (constant term)
   *    - h[1] = 1 (linear coefficient)
   * 7. Call ARB/FLINT series evaluation function
   * 8. Extract scalar result at requested derivative order
   * 9. Clean up polynomial resources
   * 10. Load result onto stack for return
   *
   * @param mv         the MethodVisitor for bytecode generation
   * @param resultType the return type (Real, Complex, or vector variant)
   * @return the updated MethodVisitor (for method chaining)
   */
  @Override
  public MethodVisitor generate(MethodVisitor mv, Class<?> resultType)
  {
    final Class<?> scalarType        = scalarType(resultType);
    final boolean  isComplex         = Complex.class.equals(scalarType);
    final int      polynomialLength  = Math.max(1, derivativeOrder + 1);

    // Step 1: Load output variable onto stack and store in local variable
    int outputScalarSlot = allocateAndStoreOutputScalar(mv, scalarType);

    // Step 2-3: Register and retrieve polynomial class type
    Class<?> polynomialClass = registerIntermediatePolynomials(isComplex);

    // Step 4-5: Create and initialize result polynomial
    int resultPolySlot = createInitializeAndFitPolynomial(mv,
                                                          isComplex,
                                                          polynomialClass,
                                                          polynomialLength);

    // Step 6-7: Create and initialize argument polynomial
    int argumentPolySlot = createInitializeAndFitPolynomial(mv,
                                                            isComplex,
                                                            polynomialClass,
                                                            polynomialLength);

    // Step 8: Construct input polynomial h(x) = t + x
    constructArgumentPolynomial(mv,
                               scalarType,
                               isComplex,
                               polynomialClass,
                               argumentPolySlot,
                               polynomialLength);

    // Step 9: Call the ARB/FLINT series evaluation function
    invokeSeriesEvaluationFunction(mv,
                                  scalarType,
                                  isComplex,
                                  polynomialLength,
                                  resultPolySlot,
                                  argumentPolySlot);

    // Step 10: Extract scalar result at requested derivative order from polynomial
    extractScalarResultFromPolynomial(mv,
                                      scalarType,
                                      isComplex,
                                      polynomialClass,
                                      outputScalarSlot,
                                      resultPolySlot);

    // Step 11: Clean up polynomial resources
    clearPolynomials(mv,
                     isComplex,
                     polynomialClass,
                     resultPolySlot,
                     argumentPolySlot);

    // Step 12: Load result onto stack for method return
    mv.visitVarInsn(Opcodes.ALOAD, outputScalarSlot);
    generatedType = scalarType;

    return mv;
  }

  // ============================================================================
  // Polynomial Creation and Initialization
  // ============================================================================
  
  /**
   * Creates a new polynomial object and pushes it onto the bytecode stack.
   * 
   * Generated bytecode creates a new instance and calls the no-argument constructor:
   * <code>
   *   new [PolyType]()
   *   dup
   *   invokespecial <init>()
   * </code>
   *
   * @param mv        the MethodVisitor for bytecode generation
   * @param isComplex whether to create ComplexPolynomial (true) or RealPolynomial (false)
   */
  private void createNewPolynomial(MethodVisitor mv, boolean isComplex)
  {
    String polynomialClass = isComplex ? ARB_COMPLEX_POLYNOMIAL : ARB_REAL_POLYNOMIAL;
    Compiler.constructNewObject(mv, polynomialClass);
    Compiler.duplicateTopOfTheStack(mv);
    mv.visitMethodInsn(Opcodes.INVOKESPECIAL,
                       polynomialClass,
                       INIT,
                       VOID_NOARG_SIGNATURE,
                       false);
  }

  /**
   * Allocates a new local variable slot and stores an output scalar variable in it.
   * Also loads it onto the stack for subsequent operations.
   *
   * @param mv        the MethodVisitor for bytecode generation
   * @param scalarType the scalar type (Real or Complex)
   * @return the local variable slot index where the output scalar is stored
   */
  private int allocateAndStoreOutputScalar(MethodVisitor mv, final Class<?> scalarType)
  {
    loadOutputVariableOntoStack(mv, scalarType);
    int outputSlot = nextLocalSlot++;
    mv.visitVarInsn(Opcodes.ASTORE, outputSlot);
    return outputSlot;
  }

  /**
   * Creates, initializes, and fits a polynomial to the specified length.
   * 
   * Operations performed:
   * 1. Create new polynomial
   * 2. Call poly_init() to initialize internal structure
   * 3. Call poly_fit_length() to allocate sufficient storage
   * 4. Call poly_set_length() to set logical length for coefficients
   * 5. Store in local variable slot
   *
   * @param mv               the MethodVisitor for bytecode generation
   * @param isComplex        whether to use Complex (true) or Real (false) polynomial
   * @param polynomialClass  the polynomial class (ComplexPolynomial or RealPolynomial)
   * @param length           the desired polynomial length (max derivative order + 1)
   * @return the local variable slot where the polynomial is stored
   */
  private int createInitializeAndFitPolynomial(MethodVisitor mv,
                                               final boolean isComplex,
                                               Class<?> polynomialClass,
                                               final int length)
  {
    // Create new polynomial instance
    createNewPolynomial(mv, isComplex);
    
    // Store in local variable and keep reference on stack
    int polySlot = nextLocalSlot++;
    mv.visitVarInsn(Opcodes.ASTORE, polySlot);
    mv.visitVarInsn(Opcodes.ALOAD, polySlot);
    
    // Initialize polynomial structure
    invokeStaticMethod(mv,
                       arblib.class,
                       isComplex ? ACB_POLY_INIT : ARB_POLY_INIT,
                       Void.class,
                       polynomialClass);
    
    // Fit polynomial to accommodate desired length
    mv.visitVarInsn(Opcodes.ALOAD, polySlot);
    pushInt(mv, length);
    invokeStaticMethod(mv,
                       arblib.class,
                       isComplex ? ACB_POLY_FIT_LENGTH : ARB_POLY_FIT_LENGTH,
                       Void.class,
                       polynomialClass,
                       int.class);
    
    // Set polynomial length
    mv.visitVarInsn(Opcodes.ALOAD, polySlot);
    pushInt(mv, length);
    invokeStaticMethod(mv,
                       arblib.class,
                       isComplex ? ACB_POLY_SET_LENGTH : ARB_POLY_SET_LENGTH,
                       Void.class,
                       polynomialClass,
                       int.class);
    
    return polySlot;
  }

  // ============================================================================
  // Argument Polynomial Construction: h(x) = t + x
  // ============================================================================
  
  /**
   * Constructs the input polynomial h(x) = t + x where t is the function argument
   * and x represents the power series variable.
   * 
   * Polynomial structure:
   * - h[0] = t (constant term, representing t·x⁰ = t·1 = t)
   * - h[1] = 1 (linear coefficient, representing 1·x¹ = x)
   * - h[k] = 0 for k > 1 (higher-order terms are zero)
   * 
   * This forms the input polynomial for ARB/FLINT series functions like:
   * - arb_poly_riemann_siegel_theta_series
   * - arb_poly_sin_series
   * - arb_poly_cos_series
   * etc.
   *
   * @param mv                the MethodVisitor for bytecode generation
   * @param scalarType        the scalar type (Real or Complex)
   * @param isComplex         whether to use Complex (true) or Real (false) arithmetic
   * @param polynomialClass   the polynomial class type
   * @param argumentPolySlot  the local variable slot containing the argument polynomial
   * @param length            the polynomial length (for validation)
   */
  private void constructArgumentPolynomial(MethodVisitor mv,
                                           final Class<?> scalarType,
                                           final boolean isComplex,
                                           Class<?> polynomialClass,
                                           int argumentPolySlot,
                                           final int length)
  {
    // ========================================================================
    // Set h[0] = t (constant term equal to the function argument)
    // ========================================================================
    assignArgumentToPolynomialCoefficient(mv,
                                          scalarType,
                                          isComplex,
                                          polynomialClass,
                                          argumentPolySlot,
                                          0);

    // ========================================================================
    // Set h[1] = 1 (linear coefficient to represent the series variable x)
    // ========================================================================
    assignOneToPolynomialCoefficient(mv,
                                     scalarType,
                                     isComplex,
                                     polynomialClass,
                                     argumentPolySlot,
                                     1);
  }

  /**
   * Assigns the function argument to a specific coefficient of the argument polynomial.
   * 
   * Generated bytecode:
   * <code>
   *   aload argumentPolySlot
   *   bipush coefficientIndex
   *   [generate argument value]
   *   invokestatic arblib.[method_name](Polynomial, int, ScalarType)
   * </code>
   *
   * @param mv                the MethodVisitor for bytecode generation
   * @param scalarType        the scalar type (Real or Complex)
   * @param isComplex         whether using Complex (true) or Real (false) arithmetic
   * @param polynomialClass   the polynomial class
   * @param argumentPolySlot  the local variable slot containing the argument polynomial
   * @param coefficientIndex  which coefficient to set (0 for constant, 1 for linear, etc.)
   */
  private void assignArgumentToPolynomialCoefficient(MethodVisitor mv,
                                                     final Class<?> scalarType,
                                                     final boolean isComplex,
                                                     Class<?> polynomialClass,
                                                     int argumentPolySlot,
                                                     int coefficientIndex)
  {
    mv.visitVarInsn(Opcodes.ALOAD, argumentPolySlot);
    pushInt(mv, coefficientIndex);
    arg.generate(mv, scalarType);
    invokePolynomialSetCoefficientMethod(mv,
                                         scalarType,
                                         isComplex,
                                         polynomialClass);
  }

  /**
   * Assigns the value 1 to a specific coefficient of the argument polynomial.
   * This is used to set h[1] = 1 for the linear term in h(x) = t + x.
   * 
   * Generated bytecode:
   * <code>
   *   new Real/Complex()
   *   dup
   *   invokespecial <init>()
   *   dup
   *   astore oneSlot
   *   invokestatic arblib.arb_one/acb_one(Real/Complex)
   *   aload argumentPolySlot
   *   bipush coefficientIndex
   *   aload oneSlot
   *   invokestatic arblib.[set_coeff_method](...)
   * </code>
   *
   * @param mv                the MethodVisitor for bytecode generation
   * @param scalarType        the scalar type (Real or Complex)
   * @param isComplex         whether using Complex (true) or Real (false) arithmetic
   * @param polynomialClass   the polynomial class
   * @param argumentPolySlot  the local variable slot containing the argument polynomial
   * @param coefficientIndex  which coefficient to set (typically 1 for linear term)
   */
  private void assignOneToPolynomialCoefficient(MethodVisitor mv,
                                                final Class<?> scalarType,
                                                final boolean isComplex,
                                                Class<?> polynomialClass,
                                                int argumentPolySlot,
                                                int coefficientIndex)
  {
    int oneSlot = allocateAndInitializeOne(mv, isComplex);
    
    mv.visitVarInsn(Opcodes.ALOAD, argumentPolySlot);
    pushInt(mv, coefficientIndex);
    mv.visitVarInsn(Opcodes.ALOAD, oneSlot);
    invokePolynomialSetCoefficientMethod(mv,
                                         scalarType,
                                         isComplex,
                                         polynomialClass);
  }

  /**
   * Allocates a local variable slot and initializes it to the value 1.
   * Used to efficiently set polynomial coefficients to 1 without creating
   * temporary objects on the stack repeatedly.
   *
   * @param mv        the MethodVisitor for bytecode generation
   * @param isComplex whether to create Complex (true) or Real (false) value
   * @return the local variable slot index containing the "1" value
   */
  private int allocateAndInitializeOne(MethodVisitor mv, final boolean isComplex)
  {
    int oneSlot = nextLocalSlot++;
    String scalarClass = isComplex ? ARB_COMPLEX : ARB_REAL;
    
    // Create new scalar instance
    Compiler.constructNewObject(mv, scalarClass);
    Compiler.duplicateTopOfTheStack(mv);
    
    // Call constructor
    mv.visitMethodInsn(Opcodes.INVOKESPECIAL,
                       scalarClass,
                       INIT,
                       VOID_NOARG_SIGNATURE,
                       false);
    
    // Duplicate and store in local variable
    Compiler.duplicateTopOfTheStack(mv);
    mv.visitVarInsn(Opcodes.ASTORE, oneSlot);
    
    // Call arb_one or acb_one to set value to 1
    invokeStaticMethod(mv,
                       arblib.class,
                       isComplex ? ACB_ONE : ARB_ONE,
                       Void.class,
                       isComplex ? Complex.class : Real.class);
    
    return oneSlot;
  }

  // ============================================================================
  // Series Evaluation Function Invocation
  // ============================================================================
  
  /**
   * Invokes the appropriate ARB/FLINT series evaluation function.
   * This is the abstract method that subclasses must implement to specify
   * which series function to call (e.g., riemann_siegel_theta_series, sin_series, etc.)
   * 
   * Subclass implementations should push the result and argument polynomials
   * onto the stack, then call the appropriate arblib function with the
   * derivative order and precision (bits) parameters.
   *
   * @param mv               the MethodVisitor for bytecode generation
   * @param scalarType       the scalar type (Real or Complex)
   * @param isComplex        whether using Complex (true) or Real (false) arithmetic
   * @param polynomialLength the number of coefficients/derivatives to compute
   * @param resultPolySlot   the local variable slot containing the result polynomial
   * @param argumentPolySlot the local variable slot containing the argument polynomial (h(x) = t + x)
   */
  protected abstract void invokeSeriesEvaluationFunction(MethodVisitor mv,
                                                        Class<?> scalarType,
                                                        boolean isComplex,
                                                        int polynomialLength,
                                                        int resultPolySlot,
                                                        int argumentPolySlot);

  // ============================================================================
  // Result Extraction from Polynomial
  // ============================================================================
  
  /**
   * Extracts the scalar result at the requested derivative order from the
   * result polynomial. The polynomial coefficients correspond to derivatives:
   * - Coefficient [0] = f(t) (function value / 0th derivative)
   * - Coefficient [1] = f'(t) (1st derivative)
   * - Coefficient [n] = f⁽ⁿ⁾(t) (nth derivative)
   * 
   * The scalar at index [derivativeOrder] is extracted and stored in
   * the output scalar variable.
   *
   * @param mv                the MethodVisitor for bytecode generation
   * @param scalarType        the scalar type (Real or Complex)
   * @param isComplex         whether using Complex (true) or Real (false) arithmetic
   * @param polynomialClass   the polynomial class
   * @param outputScalarSlot  the local variable slot for the output scalar
   * @param resultPolySlot    the local variable slot containing the result polynomial
   */
  private void extractScalarResultFromPolynomial(MethodVisitor mv,
                                                 final Class<?> scalarType,
                                                 final boolean isComplex,
                                                 Class<?> polynomialClass,
                                                 int outputScalarSlot,
                                                 int resultPolySlot)
  {
    // Load output scalar (destination for result)
    mv.visitVarInsn(Opcodes.ALOAD, outputScalarSlot);
    
    // Load result polynomial (source of coefficient)
    mv.visitVarInsn(Opcodes.ALOAD, resultPolySlot);
    
    // Push the derivative order as the coefficient index
    pushInt(mv, derivativeOrder);
    
    // Call the appropriate get_coeff method
    invokeStaticMethod(mv,
                       arblib.class,
                       isComplex ? ACB_POLY_GET_COEFF_ACB : ARB_POLY_GET_COEFF_ARB,
                       Void.class,
                       scalarType,
                       polynomialClass,
                       int.class);
  }

  // ============================================================================
  // Resource Cleanup
  // ============================================================================
  
  /**
   * Clears and deallocates polynomial resources.
   * Must be called after all polynomial operations to ensure proper
   * memory management and prevent resource leaks.
   * 
   * Calls arb_poly_clear or acb_poly_clear for each polynomial.
   *
   * @param mv               the MethodVisitor for bytecode generation
   * @param isComplex        whether using Complex (true) or Real (false) polynomials
   * @param polynomialClass  the polynomial class type
   * @param resultPolySlot   the local variable slot containing the result polynomial
   * @param argumentPolySlot the local variable slot containing the argument polynomial
   */
  private void clearPolynomials(MethodVisitor mv,
                                final boolean isComplex,
                                Class<?> polynomialClass,
                                int resultPolySlot,
                                int argumentPolySlot)
  {
    // Clear result polynomial
    mv.visitVarInsn(Opcodes.ALOAD, resultPolySlot);
    invokePolynomialClearMethod(mv, isComplex, polynomialClass);
    
    // Clear argument polynomial
    mv.visitVarInsn(Opcodes.ALOAD, argumentPolySlot);
    invokePolynomialClearMethod(mv, isComplex, polynomialClass);
  }

  /**
   * Invokes the polynomial clear method to deallocate internal structures.
   * Wrapper around invokeStaticMethod for cleaner code.
   *
   * @param mv               the MethodVisitor for bytecode generation
   * @param isComplex        whether using Complex (true) or Real (false) polynomial
   * @param polynomialClass  the polynomial class type
   */
  private void invokePolynomialClearMethod(MethodVisitor mv,
                                           final boolean isComplex,
                                           Class<?> polynomialClass)
  {
    invokeStaticMethod(mv,
                       arblib.class,
                       isComplex ? ACB_POLY_CLEAR : ARB_POLY_CLEAR,
                       Void.class,
                       polynomialClass);
  }

  // ============================================================================
  // Polynomial Coefficient Operations
  // ============================================================================
  
  /**
   * Invokes the method to set a polynomial coefficient to a scalar value.
   * Wrapper around invokeStaticMethod for setting coefficients.
   * 
   * Expected stack state before call:
   * - Top: scalar value to set
   * - Next: coefficient index
   * - Next: polynomial object
   *
   * @param mv               the MethodVisitor for bytecode generation
   * @param scalarType       the scalar type (Real or Complex)
   * @param isComplex        whether using Complex (true) or Real (false) arithmetic
   * @param polynomialClass  the polynomial class
   */
  private void invokePolynomialSetCoefficientMethod(MethodVisitor mv,
                                                    final Class<?> scalarType,
                                                    final boolean isComplex,
                                                    Class<?> polynomialClass)
  {
    invokeStaticMethod(mv,
                       arblib.class,
                       isComplex ? ACB_POLY_SET_COEFF_ACB : ARB_POLY_SET_COEFF_ARB,
                       Void.class,
                       polynomialClass,
                       int.class,
                       scalarType);
  }

  // ============================================================================
  // Intermediate Variable Registration
  // ============================================================================
  
  /**
   * Registers intermediate polynomial variables in the expression context
   * if they haven't been registered already. This allows the expression
   * compiler to track these variables across multiple code generation passes.
   * 
   * Registers two intermediate variables:
   * - "resultPoly": the polynomial holding computed derivatives
   * - "arg": the polynomial holding the input (h(x) = t + x)
   *
   * @param isComplex whether to use Complex (true) or Real (false) polynomial class
   * @return the polynomial class that was registered and should be used
   */
  private Class<?> registerIntermediatePolynomials(final boolean isComplex)
  {
    Class<?> polynomialClass = isComplex ? ComplexPolynomial.class : RealPolynomial.class;

    if (!expression.hasIntermediateVariable(RESULT_POLY))
    {
      expression.registerIntermediateVariable(RESULT_POLY,
                                              polynomialClass,
                                              true); // AutoCloseable
    }
    
    if (!expression.hasIntermediateVariable(ARG_POLY))
    {
      expression.registerIntermediateVariable(ARG_POLY,
                                              polynomialClass,
                                              true); // AutoCloseable
    }
    
    return polynomialClass;
  }

  // ============================================================================
  // Utility Methods
  // ============================================================================
  
  /**
   * Pushes an integer constant onto the bytecode stack.
   * Optimized for common small values using LDC instruction.
   *
   * @param mv the MethodVisitor for bytecode generation
   * @param value the integer value to push
   */
  protected static void pushInt(MethodVisitor mv, int value)
  {
    mv.visitLdcInsn(value);
  }
}
