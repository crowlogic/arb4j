package arb.expressions.nodes.unary;

import static arb.expressions.Compiler.*;

import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

import arb.arblib;
import arb.expressions.Expression;
import arb.expressions.nodes.Node;
import arb.functions.Function;

/**
 * <code>
 * The root cause is in `PolySeriesFunctionDerivativeNode.generate()`  — it hardcodes the series length at compile time:

```java
final int n = Math.max(1, derivativeOrder + 1);
```

With `derivativeOrder = 0`, this produces `n = 1`. The generated bytecode in the attached file confirms this: [ppl-ai-file-upload.s3.amazonaws](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/37918610/7598615d-ef19-4645-a4a3-cc535b017e56/th-t.java)

```java
arblib.arb_poly_riemann_siegel_theta_series(var21, var22, 1, bits);
//                                                        ^-- hardcoded 1
```

So only coefficient 0 is computed. `HardyThetaInversion.buildTaylorSeries()` then zeros coefficient 0 (`result.get(0).zero()`) , leaving the entire polynomial as zero — including the linear coefficient that `arb_poly_revert_series` requires to be nonzero.

The old `PolySeriesFunctionNode`-based version used `loadOrderParameter(mv)` which loaded the **runtime** `order` parameter from the `evaluate(Real t, int order, int bits, Real result)` method signature. When `buildTaylorSeries` called `θ.evaluate(t, 20, precision, result.getCoeffs())`, the `20` flowed through as the series length to `arb_poly_riemann_siegel_theta_series`. With `PolySeriesFunctionDerivativeNode`, that runtime `order` is ignored entirely.

`PolySeriesFunctionDerivativeNode` is designed to extract a single scalar — the `derivativeOrder`-th Taylor coefficient at a point. It is not designed to propagate a full Taylor series of runtime-determined length. `PolySeriesFunctionNode` was the correct parent for `RiemannSiegelThetaFunctionNode` because `ϑ(t)` is used both as a scalar evaluator and as a series generator (the `HardyThetaInversion` case). Reverting the parent back to `PolySeriesFunctionNode` fixes this.
 *</code>
 * 
 * @author Stephen Crowley ©2024-2025
 * @see arb.documentation.BusinessSourceLicenseVersionOnePointOne © terms
 */
public class RiemannSiegelThetaFunctionNode<D, C, F extends Function<? extends D, ? extends C>>
                                           extends
                                           PolySeriesFunctionNode<D, C, F>
{
  public RiemannSiegelThetaFunctionNode(Expression<D, C, F> expression)
  {
    super("ϑ",
          expression);
  }

  private RiemannSiegelThetaFunctionNode(Expression<D, C, F> expression,
                                         Node<D, C, F> arg,
                                         int order)
  {
    super("ϑ",
          expression,
          arg,
          order);
  }

  @Override
  protected void invokeSeriesEvaluationFunction(MethodVisitor mv,
                                                Class<?> scalarType,
                                                boolean isComplex,
                                                int hSlot,
                                                int outSlot,
                                                Class<?> polyClass)
  {
    mv.visitVarInsn(Opcodes.ALOAD, outSlot);
    mv.visitVarInsn(Opcodes.ALOAD, hSlot);
    loadOrderParameter(mv);
    if (derivativeOrder > 0)
    {
      mv.visitLdcInsn(derivativeOrder);
      mv.visitInsn(Opcodes.IADD);
    }
    loadBitsParameterOntoStack(mv);

    invokeStaticMethod(mv,
                       arblib.class,
                       isComplex ? "acb_poly_riemann_siegel_theta_series"
                                 : "arb_poly_riemann_siegel_theta_series",
                       Void.class,
                       polyClass,
                       polyClass,
                       int.class,
                       int.class);
  }

  @Override
  public Node<D, C, F> differentiate(arb.expressions.nodes.VariableNode<D, C, F> variable)
  {
    return new RiemannSiegelThetaFunctionNode<>(expression,
                                                arg,
                                                derivativeOrder + 1);
  }

  @Override
  public Node<D, C, F> integrate(arb.expressions.nodes.VariableNode<D, C, F> variable)
  {
    return new RiemannSiegelThetaFunctionNode<>(expression,
                                                arg,
                                                Math.max(0, derivativeOrder - 1));
  }

  @Override
  public <E, S, G extends Function<? extends E, ? extends S>>
         Node<E, S, G>
         spliceInto(Expression<E, S, G> newExpression)
  {
    return new RiemannSiegelThetaFunctionNode<E, S, G>(newExpression,
                                                       arg.spliceInto(newExpression),
                                                       derivativeOrder);
  }

  @Override
  public String toString()
  {
    return derivativeOrder == 0 ? "ϑ(" + arg + ")" : "ϑ^(" + derivativeOrder + ")(" + arg + ')';
  }

  @Override
  public String typeset()
  {
    return String.format("\\vartheta(%s)", arg == null ? "" : arg.typeset());
  }
}
