package arb.expressions.nodes;

import static arb.expressions.Compiler.cast;

import java.util.List;
import java.util.function.Consumer;

import org.objectweb.asm.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import arb.Polynomial;
import arb.exceptions.CompilerException;
import arb.expressions.Compiler;
import arb.expressions.Expression;
import arb.expressions.nodes.unary.FunctionalEvaluationNode;
import arb.functions.Function;

/**
 * Specialized node for integrating polynomial function applications, optionally
 * multiplied by a cofactor before integration.
 *
 * When {@link #cofactorNode} is null, this behaves exactly as before: generates
 * the polynomial, calls {@code integral()}, and evaluates at the argument.
 *
 * When {@link #cofactorNode} is non-null, the generated bytecode:
 * <ol>
 * <li>Evaluates the polynomial (e.g. P(i)) onto the stack</li>
 * <li>Generates the cofactor as a polynomial of the same concrete type</li>
 * <li>Calls {@code mul(cofactor, bits, intermediateProduct)} to get the
 * product polynomial</li>
 * <li>Calls {@code integral()} on the product</li>
 * <li>Evaluates at the argument if scalar</li>
 * </ol>
 *
 * @see <a href="https://github.com/crowlogic/arb4j/issues/835">#835</a>
 */
public class PolynomialIntegralNode<D, C, F extends Function<? extends D, ? extends C>> extends
                                   Node<D, C, F>
{

  private static final String POLY_PRODUCT  = "polyProduct";
  private static final String POLY_COFACTOR = "polyCofactor";

  public static final Logger  logger        = LoggerFactory.getLogger(PolynomialIntegralNode.class);

  @Override
  public Logger getLogger()
  {
    return logger;
  }

  @Override
  public String toString()
  {
    if (cofactorNode != null)
    {
      return String.format("∫(%s)*(%s)d%s", cofactorNode, polynomialNode, argumentNode);
    }
    return String.format("∫%sd%s", polynomialNode.toString(), argumentNode);
  }

  Node<D, C, F> polynomialNode;

  Node<D, C, F> cofactorNode;

  Node<D, C, F> argumentNode;

  /**
   * The name of the intermediate variable field used to hold the product
   * polynomial (cofactor × main polynomial) in the generated class.
   */
  String productIntermediateFieldName;

  /**
   * The name of the intermediate variable field used to hold the cofactor
   * polynomial after it is generated as a polynomial type.
   */
  String cofactorIntermediateFieldName;

  /**
   * Original constructor — no cofactor, behaves exactly as before.
   */
  public PolynomialIntegralNode(Expression<D, C, F> expression,
                                Node<D, C, F> polynomialNode,
                                Node<D, C, F> argumentNode)
  {
    this(expression,
         polynomialNode,
         null,
         argumentNode);
  }

  /**
   * Constructor with optional cofactor. When cofactorNode is non-null, the
   * polynomial is multiplied by the cofactor before integration.
   *
   * @param expression     the owning expression
   * @param polynomialNode the node producing the polynomial (e.g. P(i))
   * @param cofactorNode   nullable — the cofactor to multiply in (e.g. t^p * w(t))
   * @param argumentNode   the integration variable node
   */
  public PolynomialIntegralNode(Expression<D, C, F> expression,
                                Node<D, C, F> polynomialNode,
                                Node<D, C, F> cofactorNode,
                                Node<D, C, F> argumentNode)
  {
    super(expression);
    this.polynomialNode = polynomialNode;
    this.cofactorNode   = cofactorNode;
    this.argumentNode   = argumentNode;
    if (!Polynomial.class.isAssignableFrom(polynomialNode.type()))
    {
      throw new CompilerException(polynomialNode
                                  + "("
                                  + polynomialNode.getClass()
                                  + ") of type "
                                  + polynomialNode.type()
                                  + " is not assignable to a Polynomial");
    }
    if (cofactorNode != null)
    {
      var polynomialType = polynomialNode.type();
      if (!expression.hasIntermediateVariable(POLY_PRODUCT))
      {
        expression.registerIntermediateVariable(POLY_PRODUCT, polynomialType, true);
      }
      productIntermediateFieldName = POLY_PRODUCT;

      if (!expression.hasIntermediateVariable(POLY_COFACTOR))
      {
        expression.registerIntermediateVariable(POLY_COFACTOR, polynomialType, true);
      }
      cofactorIntermediateFieldName = POLY_COFACTOR;
    }
  }

  @Override
  public MethodVisitor generate(MethodVisitor mv, Class<?> resultType)
  {
    var polynomialType = polynomialNode.type();
    if (!isScalar() && isResult)
    {
      polynomialNode.isResult = true;
    }

    // Generate the polynomial onto the stack
    polynomialNode.generate(mv, polynomialType);

    if (cofactorNode != null)
    {
      // Stack: [polynomial]

      // Generate the cofactor as the same polynomial type
      cofactorNode.generate(mv, polynomialType);

      // Stack: [polynomial, cofactor]

      // Load bits parameter for mul
      Compiler.loadBitsParameterOntoStack(mv);

      // Stack: [polynomial, cofactor, bits]

      // Load the intermediate variable for the product result
      expression.loadFieldOntoStack(Compiler.loadThisOntoStack(mv),
                                    productIntermediateFieldName,
                                    Type.getDescriptor(polynomialType));

      // Stack: [polynomial, cofactor, bits, productIntermediate]

      // Call polynomial.mul(cofactor, bits, productIntermediate)
      mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                         Type.getInternalName(polynomialType),
                         "mul",
                         Compiler.getMethodDescriptor(polynomialType,
                                                     polynomialType,
                                                     int.class,
                                                     polynomialType),
                         false);

      // Stack: [productPolynomial]
    }

    // Call integral() on the polynomial (or product polynomial)
    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                       Type.getInternalName(polynomialType),
                       "integral",
                       Compiler.getMethodDescriptor(polynomialType),
                       false);

    if (isScalar())
    {
      // Now evaluate the integrated polynomial at the argument
      var argType = argumentNode.type();
      argumentNode.generate(mv, argType);

      var requiredArgType = resultType;
      if (!argType.equals(requiredArgType))
      {
        argumentNode.generateCastTo(mv, requiredArgType);
      }

      Compiler.loadOrderParameter(mv);
      Compiler.loadBitsParameterOntoStack(mv);

      loadOutputVariableOntoStack(mv, resultType);

      // Call evaluate on the integrated polynomial
      mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                         Type.getInternalName(polynomialType),
                         "evaluate",
                         Expression.evaluationMethodDescriptor,
                         false);

      if (!resultType.equals(Object.class))
      {
        cast(mv, resultType);
      }
    }

    return mv;
  }

  @Override
  public List<Node<D, C, F>> getBranches()
  {
    if (cofactorNode != null)
    {
      return List.of(polynomialNode, cofactorNode, argumentNode);
    }
    return List.of(polynomialNode, argumentNode);
  }

  @Override
  public boolean isLeaf()
  {
    return false;
  }

  @Override
  public boolean isScalar()
  {
    return Compiler.isScalar(type());
  }

  @Override
  public char symbol()
  {
    return '∫';
  }

  @Override
  public Class<?> type()
  {
    return expression.coDomainType;
  }

  @Override
  public String typeset()
  {
    if (cofactorNode != null)
    {
      return "\\int "
             + cofactorNode.typeset()
             + " \\cdot "
             + polynomialNode.typeset()
             + "("
             + argumentNode.typeset()
             + ") d"
             + argumentNode.typeset();
    }
    return "\\int "
           + polynomialNode.typeset()
           + "("
           + argumentNode.typeset()
           + ") d"
           + argumentNode.typeset();
  }

  @Override
  public <E, S, G extends Function<? extends E, ? extends S>>
         Node<E, S, G>
         spliceInto(Expression<E, S, G> newExpression)
  {
    return new PolynomialIntegralNode<>(newExpression,
                                        polynomialNode.spliceInto(newExpression),
                                        cofactorNode != null ? cofactorNode.spliceInto(newExpression)
                                                             : null,
                                        argumentNode.spliceInto(newExpression));
  }

  @Override
  public <E, S, G extends Function<? extends E, ? extends S>>
         Node<D, C, F>
         substitute(String var, Node<E, S, G> replacement)
  {
    return new PolynomialIntegralNode<>(expression,
                                        polynomialNode.substitute(var, replacement),
                                        cofactorNode != null ? cofactorNode.substitute(var,
                                                                                       replacement)
                                                             : null,
                                        argumentNode.substitute(var, replacement));
  }

  @Override
  public Node<D, C, F> integrate(VariableNode<D, C, F> var)
  {
    throw new UnsupportedOperationException("Double integration not implemented");
  }

  @Override
  public Node<D, C, F> differentiate(VariableNode<D, C, F> var)
  {
    // The derivative of the integral is the original function
    if (var.equals(argumentNode))
    {
      var funcEval = new FunctionalEvaluationNode<D, C, F>(expression,
                                                           polynomialNode,
                                                           argumentNode);
      if (cofactorNode != null)
      {
        return cofactorNode.mul(funcEval);
      }
      return funcEval;
    }
    throw new UnsupportedOperationException("Differentiation not implemented for this case");
  }

  @Override
  public boolean isZero()
  {
    return false;
  }

  @Override
  public void accept(Consumer<Node<D, C, F>> visitor)
  {
    polynomialNode.accept(visitor);
    if (cofactorNode != null)
    {
      cofactorNode.accept(visitor);
    }
    argumentNode.accept(visitor);
    visitor.accept(this);
  }

  @Override
  public boolean dependsOn(VariableNode<D, C, F> variable)
  {
    return polynomialNode.dependsOn(variable)
                  || (cofactorNode != null && cofactorNode.dependsOn(variable))
                  || argumentNode.dependsOn(variable);
  }

}
