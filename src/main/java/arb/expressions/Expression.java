package arb.expressions;

import static arb.expressions.Compiler.*;
import static arb.expressions.Parser.*;
import static java.lang.String.format;
import static org.objectweb.asm.Opcodes.*;

import java.io.File;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.*;
import java.util.stream.*;

import org.objectweb.asm.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import arb.*;
import arb.Integer;
import arb.exceptions.CompilerException;
import arb.expressions.context.Dependency;
import arb.expressions.nodes.*;
import arb.expressions.nodes.Node;
import arb.expressions.nodes.binary.*;
import arb.expressions.nodes.nary.*;
import arb.expressions.nodes.unary.*;
import arb.functions.*;
import arb.functions.Function;
import arb.functions.complex.ComplexFunction;
import arb.functions.integer.*;
import arb.functions.real.RealFunction;
import arb.utensils.Utensils;
import arb.utensils.text.trees.TextTree;
import arb.utensils.text.trees.TreeModel;

/**
 * The {@link Expression} class represents mathematical expressions in infix and
 * postfix notation flexibily depending upon the context in which the characters
 * are encountered. It uses {@link Character}s and {@link String}s to represent
 * symbols and operations within these expressions. This class is part of the
 * {@code arb.expressions} package and serves as a dynamic compiler that
 * translates these expressions into high-performance Java bytecode, leveraging
 * the ASM library for bytecode manipulation and generation.
 *
 * <p>
 * Internally, the {@link Expression} class parses the input string to construct
 * an Abstract Syntax Tree (AST), where each {@link Node} represents a
 * {@link BinaryOperationNode}, {@link UnaryOperationNode},
 * {@link NAryOperationNode}, such as {@link AdditionNode} ,
 * {@link SubtractionNode}, {@link MultiplicationNode}, and {@link DivisionNode}
 * or its operands like {@link VariableNode} and {@link LiteralConstantNode},
 * etc. This {@link TreeModel} structure allows the class to correctly manage
 * operator precedence and associativity rules inherent in mathematical
 * expressions and also naturally facilitate their printing via the
 * {@link TextTree} interface. The AST is then traversed by the
 * {@link #generate()} method to produce the corresponding Java bytecodes that
 * which when executed produce the result of the evaluation of the the
 * expression.
 *
 * <h2>Key Features:</h2>
 * <ul>
 * <li>Dynamically compiles mathematical expressions into executable Java
 * bytecode, allowing for efficient evaluation.</li>
 * <li>Supports {@link VariableNode}, {@link LiteralConstantNode}, and
 * {@link FunctionNode}s within {@link Expression}, providing an extensive set
 * of features for constructing elaborate expressions, linked together via a
 * shared {@link Context} in which variables and other functions are registered
 * for mutual accessibility..</li>
 * <li>Effectively manages {@link IntermediateVariable} and
 * {@link LiteralConstantNode}, optimizing memory usage and performance.</li>
 * <li>Automatically injects {@link VariableReference}s to {@link VariableNode}
 * and {@link FunctionNode}s into the compiled bytecode, facilitating dynamic
 * execution.</li>
 * <li>The {@link Parser} provides comprehensive methods for parsing
 * expressions, evaluating them, and generating the necessary bytecode, all
 * while handling mathematical precedence and associativity.</li>
 * </ul>
 *
 * <h2>System Properties:</h2>
 * <ul>
 * <li>{@code arb4j.compiler.traceGeneration=true|false}: Print detail
 * information related to the generation process. Default is {@code false}.</li>
 * 
 * <li>{@code arb4j.compiler.saveclasses=true|false}: Specifies whether the
 * compiled classes should be saved to disk (the current directory). Default is
 * {@code true}.</li>
 * </ul>
 * 
 * <pre>
 * Note: Why we don't manually compute stackmap frames: Using `COMPUTE_FRAMES`
 * is the pragmatic choice in most situations, especially for a tool like the
 * `Expression` compiler, which is typically used during application
 * initialization or setup rather than in performance-critical paths.
 * 
 * The additional time taken by `COMPUTE_FRAMES` to automatically compute stack
 * map frames is usually negligible in the grand scheme of things. It's a small
 * price to pay for the convenience, reliability, and maintainability it
 * provides.
 * 
 * Moreover, the `Expression` compiler is designed to generate bytecode for
 * individual expressions, which are then executed repeatedly. The compilation
 * overhead is incurred only once, while the benefits of the generated bytecode,
 * such as improved performance and type safety, are enjoyed throughout the
 * lifetime of the application.
 * 
 * Attempting to optimize the compilation process by manually computing frames
 * would be a case of premature optimization, adding unnecessary complexity and
 * maintenance burden without providing any tangible benefits in most real-world
 * scenarios.
 * 
 * Therefore, sticking with `COMPUTE_FRAMES` is a sensible choice for the
 * `Expression` compiler, as it strikes a good balance between development
 * effort, correctness, and overall performance.
 * </pre>
 * 
 * See Also:
 * <a href="https://github.com/crowlogic/arb4j/wiki/ExpressionCompiler">arb4j
 * wiki page</a><br>
 * <br>
 * 
 * @param <D> The domain type over which the expression operates, such as
 *            {@link Integer}, {@link Real}, {@link Complex},
 *            {@link RealPolynomial}, etc
 * @param <C> The codomain type that the expression evaluates to, representing
 *            the result of the expression.
 * @param <F> The function type of the expression, extending the
 *            {@link Function} interface, encapsulating the compiled expression
 *            as an evaluatable function in the sense of Java
 * 
 * @author Stephen Crowley ©2024-2025
 * @see arb.documentation.BusinessSourceLicenseVersionOnePointOne © terms
 */
@SuppressWarnings("hiding")
public class Expression<D, C, F extends Function<? extends D, ? extends C>> implements
                       Typesettable,
                       Cloneable,
                       Supplier<F>,
                       Consumer<Consumer<Expression<?, ?, ?>>>
{
  public LiteralConstantNode<D, C, F> newConstant(Integer i)
  {
    return new LiteralConstantNode<>(this, i);
  }

  
  /**
   * Inlines all references to the named contextual function, replacing each
   * {@link FunctionNode} bearing that name with the defining expression's AST
   * (arguments bound to formal parameters via {@link Node#substitute}).
   * 
   * @param functionName the name of the function to inline
   * @return this expression, with all occurrences of the named function inlined
   * @throws IllegalArgumentException if no inlineable function with that name
   *                                  exists in the context
   */
  @SuppressWarnings("unchecked")
  public Expression<D, C, F> inlineFunction(String functionName)
  {
    if (context == null)
    {
      throw new IllegalArgumentException("expression has no context");
    }

    Expression<D, C, F> definingExpression = context.getFunctionExpression(functionName);

    Node<D, C, F>       body               = definingExpression.rootNode.spliceInto(this);

    rootNode = rootNode.substitute(functionName, body);
    updateStringRepresentation();
    return this;
  }

  private static String     ASSERTION_ERROR_METHOD_DESCRIPTOR =
                                                              Compiler.getMethodDescriptor(Void.class,
                                                                                           Object.class);

  private static final char COMBINING_DOT_ABOVE               = '\u0307';

  private static final char COMBINING_TWO_DOTS_ABOVE          = '\u0308';

  public static Class<?>[]  implementedInterfaces             = new Class[]
  { Typesettable.class, AutoCloseable.class, Initializable.class, Named.class };

  static HashSet<Class<?>>  indeterminantTypes                = new HashSet<>();

  public static String      IS_INITIALIZED                    = "isInitialized";

  private static String     JAVA_LANG_ASSERTION_ERROR         = "java/lang/AssertionError";

  public static String      nameOfInitializerFunction         = "initialize";

  private static boolean    saveClasses                       =
                                        Boolean.valueOf(System.getProperty("arb4j.saveClasses",
                                                                           "false"));

  private static boolean    decompileClasses                  =
                                             Boolean.valueOf(System.getProperty("arb4j.decompileClasses",
                                                                                "false"));

  public static boolean     saveGraphs                        =
                                       Boolean.valueOf(System.getProperty("arb4j.saveGraphs",
                                                                          "false"));

  public static boolean     trace                             =
                                  Boolean.valueOf(System.getProperty("arb4j.trace", "false"));

  public static boolean     traceNodes                        =
                                       Boolean.valueOf(System.getProperty("arb4j.traceNodes",
                                                                          "false"));

  public static String      VOID_METHOD_DESCRIPTOR            =
                                                   Compiler.getMethodDescriptor(Void.class);

  static
  {
    assert arb.functions.integer.Sequence.class.equals(Sequence.class) : "you forgot to import arb.functions.sequences.Sequence or imported a class named sequence in another package";
  }

  public File compiledClassDir = new File("compiled");

  static
  {
    indeterminantTypes.addAll(Arrays.asList(RealFunction.class,
                                            RealToComplexFunction.class,
                                            Function.class,
                                            ComplexFunction.class,
                                            RationalFunction.class,
                                            ComplexRationalFunction.class,
                                            RealPolynomial.class,
                                            ComplexPolynomial.class,
                                            IntegerPolynomial.class));
  }

  public Expression<?, ?, ?>                                 upstreamExpression;

  public char                                                character                        = 0;

  public String                                              className;

  public Class<? extends C>                                  coDomainType;

  public Class<F>                                            compiledClass;

  HashMap<Class<?>, AtomicInteger>                           constantCounts                   =
                                                                            new HashMap<>();

  HashMap<Class<?>, AtomicInteger>                           foldedConstantCounts             =
                                                                                  new HashMap<>();

  public Context                                             context;

  HashSet<String>                                            declaredIntermediateVariables    =
                                                                                           new HashSet<>();

  public List<Dependency>                                    dependencies;

  public Class<? extends D>                                  domainType;

  private String                                             expression;

  public boolean                                             functionalDependsOnIndependentVariable;

  public boolean                                             functionalDependsOnIndeterminateVariable;

  private VariableNode<Object, Object, Function<?, ?>>       functionalIndependentVariable;

  public Stack<VariableNode<Object, Object, Function<?, ?>>> functionalIndeterminateVariables =
                                                                                              new Stack<>();

  public Class<? extends F>                                  functionClass;

  public String                                              functionClassDescriptor;

  public String                                              functionName;

  public String                                              genericFunctionClassInternalName;

  public boolean                                             inAbsoluteValue                  =
                                                                             false;

  public VariableNode<D, C, F>                               independentVariable;

  private final Stack<VariableNode<D, C, F>>                 indeterminateVariables           =
                                                                                    new Stack<>();

  int                                                        currentLevel                     = 0;

  public LinkedList<Consumer<MethodVisitor>>                 initializers                     =
                                                                          new LinkedList<>();

  public boolean                                             insideInitializerOrConstructor   =
                                                                                            false;

  protected F                                                instance;

  public byte[]                                              instructions;

  public HashMap<String, IntermediateVariable<D, C, F>>      intermediateVariables            =
                                                                                   new HashMap<>();

  private ArrayList<LiteralConstantNode<D, C, F>>            literalConstantNodes;

  public HashMap<String, LiteralConstantNode<D, C, F>>       literalConstants                 =
                                                                              new HashMap<>();

  private ArrayList<ConstantNode<D, C, F>>                   foldedConstants                  =
                                                                             new ArrayList<>();

  public Expression<D, C, F> registerFoldedConstant(ConstantNode<D, C, F> constantNode)
  {
    if (trace && log.isDebugEnabled())
    {
      log.debug("#{}: registerFoldedConstant(constantNode={})\n",
                System.identityHashCode(this),
                constantNode);
    }
    foldedConstants.add(constantNode);
    return this;
  }

  private final Logger                             log                 =
                                                       LoggerFactory.getLogger(Expression.class);

  public FunctionMapping<D, C, F>                  functionMapping;

  public int                                       position            = -1;

  public char                                      previousCharacter;

  public boolean                                   recursive           = false;

  public HashMap<String, FunctionMapping<?, ?, ?>> referencedFunctions = new HashMap<>();

  private HashMap<String, VariableNode<D, C, F>>   referencedVariables = new HashMap<>();

  public Node<D, C, F>                             rootNode;

  public boolean                                   variablesDeclared   = false;

  public boolean                                   verboseTrace        = false;

  public boolean acceptUntil(Predicate<Expression<?, ?, ?>> visitor)
  {
    Expression<?, ?, ?> e = this;
    while (e != null)
    {
      if (visitor.test(e))
      {
        return true;
      }
      e = e.upstreamExpression;
    }
    return false;
  }

  public Expression(Class<? extends D> domain,
                    Class<? extends C> coDomain,
                    Class<? extends F> function)
  {
    this.upstreamExpression               = null;
    this.domainType                       = domain;
    this.coDomainType                     = coDomain;
    this.functionClass                    = function;
    this.genericFunctionClassInternalName = Type.getInternalName(function);
    this.functionClassDescriptor          = function.descriptorString();

    if (context != null && context.saveClasses)
    {
      saveClasses = true;
    }
    if (Expression.trace)
    {
      log.debug("#{}: new Expression(domain={}, coDomain={}, function={})",
                System.identityHashCode(this),
                domain,
                coDomain,
                function);
    }
  }

  public Expression(String className,
                    Class<? extends D> domainClass,
                    Class<? extends C> coDomainClass,
                    Class<? extends F> functionClass,
                    String expressionString,
                    Context context)
  {
    this(className,
         domainClass,
         coDomainClass,
         functionClass,
         expressionString,
         context,
         null,
         null);
  }

  public Expression(String className,
                    Class<? extends D> domain,
                    Class<? extends C> codomain,
                    Class<? extends F> function,
                    String expression,
                    Context context,
                    String functionName,
                    Expression<?, ?, ?> ascenentExpression)
  {
    assert className != null : "className needs to be specified";
    this.upstreamExpression               = ascenentExpression;
    this.className                        = className;
    this.domainType                       = domain;
    this.coDomainType                     = codomain;
    this.functionClass                    = function;

    this.genericFunctionClassInternalName = Type.getInternalName(function);
    this.functionClassDescriptor          = function.descriptorString();
    this.setExpression(Parser.transformToJavaAcceptableCharacters(expression));
    this.context      = context;
    this.functionName = functionName;

    if (context != null && context.saveClasses)
    {
      saveClasses = true;
    }
    if (Expression.trace)
    {
      log.debug("#{}: new Expression(className={}, domain={}, coDomain={}, function={}, expression={}, context={}, functionName={}, upstreamExpression={}#{})",
                System.identityHashCode(this),
                className,
                domain,
                codomain,
                function,
                expression,
                context,
                functionName,
                ascenentExpression,
                System.identityHashCode(ascenentExpression));
    }

  }

  protected Node<D, C, F> addAndSubtract(Node<D, C, F> node)
  {
    while (true)
    {
      if (nextCharacterRepresentsAddition())
      {
        node = node.add(exponentiateMultiplyAndDivide());
      }
      else if (nextCharacterRepresentsSubtraction())
      {
        var rhs = exponentiateMultiplyAndDivide();
        assert rhs != null : "rhs is null for node=" + node + " in " + this;
        node = node == null ? rhs.neg() : node.sub(rhs);
      }
      else
      {
        return node;
      }
    }
  }

  protected void addCheckForNullField(MethodVisitor mv, String varName, boolean variable)
  {
    Class<?> fieldClass;
    if (variable)
    {
      Object field = context.getVariable(varName);
      fieldClass = field != null ? field.getClass() : null;
    }
    else
    {
      fieldClass = context.functions.get(varName).type();
    }

    if (fieldClass != null)
    {
      addNullCheckForField(mv, className, varName, fieldClass.descriptorString());
    }
  }

  protected void addChecksForNullVariableReferences(MethodVisitor mv)
  {
    if (context != null)
    {
      context.variableClassStream()
             .filter(event -> referencedVariables.containsKey(event.getLeft()))
             .forEach(entry -> addCheckForNullField(loadThisOntoStack(mv), entry.getLeft(), true));
    }
  }

  public String allocateIntermediateVariable(MethodVisitor methodVisitor, Class<?> type)
  {
    Class<?> actualType               = type.isInterface() ? scalarType(type) : type;
    String   intermediateVariableName = newIntermediateVariable(actualType);
    loadThisFieldOntoStack(methodVisitor, intermediateVariableName, actualType);
    return intermediateVariableName;
  }

  public String
         allocateIntermediateVariable(MethodVisitor methodVisitor, String prefix, Class<?> type)
  {
    Class<?> actualType               = type.isInterface() ? scalarType(type) : type;
    String   intermediateVariableName = newIntermediateVariable(prefix, actualType);
    loadFieldOntoStack(loadThisOntoStack(methodVisitor),
                       intermediateVariableName,
                       actualType.descriptorString());
    return intermediateVariableName;
  }

  public VariableNode<?, ?, ?> getIndependentVariableNamed(String name)
  {
    if (independentVariable != null && independentVariable.getName().equals(name))
    {
      return independentVariable;
    }
    if (upstreamExpression != null)
    {
      var immediatelyUpstreamIndependentVariable = upstreamExpression.getIndependentVariable();
      if (immediatelyUpstreamIndependentVariable != null)
      {
        return immediatelyUpstreamIndependentVariable;
      }
    }
    return null;
  }

  public boolean anyUpstreamIndependentVariableIsNamed(String name)
  {
    if (independentVariable != null && independentVariable.getName().equals(name))
    {
      return true;
    }
    if (upstreamExpression != null)
    {
      if (upstreamExpression.anyUpstreamIndependentVariableIsNamed(name))
      {
        return true;
      }
    }
    return false;
  }

  protected Expression<D, C, F> assignIndependentVariable(VariableNode<D, C, F> variable)
  {
    if (isNullaryFunction())
    {
      throw new CompilerException(String.format("Cannot assign independent variable '%s' to nullary function "
                                                + "(domain=Object.class) in expression '%s'; "
                                                + "use an indeterminate variable instead",
                                                variable,
                                                getExpression()));
    }

    if (independentVariable != null)
    {
      if (!independentVariable.equals(variable))
      {
        throw new CompilerException(String.format("undefined variable reference '%s' at position=%s in expression '%s' "
                                                  + "since the indeterminate variable has already been declared to be '%s' in expr#%s",
                                                  variable,
                                                  position,
                                                  this,
                                                  independentVariable,
                                                  System.identityHashCode(getExpression())));
      }
      else
      {
        return this;
      }
    }
    independentVariable               = variable;
    independentVariable.isIndependent = true;
    return this;
  }

  protected VariableNode<D, C, F> assignIndeterminateVariable(VariableNode<D, C, F> variable)
  {
    assert !variable.equals(independentVariable) : "cannot add "
                                                   + variable
                                                   + " to indeterminate stack since it is the inependent variable";
    return variable.pushThisOntoTheIndeterminantVariableStack();
  }

  /**
   * Assigns a variable to either this{@link #indeterminantVariable} or
   * this{@link #independentVariable}
   * 
   * @param variable
   * @param indeterminant if true then this variable represents a placeholder
   *                      variable for a polynomial or a rational function or a
   *                      functional. if false then it is an independent variable
   *                      defined on the domain of the expression
   */
  private void assignVariable(VariableNode<D, C, F> variable, boolean indeterminant)
  {
    if (Expression.trace)
    {
      log.debug("#{}: assignVariable( variable={}, indeterminant={})",
                System.identityHashCode(this),
                variable,
                indeterminant);
    }

    if (indeterminant)
    {
      assignIndeterminateVariable(variable);
    }
    else
    {
      assignIndependentVariable(variable);
    }
  }

  protected void
            assureInputNameHasNotAlreadyBeenAssociatedWithAContextVariable(String inputVariableName)
  {
    if (context != null)
    {
      if (context.getVariable(inputVariableName) != null)
      {
        throw new CompilerException(inputVariableName
                                    + " cannot be declared as the input since it is already registered as a context variable in "
                                    + context);
      }
    }
  }

  protected boolean characterAfterNextIs(char ch)
  {
    return position + 1 < getExpression().length() && getExpression().charAt(position + 1) == ch;
  }

  @Override
  protected Object clone()
  {
    var expr = new Expression<D, C, F>(className,
                                       domainType,
                                       coDomainType,
                                       functionClass,
                                       getExpression(),
                                       context,
                                       functionName,
                                       upstreamExpression);
    expr.context             = context;
    expr.independentVariable = independentVariable;

    // Deep copy the stack: clone each VariableNode WITHOUT resolving
    expr.indeterminateVariables.clear();
    for (VariableNode<D, C, F> var : indeterminateVariables)
    {
      // Create new VariableNode directly without calling resolveReference again
      VariableNode<D, C, F> cloned = var.spliceInto(this).asVariable();
      expr.indeterminateVariables.push(cloned);
    }

    expr.position          = position;
    expr.character         = character;
    expr.previousCharacter = previousCharacter;
    return expr;
  }

  @SuppressWarnings("unchecked")
  public Expression<D, C, F> cloneExpression()
  {
    return (Expression<D, C, F>) clone();
  }

  public Expression<D, C, F> compile()
  {
    if (compiledClass != null)
    {
      return this;
    }
    if (context == null)
    {
      context = new Context();
    }

    if (trace)
    {
      log.debug(String.format("#%s: compile(expression=%s, className=%s, context=%s)\n",
                              System.identityHashCode(this),
                              getExpression(),
                              className,
                              context));
    }
    if (instructions == null)
    {
      generate();
    }
    assert context != null : "context is null for "
                             + this
                             + " and upstreamExpression="
                             + upstreamExpression
                             + " upstreamExpression.context="
                             + upstreamExpression.context;
    compiledClass = loadFunctionClass(className, instructions, context);
    return this;
  }

  protected void constructReferencedFunctionInstanceIfItIsNull(MethodVisitor mv,
                                                               FunctionMapping<?, ?, ?> mapping)
  {
    if ((mapping.functionName == null || functionName == null
                  || !functionName.equals(mapping.functionName)) && mapping.expression != null)
    {

      Class<?> type = mapping.type();
      if (type == null)
      {
        mapping.instantiate();
        type = mapping.type();
      }
      assert type != null : "type is  null for mapping=" + mapping;
      var alreadyInitialized = new Label();
      loadThisOntoStack(mv).visitFieldInsn(GETFIELD,
                                           className,
                                           mapping.functionName,
                                           mapping.functionFieldDescriptor());
      mv.visitJumpInsn(Opcodes.IFNONNULL, alreadyInitialized);
      loadThisOntoStack(mv);
      generateNewObjectInstruction(mv, type);
      duplicateTopOfTheStack(mv);
      invokeDefaultConstructor(mv, type);
      putField(mv, className, mapping.functionName, type);
      mv.visitLabel(alreadyInitialized);
    }
  }

  public VariableNode<D, C, F> newVariableNode(String inputVariableName)
  {
    return new VariableNode<>(this,
                              newVariableReference(inputVariableName),
                              position,
                              true);
  }

  public VariableReference<D, C, F> newVariableReference(String inputVariableName)
  {
    return new VariableReference<>(inputVariableName,
                                   null,
                                   coDomainType);
  }

  private ClassVisitor declareContext(ClassVisitor cw)
  {
    Class<?> type           = Context.class;
    String   typeDescriptor = type.descriptorString();
    cw.visitField(ACC_PUBLIC, "context", typeDescriptor, null, null);
    return cw;
  }

  protected MethodVisitor declareEvaluateMethodArguments(MethodVisitor methodVisitor,
                                                         Label startLabel,
                                                         Label endLabel)
  {
    methodVisitor.visitLocalVariable("this",
                                     String.format("L%s;", className),
                                     null,
                                     startLabel,
                                     endLabel,
                                     0);
    methodVisitor.visitLocalVariable("order",
                                     Type.INT_TYPE.getDescriptor(),
                                     null,
                                     startLabel,
                                     endLabel,
                                     1);
    methodVisitor.visitLocalVariable("bits",
                                     Type.INT_TYPE.getDescriptor(),
                                     null,
                                     startLabel,
                                     endLabel,
                                     2);
    methodVisitor.visitLocalVariable("result",
                                     coDomainType.descriptorString(),
                                     null,
                                     startLabel,
                                     endLabel,
                                     3);
    return methodVisitor;
  }

  protected ClassVisitor declareFields(ClassVisitor cw)
  {
    cw = declareContext(cw);
    cw = declareReferencedFunctions(cw);
    cw = declareReferencedVariables(cw);
    cw = declareIntermediateVariables(cw);
    cw = declareLiteralConstants(cw);
    cw = declareFoldedConstants(cw);
    return cw;
  }

  private ClassVisitor declareIntermediateVariables(ClassVisitor cw)
  {
    for (var entry : intermediateVariables.entrySet())
    {
      Class<?> type           = entry.getValue().type;
      String   typeDescriptor = type.descriptorString();
      cw.visitField(ACC_PUBLIC, entry.getKey(), typeDescriptor, null, null);
    }
    return cw;
  }

  private ClassVisitor declareLiteralConstants(ClassVisitor cw)
  {
    for (var entry : literalConstants.entrySet())
    {
      LiteralConstantNode<D, C, F> node           = entry.getValue();
      Class<?>                     type           = node.type();
      String                       typeDescriptor = type.descriptorString();
      cw.visitField(ACC_PUBLIC, entry.getKey(), typeDescriptor, null, null);
    }
    return cw;
  }

  private ClassVisitor declareFoldedConstants(ClassVisitor cw)
  {
    for (var node : foldedConstants)
    {
      Class<?> type           = node.type();
      String   typeDescriptor = type.descriptorString();
      cw.visitField(ACC_PUBLIC, node.fieldName(), typeDescriptor, null, null);
    }
    return cw;
  }

  private ClassVisitor declareReferencedFunctions(ClassVisitor cw)
  {
    for (var entry : referencedFunctions.entrySet())
    {
      var    mapping        = entry.getValue();
      String typeDescriptor = mapping.functionFieldDescriptor();
      if (typeDescriptor == null)
      {
        mapping.instantiate();
        typeDescriptor = mapping.functionFieldDescriptor();
      }
      cw.visitField(ACC_PUBLIC, mapping.functionName, typeDescriptor, null, null);
    }
    return cw;
  }

  private ClassVisitor declareReferencedVariables(ClassVisitor cw)
  {
    if (context != null)
    {
      context.variableClassStream()
             .filter(event -> referencedVariables.containsKey(event.getLeft()))
             .forEach(entry ->
             {
               String varName       = entry.getLeft();
               Class<?> varType     = entry.getRight();
               String typeDescriptor = varType.descriptorString();
               cw.visitField(ACC_PUBLIC, varName, typeDescriptor, null, null);
             });
    }
    return cw;
  }

  protected MethodVisitor declareThisVariable(MethodVisitor methodVisitor,
                                              Label startLabel,
                                              Label endLabel)
  {
    methodVisitor.visitLocalVariable("this",
                                     String.format("L%s;", className),
                                     null,
                                     startLabel,
                                     endLabel,
                                     0);
    return methodVisitor;
  }

  protected void emitInitializationBytecodes(MethodVisitor mv)
  {
    generateLiteralConstantInitializations(mv);
    generateFoldedConstantInitializations(mv);
    generateVariableInitializations(mv);
    generateFunctionInitializations(mv);
  }

  @SuppressWarnings("unchecked")
  public <E extends Node<D, C, F>> E evaluate(String expressionString, Class<E> type)
  {
    position = -1;
    setExpression(expressionString);
    E node = (E) resolve();
    assert node != null : "node is null for expressionString=" + expressionString + " in " + this;
    return node;
  }

  public Node<D, C, F> exponentiateMultiplyAndDivide()
  {
    Node<D, C, F> node = parseLeafNodeThenCheckForExponentiation();
    while (true)
    {
      if (nextCharacterIsMultiplication())
      {
        node = node.mul(parseLeafNodeThenCheckForExponentiation());
      }
      else if (nextCharacterIsDivision())
      {
        node = node.div(parseLeafNodeThenCheckForExponentiation());
      }
      else
      {
        return node;
      }
    }
  }

  @SuppressWarnings("unchecked")
  public Class<? extends F> generate()
  {
    assert getExpression() != null : "expression string is null";

    ClassWriter cw = new ClassWriter(COMPUTE_FRAMES | COMPUTE_MAXS);

    MethodVisitor mv;

    String superClassName = getSuperClassName();

    cw.visit(V21,
             ACC_PUBLIC + ACC_SUPER,
             className,
             getClassSignature(),
             superClassName,
             getImplementedInterfaces());

    cw.visitSource(getExpression(), null);

    rootNode = resolve();

    assert rootNode != null : "rootNode is null for " + this;

    declareFields(cw);

    generateConstructor(cw);

    generateInitializerFunction(cw);

    generateEvaluationMethod(cw);

    generateTypesetMethod(cw, rootNode);

    generateToStringMethod(cw);

    cw.visitEnd();

    instructions = cw.toByteArray();

    if (saveClasses || (context != null && context.saveClasses))
    {
      Compiler.saveClasses(compiledClassDir, className, instructions);
    }
    if (decompileClasses || (context != null && context.decompileClasses))
    {
      Compiler.decompile(instructions);
    }
    if (saveGraphs)
    {
      Utensils.saveGraph(this);
    }
    return compiledClass;
  }

  private MethodVisitor generateConstructor(ClassWriter cw)
  {
    MethodVisitor mv;
    mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
    mv.visitCode();
    mv.visitVarInsn(ALOAD, 0);
    String superClassName = getSuperClassName();
    mv.visitMethodInsn(INVOKESPECIAL, superClassName, "<init>", "()V", false);
    mv.visitInsn(RETURN);
    mv.visitMaxs(1, 1);
    mv.visitEnd();
    return mv;
  }

  private void generateEvaluationMethod(ClassWriter cw)
  {
    MethodVisitor mv;
    Label         startLabel = new Label();
    Label         endLabel   = new Label();
    mv = cw.visitMethod(ACC_PUBLIC,
                        "evaluate",
                        getEvaluationMethodDescriptor(),
                        getEvaluationMethodSignature(),
                        null);
    mv.visitCode();
    mv.visitLabel(startLabel);
    addChecksForNullVariableReferences(mv);
    rootNode.generate(mv, coDomainType);
    mv.visitInsn(ARETURN);
    mv.visitLabel(endLabel);
    declareEvaluateMethodArguments(mv, startLabel, endLabel);
    mv.visitMaxs(0, 0);
    mv.visitEnd();
  }

  protected void generateFoldedConstantInitializations(MethodVisitor mv)
  {
    for (var node : foldedConstants)
    {
      node.generateInitializationCode(mv);
    }
  }

  protected void generateFunctionInitializations(MethodVisitor mv)
  {
    for (var mapping : referencedFunctions.values())
    {
      constructReferencedFunctionInstanceIfItIsNull(mv, mapping);
    }
  }

  protected void generateLiteralConstantInitializations(MethodVisitor mv)
  {
    for (var entry : literalConstants.entrySet())
    {
      LiteralConstantNode<D, C, F> node = entry.getValue();
      node.generateInitializationCode(mv);
    }
  }

  public void generateTypesetMethod(ClassWriter cw, Node<D, C, F> rootNode)
  {
    MethodVisitor mv = cw.visitMethod(ACC_PUBLIC,
                                      "typeset",
                                      Compiler.getMethodDescriptor(String.class),
                                      null,
                                      null);
    mv.visitCode();
    mv.visitLdcInsn(rootNode.typeset());
    mv.visitInsn(ARETURN);
    mv.visitMaxs(1, 1);
    mv.visitEnd();
  }

  protected void generateToStringMethod(ClassWriter cw)
  {
    MethodVisitor mv;
    mv = cw.visitMethod(ACC_PUBLIC, "toString", Compiler.getMethodDescriptor(String.class), null, null);
    mv.visitCode();
    mv.visitLdcInsn(getExpression());
    mv.visitInsn(ARETURN);
    mv.visitMaxs(1, 1);
    mv.visitEnd();
  }

  private String[] getImplementedInterfaces()
  {
    return Arrays.stream(implementedInterfaces)
                 .map(Type::getInternalName)
                 .toArray(String[]::new);
  }

  private String getSuperClassName()
  {
    String superClassName = Object.class.equals(domainType) ? Type.getInternalName(Object.class)
                                                            : Type.getInternalName(domainType);
    return superClassName;
  }

  protected String getClassSignature()
  {
    return null;
  }

  public String getEvaluationMethodDescriptor()
  {
    return Compiler.getMethodDescriptor(coDomainType, domainType, int.class, int.class, coDomainType);
  }

  public String getEvaluationMethodSignature()
  {
    return null;
  }

  public String getExpression()
  {
    return expression;
  }

  public VariableNode<D, C, F> getIndependentVariable()
  {
    return independentVariable;
  }

  public int getPosition()
  {
    return position;
  }

  public Node<D, C, F> getRoot()
  {
    return rootNode;
  }

  @SuppressWarnings("unchecked")
  public <X> X getInstance()
  {
    return (X) instance;
  }

  public boolean hasContext()
  {
    return context != null;
  }

  public boolean hasIndependentVariable()
  {
    return independentVariable != null;
  }

  public boolean hasIndeterminateVariables()
  {
    return !indeterminateVariables.isEmpty();
  }

  protected boolean isAlphabetic()
  {
    return Character.isAlphabetic(character);
  }

  public boolean isCharacterBeforePositionA(char ch)
  {
    return position > 0 && getExpression().charAt(position - 1) == ch;
  }

  public boolean isNullaryFunction()
  {
    return Object.class.equals(domainType);
  }

  /**
   * Returns true if this {@link Expression} or any expression in its upstream
   * chain has an independent variable that is named the same as the given
   * variable node's name.
   */
  public boolean isIndependentVariableAccessibleFrom(VariableNode<D, C, F> var)
  {
    Expression<D, C, F> current = this;
    while (current != null)
    {
      if (current.independentVariable != null
                    && current.independentVariable.getName().equals(var.getName()))
      {
        return true;
      }
      @SuppressWarnings("unchecked")
      Expression<D, C, F> upstream = (Expression<D, C, F>) current.upstreamExpression;
      current = upstream;
    }
    return false;
  }

  @SuppressWarnings("unchecked")
  protected Node<D, C, F> instantiateNode(String functionName,
                                          Node<D, C, F> argument,
                                          boolean isResult)
  {
    return Parser.instantiateNode(this, functionName, argument, isResult);
  }

  public boolean isFunctionMapped(String name)
  {
    return referencedFunctions.containsKey(name);
  }

  private boolean isMatchOrPossibleCoefficient(String name)
  {
    if (context == null)
    {
      return false;
    }
    Object var = context.getVariable(name);
    return var != null || name.length() == 1;
  }

  private boolean isNextTokenEndOfSubExpression()
  {
    return position + 1 == getExpression().length()
                  || nextCharIsTerminal(getExpression().charAt(position + 1));
  }

  public static boolean nextCharIsTerminal(char c)
  {
    return c == ')' || c == ',' || c == ']';
  }

  public static boolean charIsTerminal(char c)
  {
    return c == ')' || c == ',' || c == ']' || c == '+';
  }

  public boolean nextCharacterIs(char c)
  {
    return position + 1 < getExpression().length()
                  && getExpression().charAt(position + 1) == c;
  }

  public boolean nextCharacterIsDivision()
  {
    if (nextCharacterIs('/'))
    {
      position++;
      character = '/';
      return true;
    }
    return false;
  }

  public boolean nextCharacterIsMultiplication()
  {
    if (nextCharacterIs('*'))
    {
      position++;
      character = '*';
      return true;
    }
    return false;
  }

  public boolean nextCharacterRepresentsAddition()
  {
    return nextCharacterIs('+');
  }

  public boolean nextCharacterRepresentsSubtraction()
  {
    return nextCharacterIs('-') && !characterAfterNextIs('>');
  }

  public String newIntermediateVariable(Class<?> type)
  {
    AtomicInteger count = constantCounts.computeIfAbsent(type, k -> new AtomicInteger(0));
    String        name  = getIntermediateVariableName(type, count.incrementAndGet());
    addIntermediateVariable(name, type);
    return name;
  }

  public String newIntermediateVariable(String prefix, Class<?> type)
  {
    AtomicInteger count = constantCounts.computeIfAbsent(type, k -> new AtomicInteger(0));
    String        name  = prefix + count.incrementAndGet();
    addIntermediateVariable(name, type);
    return name;
  }

  public LiteralConstantNode<D, C, F> newLiteralConstant(int i)
  {
    return new LiteralConstantNode<>(this, i);
  }

  public LiteralConstantNode<D, C, F> newLiteralConstant(long i)
  {
    return new LiteralConstantNode<>(this, i);
  }

  private IntermediateVariable<D, C, F> addIntermediateVariable(String name, Class<?> type)
  {
    var intermediateVariable = new IntermediateVariable<>(this, name, type);
    intermediateVariables.put(name, intermediateVariable);
    return intermediateVariable;
  }

  public static String getIntermediateVariableName(Class<?> type, int count)
  {
    return type.getSimpleName().substring(0, 1).toLowerCase() + count;
  }

  public LiteralConstantNode<D, C, F> newLiteralConstant(Real x)
  {
    return new LiteralConstantNode<>(this, x);
  }

  public LiteralConstantNode<D, C, F> newLiteralConstant(Integer x)
  {
    return new LiteralConstantNode<>(this, x);
  }

  public LiteralConstantNode<D, C, F> newLiteralConstant(Fraction x)
  {
    return new LiteralConstantNode<>(this, x);
  }

  public LiteralConstantNode<D, C, F> newLiteralConstant(Complex x)
  {
    return new LiteralConstantNode<>(this, x);
  }

  public LiteralConstantNode<D, C, F> newLiteralConstant(RationalFunction x)
  {
    return new LiteralConstantNode<>(this, x);
  }

  public LiteralConstantNode<D, C, F> newLiteralConstant(ComplexRationalFunction x)
  {
    return new LiteralConstantNode<>(this, x);
  }

  public Node<D, C, F> newVariable(int startPos, VariableReference<D, C, F> reference)
  {
    return newVariable(startPos, reference, false);
  }

  @SuppressWarnings("unchecked")
  protected Node<D, C, F> newVariable(int startPos,
                                      VariableReference<D, C, F> reference,
                                      boolean functionArgument)
  {
    var variable = new VariableNode<D, C, F>(this,
                                             reference,
                                             startPos,
                                             functionArgument);
    String varName = reference.name;
    if (variable.isIndependent)
    {
      return variable;
    }
    if (variable.isIndeterminate)
    {
      return variable;
    }
    Context ctx = this.context;
    if (ctx != null)
    {
      Object contextVar = ctx.getVariable(varName);
      if (contextVar != null)
      {
        referencedVariables.put(varName, variable);
        return variable;
      }
      FunctionMapping<?, ?, ?> funcMapping = ctx.functions.get(varName);
      if (funcMapping != null)
      {
        referencedFunctions.put(varName, (FunctionMapping<D, C, F>) funcMapping);
        return new FunctionNode<>(this, varName, null, false, false, false, false);
      }
    }
    return variable;
  }

  protected boolean nextCharIsDigit()
  {
    return position + 1 < getExpression().length()
                  && Character.isDigit(getExpression().charAt(position + 1));
  }

  protected boolean nextCharIsDot()
  {
    return position + 1 < getExpression().length()
                  && getExpression().charAt(position + 1) == '.';
  }

  @Override
  public String toString()
  {
    return String.format("%s%s%s[%s]",
                         className,
                         functionName == null ? "" : "." + functionName,
                         expression == null ? "" : "@" + expression,
                         System.identityHashCode(this));
  }

  @Override
  public String typeset()
  {
    return rootNode == null ? expression : rootNode.typeset();
  }

  public boolean variableOrFunctionIsDeclaredInContext(String name)
  {
    if (context != null)
    {
      if (context.getVariable(name) != null)
      {
        return true;
      }
      if (context.functions.containsKey(name))
      {
        return true;
      }
    }
    return false;
  }

  protected Node<D, C, F> parseLeafNodeThenCheckForExponentiation()
  {
    Node<D, C, F> node = parsePrimaryNode();
    if (node == null)
    {
      return null;
    }
    while (nextCharacterIs('^'))
    {
      position++;
      node = node.pow(parsePrimaryNode());
    }
    return node;
  }

  @SuppressWarnings("unchecked")
  protected Node<D, C, F> parsePrimaryNode()
  {
    character    = getExpression().charAt(++position);
    int startPos = position;
    if (Expression.trace)
    {
      log.debug("#{}: parsePrimaryNode at position={} char={}",
                System.identityHashCode(this),
                position,
                character);
    }

    switch (character)
    {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
      return parseInteger();
    }
    case '.':
    {
      return parseFloatingPoint();
    }
    case '(':
    {
      Node<D, C, F> node = resolve();
      assert getExpression().charAt(++position) == ')' : "Expected ) but got '"
                                                         + character
                                                         + "' at position="
                                                         + position
                                                         + " in expression="
                                                         + getExpression();
      return node;
    }
    case '[':
    {
      Node<D, C, F> node = resolve();
      ++position;
      return node;
    }
    case '-':
    {
      return parseNegation();
    }
    case '|':
    {
      return parseAbsoluteValue();
    }
    default:
    {
      return parseIdentifier(startPos);
    }
    }
  }

  protected Node<D, C, F> parseAbsoluteValue()
  {
    inAbsoluteValue = true;
    var absNode      = new AbsoluteValueNode<>(this, resolve());
    inAbsoluteValue = false;
    ++position;
    return absNode;
  }

  protected Node<D, C, F> parseFloatingPoint()
  {
    int startPos = position;
    while (nextCharIsDigit())
    {
      character = getExpression().charAt(++position);
    }
    return newLiteralConstant(getExpression().substring(startPos, position));
  }

  protected Node<D, C, F> parseInteger()
  {
    int startPos = position;
    while (nextCharIsDigit())
    {
      character = getExpression().charAt(++position);
    }
    if (nextCharIsDot())
    {
      character = getExpression().charAt(++position);
      while (nextCharIsDigit())
      {
        character = getExpression().charAt(++position);
      }
    }
    return newLiteralConstant(getExpression().substring(startPos, position));
  }

  protected Node<D, C, F> parseNegation()
  {
    if (nextCharIsDigit())
    {
      int startPos = position;
      character = getExpression().charAt(++position);
      while (nextCharIsDigit())
      {
        character = getExpression().charAt(++position);
      }
      if (nextCharIsDot())
      {
        character = getExpression().charAt(++position);
        while (nextCharIsDigit())
        {
          character = getExpression().charAt(++position);
        }
      }
      return newLiteralConstant(getExpression().substring(startPos, position));
    }
    else if (nextCharacterIs('('))
    {
      return resolve().neg();
    }
    return exponentiateMultiplyAndDivide().neg();
  }

  protected Node<D, C, F> parseIdentifier(int startPos)
  {
    assert character != 0 : "character is 0 at position=" + position + " in expression=" + getExpression();
    String name = parseAlphanumericString(startPos);
    return resolveIdentifier(name, startPos);
  }

  /**
   * Parses an alphanumeric string starting at startPos. Advances position until
   * the next character is not alphanumeric. Handles special unicode characters.
   */
  private String parseAlphanumericString(int startPos)
  {
    while (position + 1 < getExpression().length())
    {
      char nextChar = getExpression().charAt(position + 1);
      if (!Character.isAlphabetic(nextChar) && !Character.isDigit(nextChar)
                    && nextChar != '_' && nextChar != COMBINING_DOT_ABOVE
                    && nextChar != COMBINING_TWO_DOTS_ABOVE)
      {
        break;
      }
      character = getExpression().charAt(++position);
    }
    return getExpression().substring(startPos, position + 1);
  }

  /**
   * Resolves an identifier (variable or function) with possible coefficient
   * handling.
   */
  @SuppressWarnings("unchecked")
  private Node<D, C, F> resolveIdentifier(String name, int startPos)
  {
    if (context != null)
    {
      FunctionMapping<?, ?, ?> funcMapping = context.functions.get(name);
      if (funcMapping != null)
      {
        return parseFunctionCallOrCoefficient(name, startPos);
      }
    }

    if (isNextTokenEndOfSubExpression())
    {
      return resolveAtomicIdentifier(name, startPos);
    }
    return parseFunctionCallOrCoefficient(name, startPos);
  }

  /**
   * Resolves a purely atomic identifier (variable/constant, no function call or
   * coefficient).
   */
  @SuppressWarnings("unchecked")
  private Node<D, C, F> resolveAtomicIdentifier(String name, int startPos)
  {
    VariableReference<D, C, F> reference = new VariableReference<>(name, null, coDomainType);
    return reference.resolve(this, startPos);
  }

  /**
   * Parses a function call or coefficient expression for the given name.
   */
  @SuppressWarnings("unchecked")
  private Node<D, C, F> parseFunctionCallOrCoefficient(String name, int startPos)
  {
    if (nextCharacterIs('('))
    {
      position++;
      return parseFunctionCall(name, startPos);
    }
    return parseCoefficient(name, startPos);
  }

  /**
   * Parses a function call node (after '(' has been confirmed as next char).
   */
  @SuppressWarnings("unchecked")
  private Node<D, C, F> parseFunctionCall(String name, int startPos)
  {
    if (nextCharacterIs(')'))
    {
      ++position;
      return instantiateNode(name, null, true);
    }
    Node<D, C, F> arg = resolve();
    assert getExpression().charAt(++position) == ')' : "Expected ')' but got '"
                                                       + getExpression().charAt(position)
                                                       + "' at position="
                                                       + position
                                                       + " in expression "
                                                       + getExpression();
    return instantiateNode(name, arg, true);
  }

  /**
   * Parses a coefficient expression: name followed by an expression (implicit
   * multiplication).
   */
  @SuppressWarnings("unchecked")
  private Node<D, C, F> parseCoefficient(String name, int startPos)
  {
    if (!isMatchOrPossibleCoefficient(name))
    {
      VariableReference<D, C, F> reference = new VariableReference<>(name, null, coDomainType);
      return reference.resolve(this, startPos);
    }
    VariableReference<D, C, F> reference = new VariableReference<>(name, null, coDomainType);
    Node<D, C, F>              coeff     = reference.resolve(this, startPos);
    Node<D, C, F>              right     = parseLeafNodeThenCheckForExponentiation();
    return coeff.mul(right);
  }

  protected Node<D, C, F> resolve()
  {
    return addAndSubtract(exponentiateMultiplyAndDivide());
  }

  protected void generateVariableInitializations(MethodVisitor mv)
  {
    if (context != null)
    {
      for (var entry : context.variableClassStream().collect(Collectors.toList()))
      {
        String   varName   = entry.getLeft();
        Class<?> varType   = entry.getRight();
        if (referencedVariables.containsKey(varName))
        {
          generateVariableInitialization(mv, varName, varType);
        }
      }
    }
  }

  protected void generateVariableInitialization(MethodVisitor mv, String varName, Class<?> varType)
  {
    loadThisOntoStack(mv);
    String contextFieldDescriptor = Context.class.descriptorString();
    mv.visitFieldInsn(GETFIELD, className, "context", contextFieldDescriptor);
    mv.visitLdcInsn(varName);
    mv.visitMethodInsn(INVOKEVIRTUAL,
                       Type.getInternalName(Context.class),
                       "getVariable",
                       Compiler.getMethodDescriptor(Object.class, String.class),
                       false);
    mv.visitTypeInsn(CHECKCAST, Type.getInternalName(varType));
    mv.visitFieldInsn(PUTFIELD, className, varName, varType.descriptorString());
    loadThisOntoStack(mv);
  }

  protected void generateInitializerFunction(ClassWriter cw)
  {
    Label         startLabel = new Label();
    Label         endLabel   = new Label();
    MethodVisitor mv         = cw.visitMethod(ACC_PUBLIC,
                                              nameOfInitializerFunction,
                                              VOID_METHOD_DESCRIPTOR,
                                              null,
                                              null);
    mv.visitCode();
    mv.visitLabel(startLabel);
    loadThisOntoStack(mv);
    addChecksForNullVariableReferences(mv);
    emitInitializationBytecodes(mv);
    mv.visitInsn(RETURN);
    mv.visitLabel(endLabel);
    declareThisVariable(mv, startLabel, endLabel);
    mv.visitMaxs(0, 0);
    mv.visitEnd();
  }

  public boolean isVariableReferenced(String varName)
  {
    return referencedVariables.containsKey(varName);
  }

  @Override
  public void accept(Consumer<Expression<?, ?, ?>> visitor)
  {
    visitor.accept(this);
  }

  @Override
  public F get()
  {
    return instance;
  }

  public Context getContext()
  {
    return context;
  }

  public void setContext(Context context)
  {
    this.context = context;
  }

  public static <D, C, F extends Function<? extends D, ? extends C>> Expression<D, C, F>
         newExpression(String className,
                       Class<D> domain,
                       Class<C> codomain,
                       Class<F> function,
                       String expression,
                       Context context)
  {
    return new Expression<>(className, domain, codomain, function, expression, context);
  }

  /**
   * @param variable
   * @return
   */
  public VariableNode<D, C, F> registerIndependentVariable(String variable)
  {
    return registerVariable(variable, false);
  }

  public VariableNode<D, C, F> registerIndeterminateVariable(String variable)
  {
    return registerVariable(variable, true);
  }

  public VariableNode<D, C, F> registerVariable(String inputVariableName, boolean indeterminate)
  {
    assureInputNameHasNotAlreadyBeenAssociatedWithAContextVariable(inputVariableName);
    VariableNode<D, C, F> var = newVariableNode(inputVariableName);
    assignVariable(var, indeterminate);
    return var;
  }

  public void setExpression(String expression)
  {
    this.expression = expression;
  }

  public void updateStringRepresentation()
  {
    expression = rootNode == null ? expression : rootNode.toString();
  }

  public static <D, C, F extends Function<? extends D, ? extends C>>
         Expression<D, C, F>
         compile(String className,
                 Class<D> domain,
                 Class<C> codomain,
                 Class<F> function,
                 String expression,
                 Context context)
  {
    return newExpression(className, domain, codomain, function, expression, context).compile();
  }

  public static Class<?> scalarType(Class<?> type)
  {
    if (type.equals(RealFunction.class) || type.equals(RealToComplexFunction.class)
                  || type.equals(Function.class))
    {
      return Real.class;
    }
    else if (type.equals(ComplexFunction.class))
    {
      return Complex.class;
    }
    else if (type.equals(RationalFunction.class))
    {
      return Fraction.class;
    }
    else if (type.equals(ComplexRationalFunction.class))
    {
      return ComplexFraction.class;
    }
    else
    {
      return type;
    }
  }

  public Node<D, C, F> substituteAll(Map<String, Node<D, C, F>> substitutions)
  {
    return rootNode.substituteAll(substitutions);
  }

  public boolean dependsOn(String variable)
  {
    return rootNode != null && rootNode.dependsOn(variable);
  }

  /**
   * Look up a node in this expression that is "named" variable, such as a
   * {@link VariableNode} whose name equals the given string.
   */
  public Node<D, C, F> nodeNamed(String variable)
  {
    return rootNode == null ? null : rootNode.nodeNamed(variable);
  }

  /**
   * Checks if this expression string contains the given substring. Can be useful
   * for quick syntactic checks before deeper analysis.
   */
  public boolean expressionContains(String substring)
  {
    return expression != null && expression.contains(substring);
  }

  /**
   * Returns a new {@link Expression} that represents the composition of this
   * expression with the provided argument expression on the given variable name.
   * 
   * @param varName the name of the variable to substitute
   * @param arg     the expression to substitute for the variable
   * @return a new expression representing the composition
   */
  public Expression<D, C, F> composeWith(String varName, Expression<D, C, F> arg)
  {
    Expression<D, C, F> composed = cloneExpression();
    composed.rootNode = composed.rootNode.substitute(varName, arg.rootNode.spliceInto(composed));
    composed.updateStringRepresentation();
    return composed;
  }

  /**
   * Returns a human-readable string showing the expression and its tree
   * structure.
   */
  public String toTreeString()
  {
    if (rootNode == null)
    {
      return "[null rootNode]";
    }
    StringBuilder sb = new StringBuilder();
    sb.append("Expression: ").append(expression).append("\n");
    sb.append(rootNode.toString());
    return sb.toString();
  }

  /**
   * Prints the tree structure of this expression to {@code System.out}.
   */
  public void printTree()
  {
    System.out.println(toTreeString());
  }

  /**
   * Checks whether the root node of this expression is of the given type.
   * 
   * @param nodeType the {@link Node} subclass to test
   * @return true if the root node is an instance of the given type
   */
  public boolean rootIs(Class<? extends Node<?, ?, ?>> nodeType)
  {
    return rootNode != null && nodeType.isInstance(rootNode);
  }

  public boolean isReal()
  {
    return Real.class.isAssignableFrom(coDomainType);
  }

  public boolean isComplex()
  {
    return Complex.class.isAssignableFrom(coDomainType);
  }

  public boolean isInteger()
  {
    return Integer.class.isAssignableFrom(coDomainType);
  }

  public boolean isFraction()
  {
    return Fraction.class.isAssignableFrom(coDomainType);
  }

  protected Node<D, C, F> parsePowerExpression()
  {
    Node<D, C, F> base = parsePrimaryNode();
    if (nextCharacterIs('^'))
    {
      position++;
      Node<D, C, F> exp = parsePrimaryNode();
      return base.pow(exp);
    }
    return base;
  }

  public LiteralConstantNode<D, C, F> newConstant(int i)
  {
    return new LiteralConstantNode<>(this, i);
  }

  public LiteralConstantNode<D, C, F> newConstant(long i)
  {
    return new LiteralConstantNode<>(this, i);
  }

  public LiteralConstantNode<D, C, F> newConstant(Real r)
  {
    return new LiteralConstantNode<>(this, r);
  }

  public LiteralConstantNode<D, C, F> newConstant(Fraction f)
  {
    return new LiteralConstantNode<>(this, f);
  }

  protected boolean functionExistsInContext(String name)
  {
    return context != null && context.functions.containsKey(name);
  }

  public int numberOfLiteralConstants()
  {
    return literalConstants.size();
  }

  public int numberOfIntermediateVariables()
  {
    return intermediateVariables.size();
  }

  public LiteralConstantNode<D, C, F> newLiteralConstant(Integer i)
  {
    return new LiteralConstantNode<>(this,
                                     java.lang.Integer.toString(i));
  }

  public LiteralConstantNode<D, C, F> newLiteralConstant(String i)
  {
    return new LiteralConstantNode<>(this,
                                     i);
  }

  public LiteralConstantNode<D, C, F> newFractionLiteralConstant(Fraction frac)
  {
    return new LiteralConstantNode<>(this, frac);
  }

  protected VariableNode<D, C, F> newVariable(int startPos, VariableReference<D, C, F> reference)
  {
    return new VariableNode<D, C, F>(this,
                                     reference,
                                     startPos,
                                     false);
  }

  protected VariableNode<D, C, F> newVariable(String name)
  {
    VariableReference<D, C, F> ref = new VariableReference<>(name, null, coDomainType);
    return new VariableNode<D, C, F>(this, ref, position, false);
  }

  protected Node<D, C, F> parseSuperscript(Node<D, C, F> base)
  {
    position++;
    int startPos = position;
    character    = getExpression().charAt(position);
    int superscriptDigit = Character.getNumericValue(character);
    if (nextCharIsDigit())
    {
      character       = getExpression().charAt(++position);
      superscriptDigit = superscriptDigit * 10 + Character.getNumericValue(character);
    }
    Node<D, C, F> node = base.pow(newLiteralConstant(superscriptDigit));
    return node;
  }

  protected Node<D, C, F> parseSuperscripts(Node<D, C, F> base)
  {
    while (position + 1 < getExpression().length()
                  && isSuperscriptDigit(getExpression().charAt(position + 1)))
    {
      base = parseSuperscript(base);
    }
    return base;
  }

  public static boolean isSuperscriptDigit(char c)
  {
    return c >= '\u2070' && c <= '\u2079' || c == '\u00B9' || c == '\u00B2' || c == '\u00B3';
  }

  public LiteralConstantNode<D, C, F> parseFraction()
  {
    int startPos     = position;
    int slashPos     = getExpression().indexOf('/', position);
    int numerator    = java.lang.Integer.parseInt(getExpression().substring(startPos, slashPos));
    position         = slashPos + 1;
    int endPos       = position;
    while (endPos < getExpression().length() && Character.isDigit(getExpression().charAt(endPos)))
    {
      endPos++;
    }
    int denominator = java.lang.Integer.parseInt(getExpression().substring(position, endPos));
    position        = endPos - 1;
    Fraction frac   = new Fraction(numerator, denominator);
    return newFractionLiteralConstant(frac);
  }

  public static Expression<?, ?, ?> parse(String expr)
  {
    return new Expression<>(null,
                            Object.class,
                            Object.class,
                            Function.class,
                            expr,
                            null);
  }

  public String getFunctionName()
  {
    return functionName;
  }

  public Class<? extends D> getDomainType()
  {
    return domainType;
  }

  public Class<? extends C> getCoDomainType()
  {
    return coDomainType;
  }

  public Class<? extends F> getFunctionClass()
  {
    return functionClass;
  }

  public LiteralConstantNode<D, C, F> negativeOne()
  {
    return newConstant(-1);
  }

}
