package arb.expressions;

import static arb.expressions.Compiler.*;
import static arb.expressions.Parser.*;
import static java.lang.String.format;
import static org.objectweb.asm.Opcodes.*;

import java.io.File;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.*;
import java.util.stream.*;

import org.objectweb.asm.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import arb.*;
import arb.Integer;
import arb.exceptions.CompilerException;
import arb.expressions.context.Dependency;
import arb.expressions.nodes.*;
import arb.expressions.nodes.Node;
import arb.expressions.nodes.binary.*;
import arb.expressions.nodes.nary.*;
import arb.expressions.nodes.unary.*;
import arb.functions.*;
import arb.functions.Function;
import arb.functions.complex.ComplexFunction;
import arb.functions.integer.*;
import arb.functions.real.RealFunction;
import arb.utensils.Utensils;
import arb.utensils.text.trees.TextTree;
import arb.utensils.text.trees.TreeModel;

/**
 * The {@link Expression} class represents mathematical expressions in infix and
 * postfix notation flexibily depending upon the context in which the characters
 * are encountered. It uses {@link Character}s and {@link String}s to represent
 * symbols and operations within these expressions. This class is part of the
 * {@code arb.expressions} package and serves as a dynamic compiler that
 * translates these expressions into high-performance Java bytecode, leveraging
 * the ASM library for bytecode manipulation and generation.
 *
 * <p>
 * Internally, the {@link Expression} class parses the input string to construct
 * an Abstract Syntax Tree (AST), where each {@link Node} represents a
 * {@link BinaryOperationNode}, {@link UnaryOperationNode},
 * {@link NAryOperationNode}, such as {@link AdditionNode} ,
 * {@link SubtractionNode}, {@link MultiplicationNode}, and {@link DivisionNode}
 * or its operands like {@link VariableNode} and {@link LiteralConstantNode},
 * etc. This {@link TreeModel} structure allows the class to correctly manage
 * operator precedence and associativity rules inherent in mathematical
 * expressions and also naturally facilitate their printing via the
 * {@link TextTree} interface. The AST is then traversed by the
 * {@link #generate()} method to produce the corresponding Java bytecodes that
 * which when executed produce the result of the evaluation of the the
 * expression.
 *
 * <h2>Key Features:</h2>
 * <ul>
 * <li>Dynamically compiles mathematical expressions into executable Java
 * bytecode, allowing for efficient evaluation.</li>
 * <li>Supports {@link VariableNode}, {@link LiteralConstantNode}, and
 * {@link FunctionNode}s within {@link Expression}, providing an extensive set
 * of features for constructing elaborate expressions, linked together via a
 * shared {@link Context} in which variables and other functions are registered
 * for mutual accessibility..</li>
 * <li>Effectively manages {@link IntermediateVariable} and
 * {@link LiteralConstantNode}, optimizing memory usage and performance.</li>
 * <li>Automatically injects {@link VariableReference}s to {@link VariableNode}
 * and {@link FunctionNode}s into the compiled bytecode, facilitating dynamic
 * execution.</li>
 * <li>The {@link Parser} provides comprehensive methods for parsing
 * expressions, evaluating them, and generating the necessary bytecode, all
 * while handling mathematical precedence and associativity.</li>
 * </ul>
 *
 * <h2>System Properties:</h2>
 * <ul>
 * <li>{@code arb4j.compiler.traceGeneration=true|false}: Print detail
 * information related to the generation process. Default is {@code false}.</li>
 * 
 * <li>{@code arb4j.compiler.saveclasses=true|false}: Specifies whether the
 * compiled classes should be saved to disk (the current directory). Default is
 * {@code true}.</li>
 * </ul>
 * 
 * <pre>
 * Note: Why we don't manually compute stackmap frames: Using `COMPUTE_FRAMES`
 * is the pragmatic choice in most situations, especially for a tool like the
 * `Expression` compiler, which is typically used during application
 * initialization or setup rather than in performance-critical paths.
 * 
 * The additional time taken by `COMPUTE_FRAMES` to automatically compute stack
 * map frames is usually negligible in the grand scheme of things. It's a small
 * price to pay for the convenience, reliability, and maintainability it
 * provides.
 * 
 * Moreover, the `Expression` compiler is designed to generate bytecode for
 * individual expressions, which are then executed repeatedly. The compilation
 * overhead is incurred only once, while the benefits of the generated bytecode,
 * such as improved performance and type safety, are enjoyed throughout the
 * lifetime of the application.
 * 
 * Attempting to optimize the compilation process by manually computing frames
 * would be a case of premature optimization, adding unnecessary complexity and
 * maintenance burden without providing any tangible benefits in most real-world
 * scenarios.
 * 
 * Therefore, sticking with `COMPUTE_FRAMES` is a sensible choice for the
 * `Expression` compiler, as it strikes a good balance between development
 * effort, correctness, and overall performance.
 * </pre>
 * 
 * See Also:
 * <a href="https://github.com/crowlogic/arb4j/wiki/ExpressionCompiler">arb4j
 * wiki page</a><br>
 * <br>
 * 
 * @param <D> The domain type over which the expression operates, such as
 *            {@link Integer}, {@link Real}, {@link Complex},
 *            {@link RealPolynomial}, etc
 * @param <C> The codomain type that the expression evaluates to, representing
 *            the result of the expression.
 * @param <F> The function type of the expression, extending the
 *            {@link Function} interface, encapsulating the compiled expression
 *            as an evaluatable function in the sense of Java
 * 
 * @author Stephen Crowley ©2024-2025
 * @see arb.documentation.BusinessSourceLicenseVersionOnePointOne © terms
 */
@SuppressWarnings("hiding")
public class Expression<D, C, F extends Function<? extends D, ? extends C>> implements
                       Typesettable,
                       Cloneable,
                       Supplier<F>,
                       Consumer<Consumer<Expression<?, ?, ?>>>
{
  /**
   * Inlines all references to the named contextual function, replacing each
   * {@link FunctionNode} bearing that name with the defining expression's AST
   * (arguments bound to formal parameters via {@link Node#substitute}).
   * 
   * @param functionName the name of the function to inline
   * @return this expression, with all occurrences of the named function inlined
   * @throws IllegalArgumentException if no inlineable function with that name
   *                                  exists in the context
   */
  @SuppressWarnings("unchecked")
  public Expression<D, C, F> inlineFunction(String functionName)
  {
    if (context == null)
    {
      throw new IllegalArgumentException("expression has no context");
    }

    Expression<D, C, F> definingExpression = context.getFunctionExpression(functionName);

    Node<D, C, F>       body               = definingExpression.rootNode.spliceInto(this);

    rootNode = rootNode.substitute(functionName, body);
    updateStringRepresentation();
    return this;
  }

  private static String     ASSERTION_ERROR_METHOD_DESCRIPTOR =
                                                              Compiler.getMethodDescriptor(Void.class,
                                                                                           Object.class);

  private static final char COMBINING_DOT_ABOVE               = '\u0307';

  private static final char COMBINING_TWO_DOTS_ABOVE          = '\u0308';

  public static Class<?>[]  implementedInterfaces             = new Class[]
  { Typesettable.class, AutoCloseable.class, Initializable.class, Named.class };

  static HashSet<Class<?>>  indeterminantTypes                = new HashSet<>();

  public static String      IS_INITIALIZED                    = "isInitialized";

  private static String     JAVA_LANG_ASSERTION_ERROR         = "java/lang/AssertionError";

  public static String      nameOfInitializerFunction         = "initialize";

  private static boolean    saveClasses                       =
                                        Boolean.valueOf(System.getProperty("arb4j.saveClasses",
                                                                           "false"));

  private static boolean    decompileClasses                  =
                                             Boolean.valueOf(System.getProperty("arb4j.decompileClasses",
                                                                                "false"));

  public static boolean     saveGraphs                        =
                                       Boolean.valueOf(System.getProperty("arb4j.saveGraphs",
                                                                          "false"));

  public static boolean     trace                             =
                                  Boolean.valueOf(System.getProperty("arb4j.trace", "false"));

  public static boolean     traceNodes                        =
                                       Boolean.valueOf(System.getProperty("arb4j.traceNodes",
                                                                          "false"));

  public static String      VOID_METHOD_DESCRIPTOR            =
                                                   Compiler.getMethodDescriptor(Void.class);

  static
  {
    assert arb.functions.integer.Sequence.class.equals(Sequence.class) : "you forgot to import arb.functions.sequences.Sequence or imported a class named sequence in another package";
  }

  static
  {
    if (saveClasses && !Compiler.compiledClassDir.canWrite())
    {
      Compiler.compiledClassDir.mkdir();
    }
  }

  static
  {
    indeterminantTypes.addAll(Arrays.asList(RealFunction.class,
                                            RealToComplexFunction.class,
                                            Function.class,
                                            ComplexFunction.class,
                                            RationalFunction.class,
                                            ComplexRationalFunction.class,
                                            RealPolynomial.class,
                                            ComplexPolynomial.class,
                                            IntegerPolynomial.class));
  }

  public Expression<?, ?, ?>                                 upstreamExpression;

  public char                                                character                        = 0;

  public String                                              className;

  public Class<? extends C>                                  coDomainType;

  public Class<F>                                            compiledClass;

  HashMap<Class<?>, AtomicInteger>                           constantCounts                   =
                                                                            new HashMap<>();

  public Context                                             context;

  HashSet<String>                                            declaredIntermediateVariables    =
                                                                                           new HashSet<>();

  public List<Dependency>                                    dependencies;

  public Class<? extends D>                                  domainType;

  private String                                             expression;

  public boolean                                             functionalDependsOnIndependentVariable;

  public boolean                                             functionalDependsOnIndeterminateVariable;

  private VariableNode<Object, Object, Function<?, ?>>       functionalIndependentVariable;

  public Stack<VariableNode<Object, Object, Function<?, ?>>> functionalIndeterminateVariables =
                                                                                              new Stack<>();

  public Class<? extends F>                                  functionClass;

  public String                                              functionClassDescriptor;

  public String                                              functionName;

  public String                                              genericFunctionClassInternalName;

  public boolean                                             inAbsoluteValue                  =
                                                                             false;

  public VariableNode<D, C, F>                               independentVariable;

  private final Stack<VariableNode<D, C, F>>                 indeterminateVariables           =
                                                                                    new Stack<>();

  int                                                        currentLevel                     = 0;

  public LinkedList<Consumer<MethodVisitor>>                 initializers                     =
                                                                          new LinkedList<>();

  public boolean                                             insideInitializer                =
                                                                               false;

  protected F                                                instance;

  public byte[]                                              instructions;

  public HashMap<String, IntermediateVariable<D, C, F>>      intermediateVariables            =
                                                                                   new HashMap<>();

  private ArrayList<LiteralConstantNode<D, C, F>>            literalConstantNodes;

  public HashMap<String, LiteralConstantNode<D, C, F>>       literalConstants                 =
                                                                              new HashMap<>();

  private final Logger                                       log                              =
                                                                 LoggerFactory.getLogger(Expression.class);

  public FunctionMapping<D, C, F>                            functionMapping;

  public int                                                 position                         = -1;

  public char                                                previousCharacter;

  public boolean                                             recursive                        =
                                                                       false;

  public HashMap<String, FunctionMapping<?, ?, ?>>           referencedFunctions              =
                                                                                 new HashMap<>();

  private HashMap<String, VariableNode<D, C, F>>             referencedVariables              =
                                                                                 new HashMap<>();

  public Node<D, C, F>                                       rootNode;

  public boolean                                             variablesDeclared                =
                                                                               false;

  public boolean                                             verboseTrace                     =
                                                                          false;

  public boolean acceptUntil(Predicate<Expression<?, ?, ?>> visitor)
  {
    Expression<?, ?, ?> e = this;
    while (e != null)
    {
      if (visitor.test(e))
      {
        return true;
      }
      e = e.upstreamExpression;
    }
    return false;
  }

  public Expression(Class<? extends D> domain,
                    Class<? extends C> coDomain,
                    Class<? extends F> function)
  {
    this.upstreamExpression               = null;
    this.domainType                       = domain;
    this.coDomainType                     = coDomain;
    this.functionClass                    = function;
    this.genericFunctionClassInternalName = Type.getInternalName(function);
    this.functionClassDescriptor          = function.descriptorString();

    if (context != null && context.saveClasses)
    {
      saveClasses = true;
    }
    if (Expression.trace)
    {
      log.debug("#{}: new Expression(domain={}, coDomain={}, function={})",
                System.identityHashCode(this),
                domain,
                coDomain,
                function);
    }
  }

  public Expression(String className,
                    Class<? extends D> domainClass,
                    Class<? extends C> coDomainClass,
                    Class<? extends F> functionClass,
                    String expressionString,
                    Context context)
  {
    this(className,
         domainClass,
         coDomainClass,
         functionClass,
         expressionString,
         context,
         null,
         null);
  }

  public Expression(String className,
                    Class<? extends D> domain,
                    Class<? extends C> codomain,
                    Class<? extends F> function,
                    String expression,
                    Context context,
                    String functionName,
                    Expression<?, ?, ?> ascenentExpression)
  {
    assert className != null : "className needs to be specified";
    this.upstreamExpression               = ascenentExpression;
    this.className                        = className;
    this.domainType                       = domain;
    this.coDomainType                     = codomain;
    this.functionClass                    = function;

    this.genericFunctionClassInternalName = Type.getInternalName(function);
    this.functionClassDescriptor          = function.descriptorString();
    this.setExpression(Parser.transformToJavaAcceptableCharacters(expression));
    this.context      = context;
    this.functionName = functionName;

    if (context != null && context.saveClasses)
    {
      saveClasses = true;
    }
    if (Expression.trace)
    {
      log.debug("#{}: new Expression(className={}, domain={}, coDomain={}, function={}, expression={}, context={}, functionName={}, upstreamExpression={}#{})",
                System.identityHashCode(this),
                className,
                domain,
                codomain,
                function,
                expression,
                context,
                functionName,
                ascenentExpression,
                System.identityHashCode(ascenentExpression));
    }

  }

  protected Node<D, C, F> addAndSubtract(Node<D, C, F> node)
  {
    while (true)
    {
      if (nextCharacterRepresentsAddition())
      {
        node = node.add(exponentiateMultiplyAndDivide());
      }
      else if (nextCharacterRepresentsSubtraction())
      {
        var rhs = exponentiateMultiplyAndDivide();
        assert rhs != null : "rhs is null for node=" + node + " in " + this;
        node = node == null ? rhs.neg() : node.sub(rhs);
      }
      else
      {
        return node;
      }
    }
  }

  protected void addCheckForNullField(MethodVisitor mv, String varName, boolean variable)
  {
    Class<?> fieldClass;
    if (variable)
    {
      Object field = context.getVariable(varName);
      fieldClass = field != null ? field.getClass() : null;
    }
    else
    {
      fieldClass = context.functions.get(varName).type();
    }

    if (fieldClass != null)
    {
      addNullCheckForField(mv, className, varName, fieldClass.descriptorString());
    }
  }

  protected void addChecksForNullVariableReferences(MethodVisitor mv)
  {
    if (context != null)
    {
      context.variableClassStream()
             .filter(event -> referencedVariables.containsKey(event.getLeft()))
             .forEach(entry -> addCheckForNullField(loadThisOntoStack(mv), entry.getLeft(), true));
    }
  }

  public String allocateIntermediateVariable(MethodVisitor methodVisitor, Class<?> type)
  {
    Class<?> actualType               = type.isInterface() ? scalarType(type) : type;
    String   intermediateVariableName = newIntermediateVariable(actualType);
    loadThisFieldOntoStack(methodVisitor, intermediateVariableName, actualType);
    return intermediateVariableName;
  }

  public String
         allocateIntermediateVariable(MethodVisitor methodVisitor, String prefix, Class<?> type)
  {
    Class<?> actualType               = type.isInterface() ? scalarType(type) : type;
    String   intermediateVariableName = newIntermediateVariable(prefix, actualType);
    loadFieldOntoStack(loadThisOntoStack(methodVisitor),
                       intermediateVariableName,
                       actualType.descriptorString());
    return intermediateVariableName;
  }

  public VariableNode<?, ?, ?> getIndependentVariableNamed(String name)
  {
    if (independentVariable != null && independentVariable.getName().equals(name))
    {
      return independentVariable;
    }
    if (upstreamExpression != null)
    {
      var immediatelyUpstreamIndependentVariable = upstreamExpression.getIndependentVariable();
      if (immediatelyUpstreamIndependentVariable != null)
      {
        return immediatelyUpstreamIndependentVariable;
      }
    }
    return null;
  }

  public boolean anyUpstreamIndependentVariableIsNamed(String name)
  {
    if (independentVariable != null && independentVariable.getName().equals(name))
    {
      return true;
    }
    if (upstreamExpression != null)
    {
      if (upstreamExpression.anyUpstreamIndependentVariableIsNamed(name))
      {
        return true;
      }
    }
    return false;
  }

  protected Expression<D, C, F> assignIndependentVariable(VariableNode<D, C, F> variable)
  {
    if (isNullaryFunction())
    {
      throw new CompilerException(String.format("Cannot assign independent variable '%s' to nullary function "
                                                + "(domain=Object.class) in expression '%s'; "
                                                + "use an indeterminate variable instead",
                                                variable,
                                                getExpression()));
    }

    if (independentVariable != null)
    {
      if (!independentVariable.equals(variable))
      {
        throw new CompilerException(String.format("undefined variable reference '%s' at position=%s in expression '%s' "
                                                  + "since the indeterminate variable has already been declared to be '%s' in expr#%s",
                                                  variable,
                                                  position,
                                                  this,
                                                  independentVariable,
                                                  System.identityHashCode(getExpression())));
      }
      else
      {
        return this;
      }
    }
    independentVariable               = variable;
    independentVariable.isIndependent = true;
    return this;
  }

  protected VariableNode<D, C, F> assignIndeterminateVariable(VariableNode<D, C, F> variable)
  {
    assert !variable.equals(independentVariable) : "cannot add "
                                                   + variable
                                                   + " to indeterminate stack since it is the inependent variable";
    return variable.pushThisOntoTheIndeterminantVariableStack();
  }

  /**
   * Assigns a variable to either this{@link #indeterminantVariable} or
   * this{@link #independentVariable}
   * 
   * @param variable
   * @param indeterminant if true then this variable represents a placeholder
   *                      variable for a polynomial or a rational function or a
   *                      functional. if false then it is an independent variable
   *                      defined on the domain of the expression
   */
  private void assignVariable(VariableNode<D, C, F> variable, boolean indeterminant)
  {
    if (Expression.trace)
    {
      log.debug("#{}: assignVariable( variable={}, indeterminant={})",
                System.identityHashCode(this),
                variable,
                indeterminant);
    }

    if (indeterminant)
    {
      assignIndeterminateVariable(variable);
    }
    else
    {
      assignIndependentVariable(variable);
    }
  }

  protected void
            assureInputNameHasNotAlreadyBeenAssociatedWithAContextVariable(String inputVariableName)
  {
    if (context != null)
    {
      if (context.getVariable(inputVariableName) != null)
      {
        throw new CompilerException(inputVariableName
                                    + " cannot be declared as the input since it is already registered as a context variable in "
                                    + context);
      }
    }
  }

  protected boolean characterAfterNextIs(char ch)
  {
    return position + 1 < getExpression().length() && getExpression().charAt(position + 1) == ch;
  }

  @Override
  protected Object clone()
  {
    var expr = new Expression<D, C, F>(className,
                                       domainType,
                                       coDomainType,
                                       functionClass,
                                       getExpression(),
                                       context,
                                       functionName,
                                       upstreamExpression);
    expr.context             = context;
    expr.independentVariable = independentVariable;

    // Deep copy the stack: clone each VariableNode WITHOUT resolving
    expr.indeterminateVariables.clear();
    for (VariableNode<D, C, F> var : indeterminateVariables)
    {
      // Create new VariableNode directly without calling resolveReference again
      VariableNode<D, C, F> cloned = var.spliceInto(this).asVariable();// VariableNode<>(expr,
//                                                        var.reference.spliceInto(expr),
//                                                        var.position,
//                                                        false); // ← resolve=false!
//      cloned.isIndeterminate = var.isIndeterminate;
//      cloned.isIndependent   = var.isIndependent;
      expr.indeterminateVariables.push(cloned);
    }

    expr.position          = position;
    expr.character         = character;
    expr.previousCharacter = previousCharacter;
    return expr;
  }

  @SuppressWarnings("unchecked")
  public Expression<D, C, F> cloneExpression()
  {
    return (Expression<D, C, F>) clone();
  }

  public Expression<D, C, F> compile()
  {
    if (compiledClass != null)
    {
      return this;
    }
    if (context == null)
    {
      context = new Context();
    }

    if (trace)
    {
      log.debug(String.format("#%s: compile(expression=%s, className=%s, context=%s)\n",
                              System.identityHashCode(this),
                              getExpression(),
                              className,
                              context));
    }
    if (instructions == null)
    {
      generate();
    }
    assert context != null : "context is null for "
                             + this
                             + " and upstreamExpression="
                             + upstreamExpression
                             + " upstreamExpression.context="
                             + upstreamExpression.context;
    compiledClass = loadFunctionClass(className, instructions, context);
    return this;
  }

  protected void constructReferencedFunctionInstanceIfItIsNull(MethodVisitor mv,
                                                               FunctionMapping<?, ?, ?> mapping)
  {
    if ((mapping.functionName == null || functionName == null
                  || !functionName.equals(mapping.functionName)) && mapping.expression != null)
    {

      Class<?> type = mapping.type();
      if (type == null)
      {
        mapping.instantiate();
        type = mapping.type();
      }
      assert type != null : "type is  null for mapping=" + mapping;
      var alreadyInitialized = new Label();
      loadThisOntoStack(mv).visitFieldInsn(GETFIELD,
                                           className,
                                           mapping.functionName,
                                           mapping.functionFieldDescriptor());
      mv.visitJumpInsn(Opcodes.IFNONNULL, alreadyInitialized);
      loadThisOntoStack(mv);
      generateNewObjectInstruction(mv, type);
      duplicateTopOfTheStack(mv);
      invokeDefaultConstructor(mv, type);
      putField(mv, className, mapping.functionName, type);
      mv.visitLabel(alreadyInitialized);
    }
  }

  public VariableNode<D, C, F> newVariableNode(String inputVariableName)
  {
    return new VariableNode<>(this,
                              newVariableReference(inputVariableName),
                              position,
                              true);
  }

  public VariableReference<D, C, F> newVariableReference(String inputVariableName)
  {
    return new VariableReference<>(inputVariableName,
                                   null,
                                   coDomainType);
  }

  private ClassVisitor declareContext(ClassVisitor cw)
  {
    Class<?> type           = Context.class;
    String   typeDescriptor = type.descriptorString();
    cw.visitField(ACC_PUBLIC, "context", typeDescriptor, null, null);
    return cw;
  }

  protected MethodVisitor declareEvaluateMethodsLocalVariableArguments(MethodVisitor methodVisitor,
                                                                       Label startLabel,
                                                                       Label endLabel)
  {
    methodVisitor.visitLocalVariable("this",
                                     String.format("L%s;", className),
                                     null,
                                     startLabel,
                                     endLabel,
                                     0);
    methodVisitor.visitLocalVariable(independentVariable != null ? independentVariable.getName()
                                                                 : "in",
                                     domainType.descriptorString(),
                                     null,
                                     startLabel,
                                     endLabel,
                                     1);
    methodVisitor.visitLocalVariable("order", "I", null, startLabel, endLabel, 2);
    methodVisitor.visitLocalVariable("bits", "I", null, startLabel, endLabel, 3);
    methodVisitor.visitLocalVariable("result",
                                     coDomainType.descriptorString(),
                                     null,
                                     startLabel,
                                     endLabel,
                                     4);
    return methodVisitor;
  }

  protected void declareFields(ClassVisitor cw)
  {
    cw.visitField(Opcodes.ACC_PUBLIC, IS_INITIALIZED, "Z", null, null);

    declareContext(cw);

    if (!coDomainType.isInterface())
    {
      declareLiteralConstants(cw);
      declareIntermediateVariables(cw);
    }
    declareFunctionReferences(cw);
    declareVariables(cw);
  }

  protected ClassVisitor declareFunctionReferences(ClassVisitor classVisitor)
  {
    if (context == null)
    {
      return classVisitor;
    }
    context.populateFunctionReferenceGraph();
    dependencies = Utensils.sortDependencies(context.functionReferenceGraph, referencedFunctions);

    if (saveGraphs)
    {
      context.saveDependencyGraph(dependencies);
    }
    // Declare functions in dependency order
    for (Dependency dependency : dependencies)
    {
      String dependencyVariableName = dependency.variableName;
      var    functionMapping        = referencedFunctions.get(dependencyVariableName);

      if (functionMapping != null)
      {
        functionMapping.declare(classVisitor, dependencyVariableName);
      }
    }

    return classVisitor;
  }

  protected void declareIntermediateVariables(ClassVisitor classVisitor)
  {
    sortedIntermediateVariableStream().filter(variable -> !declaredIntermediateVariables.contains(variable.name))
                                      .forEach(variable ->
                                      {
                                        variable.declareField(classVisitor);
                                        declaredIntermediateVariables.add(variable.name);
                                      });
  }

  protected ClassVisitor declareLiteralConstants(ClassVisitor classVisitor)
  {
    for (var constant : getSortedLiteralConstantNodes())
    {
      constant.declareField(classVisitor);
    }
    return classVisitor;
  }

  protected void declareVariableEntry(ClassVisitor classVisitor, Entry<String, Named> variable)
  {
    if (trace)
    {
      log.trace("Declaring variable of " + className + ": " + variable);
    }
    if (variable.getValue() != null)
    {
      String varName = variable.getKey();
      classVisitor.visitField(ACC_PUBLIC,
                              varName,
                              variable.getValue().getClass().descriptorString(),
                              null,
                              null);
      declaredVariables.add(varName);
    }
    else
    {
      if (trace)
      {
        log.trace("Skipping null variable of " + className + ": " + variable);
      }
    }
  }

  /**
   * Declares variables as fields in the generated class. This includes: 1. The
   * upstream (parent) expression's independent variable (if any) - so this
   * expression can receive it 2. Variables referenced from ancestor expressions
   * (upstreamInput variables) 3. Context variables
   * 
   * NEVER declares this expression's own independent variable as a field in its
   * own class.
   */
  protected void declareVariables(ClassVisitor classVisitor)
  {
    // Declare the parent's independent variable as a field so we can receive it
    if (upstreamExpression != null)
    {
      var upstreamIndependentVariableNode = upstreamExpression.independentVariable;
      if (upstreamIndependentVariableNode != null
                    && !upstreamIndependentVariableNode.type().equals(Object.class))
      {
        classVisitor.visitField(ACC_PUBLIC,
                                upstreamIndependentVariableNode.reference.name,
                                upstreamIndependentVariableNode.type().descriptorString(),
                                null,
                                null);
      }
    }

    // Declare fields for all referenced variables from ancestor expressions
    // These are variables where upstreamInput=true that were added to
    // referencedVariables
    declareFieldsForAscendentInputPropagation(classVisitor);

    // Declare context variables
    if (context != null)
    {
      var varList = context.variableEntryStream()
                           .sorted((a, b) -> a.getKey().compareTo(b.getKey()))
                           .toList();
      if (trace)
      {
        String vars = varList.stream().map(f -> f.getKey()).collect(Collectors.joining(","));
        log.debug("declareVariables for {}: context variables {}", className, vars);
      }
      for (var variable : varList)
      {
        declareVariableEntry(classVisitor, variable);
      }
    }

    variablesDeclared = true;
  }

  protected void declareFieldsForAscendentInputPropagation(ClassVisitor classVisitor)
  {
    upstreamInputVariableEntryStream().forEach(entry ->
    {
      String                varName = entry.getKey();
      VariableNode<D, C, F> varNode = entry.getValue();
      Class<?>              varType = varNode.type();
      assert varType != null && !varType.equals(Object.class) : "type of "
                                                                + varNode
                                                                + " should not be Object or null";
      if (trace)
      {
        log.debug("declareVariables for {}: declaring upstreamInput variable {} of type {}",
                  className,
                  varName,
                  varType);
      }
      Compiler.declareField(classVisitor, varName, varType);
    });
  }

  protected Stream<Entry<String, VariableNode<D, C, F>>> upstreamInputVariableEntryStream()
  {
    return referencedVariableEntryStream().filter(upstreamInputVariablePredicate);
  }

  protected Stream<Entry<String, VariableNode<D, C, F>>> referencedVariableEntryStream()
  {
    return referencedVariables.entrySet().stream();
  }

  public boolean defaultToIntegerConstantsWhenPossible()
  {
    return coDomainType.equals(Integer.class);
  }

  public boolean anyAscendentIndeterminateVariableIsNamed(String name)
  {
    for (var indeterminateVariable : indeterminateVariables)
    {
      if (indeterminateVariable != null && indeterminateVariable.getName().equals(name))
      {
        return true;
      }
    }
    if (upstreamExpression != null)
    {
      if (upstreamExpression.anyAscendentIndeterminateVariableIsNamed(name))
      {
        return true;
      }
    }
    return false;
  }

  @Override
  public boolean equals(Object obj)
  {
    return obj instanceof Expression exp ? Objects.equals(rootNode, exp.rootNode) : false;
  }

  /**
   * 
   * @return the results of this{@link #resolveSquareBracketedIndex()} and
   *         this{@link #resolveSubscriptedIndex()} being applied in succession
   */
  protected Node<D, C, F> resolveIndex()
  {
    var index = resolveSquareBracketedIndex();
    return index == null ? index = resolveSubscriptedIndex() : index;
  }

  protected Node<D, C, F> resolveNumericLiteralConstant()
  {
    int startingPosition = position;
    while (isNumeric(character))
    {
      nextCharacter();
    }
    assert position > startingPosition : "didn't read any digits";

    return newLiteralConstant(getExpression().substring(startingPosition, position));
  }

  public Node<D, C, F> resolveOperand() throws CompilerException
  {
    Node<D, C, F> node = null;

    if (nextCharacterIs('['))
    {
      node = new VectorNode<>(this);
    }
    else if (nextCharacterIs('(', '⁽'))
    {
      node = resolve();
      require(')', '⁾');
    }
    else if (nextCharacterIs('∂'))
    {
      node = new DerivativeNode<>(this);
    }
    else if (nextCharacterIs('Đ'))
    {
      node = resolveCaputoFractionalDerivative();
    }
    else if (nextCharacterIs('∫'))
    {
      node = new IntegralNode<>(this);
    }
    else if (nextCharacterIs('Π', '∏'))
    {
      node = new ProductNode<>(this);
    }
    else if (nextCharacterIs('∑', 'Σ'))
    {
      node = new SumNode<>(this);
    }
    else if (isNumeric(character))
    {
      node = resolveNumericLiteralConstant();
    }
    else if (isIdentifierCharacter())
    {
      // PEEK AHEAD: check if identifier is followed by arrow (nested lambda)
      int    savedPos                      = position;
      char   savedChar                     = character;

      String possibleVariableSpecification = parseName();
      skipSpaces();

      if ((character == '➔') && coDomainType.isInterface())
      {
        node = parseLambda(possibleVariableSpecification);
      }
      else
      {
        // Not a lambda, reset and parse normally
        position  = savedPos;
        character = savedChar;
        node      = resolveIdentifier();
      }
    }
    else if (nextCharacterIs('ꟲ'))
    {
      int  savedPos  = position;
      char savedChar = character;
      if (nextCharacterIs('D'))
      {
        node = resolveCaputoFractionalDerivative();
      }
      else
      {
        position  = savedPos;
        character = savedChar;
      }
    }

    return resolvePostfixOperators(node);
  }

  /**
   * FIXME: add support for specifying the variable of differentiation
   * 
   * @return
   */
  protected Node<D, C, F> resolveCaputoFractionalDerivative()
  {
    var α    = require('^').require('(').resolve();
    var f    = require(')').resolveOperand();
    var node = f.fractionalDerivative(null, α);
    return node;
  }

  /**
   * Parses a lambda body by creating a properly-scoped sub-expression.
   * <p>
   * Instead of calling {@link #resolve()} on {@code this} (which leaves all
   * lambda parameters as indeterminates in a single flat scope), this method
   * clones the current expression, clears its independent variable and
   * indeterminate stack, and parses the body in that child scope. The lambda
   * parameter becomes the sub-expression's <em>independent</em> variable,
   * establishing a proper lexical scope boundary. Upstream variables (the
   * parent's independent variable, context variables, etc.) are resolved through
   * the {@link #upstreamExpression} chain, which
   * {@link arb.expressions.nodes.VariableNode#resolveReference} already supports.
   * <p>
   * The lambda parameter is still pushed as an indeterminate on {@code this} so
   * that {@link #newFunctionalExpression()} can find it during code generation.
   *
   * @param paramName the name of the lambda parameter (e.g. "t" in t➔expr)
   * @return the parsed body node, scoped to the child sub-expression
   * @see <a href="https://github.com/crowlogic/arb4j/issues/876">#876</a>
   */
  public Node<D, C, F> parseLambda(String paramName)
  {
    if (trace)
    {
      log.debug("#{}: parseLambda( expr={},  paramName = {} at position {} where remaining={} )",
                System.identityHashCode(this),
                getExpression(),
                paramName,
                position,
                remaining());
    }

    checkLambdaParameterConflicts(paramName);

    // Register the lambda parameter as an indeterminate on THIS expression.
    // newFunctionalExpression() expects to find it on the indeterminate stack
    // during code generation (it peeks the top to promote to independent var
    // of the generated functional class).
    var paramVar   = newVariableNode(paramName);
    var savedParam = paramVar;

    require('➔');

    // --- Create a sub-expression for proper lexical scoping (#876) ---
    Expression<D, C, F> subExpr = cloneExpression();

    // Establish the parent→child relationship so that VariableNode
    // resolveReference can walk up the chain to find upstream variables.
    subExpr.upstreamExpression  = this;

    // Clear the sub-expression's independent variable. When
    // newVariableNode(paramName) is called below, resolveReference will
    // find no existing independent variable and assign paramName to that
    // role — giving the lambda parameter the correct semantics of being
    // the independent variable of this scope rather than a flat
    // indeterminate on the parent's stack.
    subExpr.independentVariable = null;

    // Clear indeterminate variables. The parent's indeterminates are
    // reachable through the upstreamExpression chain; keeping stale
    // copies here would cause duplicate resolution and incorrect scoping.
    subExpr.clearIndeterminateVariables();

    // Clear rootNode so the sub-expression is a fresh parse target
    subExpr.rootNode = null;

    // Resolve paramName as the sub-expression's independent variable.
    subExpr.newVariableNode(paramName);

    // Parse the lambda body in the properly scoped sub-expression.
    // All variable lookups go through subExpr first, then walk
    // upstreamExpression to find x, n, α, etc.
    var node = subExpr.resolve();

    // Sync the parser position back to the parent expression so that
    // parsing can continue after the lambda body.
    this.position          = subExpr.position;
    this.character         = subExpr.character;
    this.previousCharacter = subExpr.previousCharacter;

    // Ensure the lambda parameter is on top of THIS expression's
    // indeterminate stack for newFunctionalExpression() to retrieve.
    if (!indeterminateVariables.isEmpty() && indeterminateVariables.peek() != savedParam)
    {
      indeterminateVariables.remove(savedParam);
      indeterminateVariables.push(savedParam);
    }

    return node;
  }

  private void checkLambdaParameterConflicts(String paramName)
  {
    if (independentVariable != null && Objects.equals(independentVariable.getName(), paramName))
    {
      throw new CompilerException("lambda parameter '"
                                  + paramName
                                  + "' conflicts with the independent variable of the containing expression");
    }

    for (var v : indeterminateVariables)
    {
      if (v != null && Objects.equals(v.getName(), paramName))
      {
        throw new CompilerException("lambda parameter '"
                                    + paramName
                                    + "' conflicts with an existing indeterminate variable");
      }
    }
  }

  public File saveToFile()
  {
    var file = new File(className + ".yaml");
    if (trace)
    {
      log.debug("#{}: saveToFile(): file={}", System.identityHashCode(this), file);
    }
    Utensils.saveToYamlFormat(file, this);
    return file;
  }

  protected Expression<D, C, F> evaluateOptionalIndependentVariableSpecification()
  {
    if (trace)
    {
      log.debug("#{}: evaluateOptionalIndependentVariableSpecification: remaining {} ",
                System.identityHashCode(this),
                remaining());
    }
    setExpression(transformToJavaAcceptableCharacters(getExpression()));

    int searchPos = 0;
    int rightArrowIndex;

    if ((rightArrowIndex = getExpression().indexOf('➔', searchPos)) != -1)
    {
      String  inputVariableName        =
                                getExpression().substring(searchPos, rightArrowIndex).trim();
      boolean isInputVariableSpecified = true;

      isInputVariableSpecified = assureNoNumbersInTheInputVariable(inputVariableName,
                                                                   isInputVariableSpecified);

      if (isInputVariableSpecified)
      {
        assureInputNameHasNotAlreadyBeenAssociatedWithAContextVariable(inputVariableName);

        if (isNullaryFunction())
        {
          // Nullary function: the arrow variable is the indeterminate of the
          // algebraic codomain (e.g. x in a RationalFunction), not an input
          // parameter. Create it as an indeterminate variable so that codegen
          // allocates an intermediate variable + identity() rather than
          // loading the null input parameter.
          VariableNode<D, C, F> indeterminate = new VariableNode<>(this,
                                                                   newVariableReference(inputVariableName),
                                                                   position,
                                                                   false);
          indeterminate.isIndeterminate = true;
          indeterminate.reference.type  = coDomainType;
          assignIndeterminateVariable(indeterminate);
        }
        else
        {
          VariableNode<D, C, F> newRef = newVariableNode(inputVariableName);
          assignVariable(newRef,
                         independentVariable != null && !independentVariable.equals(newRef));
        }
        searchPos = rightArrowIndex + 1;
      }
    }

    position = searchPos - 1;
    return this;
  }

  protected Node<D, C, F> resolveSquareBracketedIndex()
  {
    Node<D, C, F> index = null;
    if (nextCharacterIs('['))
    {
      index = resolve();
      require(']');
    }
    return index;
  }

  protected Node<D, C, F> resolveSubscriptedIndex()
  {
    int startPos = position;

    if (nextCharacterIs(Parser.SUBSCRIPT_DIGITS_ARRAY))
    {
      while (nextCharacterIs(Parser.SUBSCRIPT_DIGITS_ARRAY));
      return newLiteralConstant(getExpression().substring(startPos, position));
    }
    else if (isIdentifierCharacter())
    {
      return resolveIdentifier();
    }
    return null;
  }

  protected VariableReference<D, C, F> resolveVariableReference(int startPos)
  {
    String identifier = parseName(startPos);
    var    index      = resolveIndex();
    return new VariableReference<D, C, F>(identifier,
                                          index);
  }

  protected Node<D, C, F> exponentiate() throws CompilerException
  {
    return exponentiate(resolveOperand());
  }

  protected Node<D, C, F> exponentiate(Node<D, C, F> node) throws CompilerException
  {
    if (nextCharacterIs('^'))
    {
      boolean parenthetical = nextCharacterIs('(', '⁽');
      node = node.pow(parenthetical ? resolve() : resolveOperand());
      if (parenthetical)
      {
        require(')', '⁾');
      }
      return node;
    }
    else
    {
      return parseSuperscripts(node);
    }
  }

  /**
   * @return the result of passing this{@link #exponentiate()} to
   *         this{@link #multiplyAndDivide(Node)}
   */
  protected Node<D, C, F> exponentiateMultiplyAndDivide()
  {
    return multiplyAndDivide(exponentiate());
  }

  /**
   * Generate the implementation of the function after this{@link #parse(boolean)}
   * has been invoked
   * 
   * @return this
   * @throws CompilerException
   */
  public Expression<D, C, F> generate() throws CompilerException
  {
    assert instructions == null;
    if (trace)
    {
      log.debug("#{}: generate(className={}, functionName={}, expression='{}')\n",
                System.identityHashCode(this),
                className,
                functionName,
                getExpression());
    }

    ClassVisitor classVisitor = Compiler.constructClassVisitor();

    try
    {
      generateFunctionInterface(this, className, classVisitor);
      generateDomainTypeMethod(classVisitor);
      generateCoDomainTypeMethod(classVisitor);
      generateEvaluationMethod(classVisitor);
      generateDiffererentiationAndIntegrationMethods(classVisitor);
      declareFields(classVisitor);
      generateInitializationMethod(classVisitor);
      generateConstructor(classVisitor);
      declareIntermediateVariables(classVisitor);
      if (needsCloseMethod())
      {
        generateCloseMethod(classVisitor);
      }
      generateGetNameMethod(classVisitor);
      generateGetContextMethod(classVisitor);

      generateToStringMethod(classVisitor);
      generateTypesetMethod(classVisitor);
    }
    finally
    {
      classVisitor.visitEnd();
    }

    logVariables();

    return storeInstructions(classVisitor);
  }

  /**
   * @see {@link RealPolynomialSequence#derivative()}
   *      {@link RealPolynomialSequence#integral()} and
   *      {@link ComplexPolynomialSequence#derivative()} and
   *      {@link ComplexPolynomialSequence#integral()} for the default
   *      implementation which is used in the non-nullary polynomial sequence case
   * 
   */
  protected void generateDiffererentiationAndIntegrationMethods(ClassVisitor classVisitor)
  {
    if (!isNullaryFunction() && !Polynomial.class.isAssignableFrom(coDomainType))
    {
      // Non-polynomial, non-nullary: generate symbolic derivative/integral methods
      generateDerivativeMethod(classVisitor);
      generateIntegralMethod(classVisitor);
    }
    else if (Polynomial.class.isAssignableFrom(coDomainType))
    {
      if (isNullaryFunction())
      {

        generatePolynomialMethod(classVisitor, "integral");
        generatePolynomialMethod(classVisitor, "derivative");
      }
      // NON-NULLARY polynomial sequences (e.g. RealPolynomialSequence,
      // ComplexPolynomialSequence): DO NOTHING HERE.
      // The interface declares default integral()/derivative() methods that
      // delegate to the polynomial's own integral()/derivative() via lambda.
      // Generating bytecode here would OVERRIDE those default methods and break
      // differentiation by using the sequence index instead of the polynomial's
      // indeterminate variable.
    }
  }

  protected void generateAssertionThatOrderIsLessThanOrEqualTo1(MethodVisitor mv)
  {

    Label label1 = new Label();
    mv.visitVarInsn(ILOAD, 2);
    mv.visitInsn(ICONST_1);
    mv.visitJumpInsn(IF_ICMPLE, label1);
    mv.visitTypeInsn(NEW, "java/lang/AssertionError");
    mv.visitInsn(DUP);
    mv.visitVarInsn(ILOAD, 2);
    mv.visitInvokeDynamicInsn("makeConcatWithConstants",
                              "(I)Ljava/lang/String;",
                              new Handle(Opcodes.H_INVOKESTATIC,
                                         "java/lang/invoke/StringConcatFactory",
                                         "makeConcatWithConstants",
                                         "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;",
                                         false),
                              new Object[]
                              { "TODO: implement order=\u0001>1" });
    mv.visitMethodInsn(INVOKESPECIAL,
                       "java/lang/AssertionError",
                       "<init>",
                       "(Ljava/lang/Object;)V",
                       false);
    mv.visitInsn(ATHROW);
    mv.visitLabel(label1);
  }

  protected MethodVisitor generateCloseFieldCall(MethodVisitor methodVisitor,
                                                 String fieldName,
                                                 Class<?> fieldType)
  {
    getFieldFromThis(methodVisitor, className, fieldName, fieldType);
    return invokeCloseMethod(methodVisitor, fieldType);
  }

  protected ClassVisitor generateCloseMethod(ClassVisitor classVisitor)
  {
    var methodVisitor = defineMethod(classVisitor, "close", VOID_METHOD_DESCRIPTOR);

    methodVisitor.visitCode();

    if (!coDomainType.isInterface())
    {
      getSortedLiteralConstantNodes().forEach(constant -> generateCloseFieldCall(loadThisOntoStack(methodVisitor),
                                                                                 constant.fieldName,
                                                                                 constant.type()));

      sortedIntermediateVariables().forEach(intermediateVariable -> generateCloseFieldCall(loadThisOntoStack(methodVisitor),
                                                                                           intermediateVariable.name,
                                                                                           intermediateVariable.type));

      referencedFunctions.forEach((name,
                                   mapping) -> generateCloseFieldCall(loadThisOntoStack(methodVisitor),
                                                                      name,
                                                                      mapping.type()));
    }

    Compiler.generateReturnFromVoidMethod(methodVisitor);

    return classVisitor;
  }

  protected void generateCodeToSetIsInitializedToTrue(MethodVisitor methodVisitor)
  {
    loadThisOntoStack(methodVisitor).visitInsn(Opcodes.ICONST_1);
    methodVisitor.visitFieldInsn(PUTFIELD, className, IS_INITIALIZED, "Z");
  }

  protected void generateCodeToThrowErrorIfAlreadyInitialized(MethodVisitor mv)
  {
    loadThisOntoStack(mv);
    mv.visitFieldInsn(GETFIELD, className, IS_INITIALIZED, "Z");
    var alreadyInitializedLabel = new Label();
    mv.visitJumpInsn(IFEQ, alreadyInitializedLabel);
    mv.visitTypeInsn(NEW, JAVA_LANG_ASSERTION_ERROR);
    duplicateTopOfTheStack(mv).visitLdcInsn("Already initialized");
    mv.visitMethodInsn(INVOKESPECIAL,
                       JAVA_LANG_ASSERTION_ERROR,
                       "<init>",
                       ASSERTION_ERROR_METHOD_DESCRIPTOR,
                       false);
    mv.visitInsn(ATHROW);
    mv.visitLabel(alreadyInitializedLabel);
  }

  protected ClassVisitor
            generateCoDomainTypeMethod(ClassVisitor classVisitor) throws CompilerException
  {
    return generateTypeMethod(classVisitor,
                              "coDomainType",
                              Type.getType(coDomainType),
                              getCoDomainTypeMethodSignature());
  }

  protected MethodVisitor generateConditionalInitializater(MethodVisitor mv)
  {
    var alreadyInitialized = new Label();
    getFieldFromThis(mv, className, IS_INITIALIZED, boolean.class);
    jumpToIfNotEqual(mv, alreadyInitialized);
    loadThisOntoStack(mv).visitMethodInsn(INVOKEVIRTUAL,
                                          className,
                                          nameOfInitializerFunction,
                                          "()V",
                                          false);
    Compiler.designateLabel(mv, alreadyInitialized);
    return mv;
  }

  protected ClassVisitor generateConstructor(ClassVisitor classVisitor)
  {
    MethodVisitor mv = classVisitor.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
    mv.visitCode();

    generateInvocationOfDefaultNoArgConstructor(mv, true);

    // Only root expressions create their own Context.
    // Child arg classes receive the parent's context via initialize() (#842)
    if (context != null && upstreamExpression == null)
    {
      generateContextInitializer(mv);
    }

    if (!coDomainType.isInterface())
    {
      generateLiteralConstantInitializers(mv);
    }

    generateIntermediateVariableInitializers(mv);

    Compiler.generateReturnFromVoidMethod(mv);
    return classVisitor;
  }

  public MethodVisitor generateContextInitializer(MethodVisitor methodVisitor)
  {

    loadThisOntoStack(methodVisitor);
    String contextTypeInternalName = Type.getInternalName(Context.class);
    methodVisitor.visitTypeInsn(NEW, contextTypeInternalName);
    methodVisitor.visitInsn(DUP);
    methodVisitor.visitMethodInsn(INVOKESPECIAL, contextTypeInternalName, "<init>", "()V", false);
    methodVisitor.visitFieldInsn(PUTFIELD, className, "context", Context.class.descriptorString());
    return methodVisitor;
  }

  protected void generateDependencyAssignment(MethodVisitor mv,
                                              String functionName,
                                              String functionDescriptor,
                                              String assignment)
  {
    var otherMapping = referencedFunctions.get(assignment);

    if (Expression.trace)
    {
      log.debug("generateDependencyAssignment: functionName={} functionDescriptor={} assignment={}",
                functionName,
                functionDescriptor,
                assignment);
    }
    loadThisOntoStack(mv).visitFieldInsn(GETFIELD,
                                         className,
                                         assignment,
                                         otherMapping.functionFieldDescriptor());
    loadThisOntoStack(mv).visitFieldInsn(GETFIELD, className, functionName, functionDescriptor);
    mv.visitFieldInsn(PUTFIELD, assignment, functionName, functionDescriptor);
  }

  protected void generateDependencyAssignments(MethodVisitor mv, Dependency dependency)
  {
    var assignments        = dependency.getAssignments(className, referencedFunctions);

    var functionName       = dependency.variableName;
    var mapping            = referencedFunctions.get(functionName);
    var functionDescriptor = functionClass.descriptorString();

    if (mapping != null)
    {

      functionDescriptor = mapping.functionFieldDescriptor();

      // Phase 1 (generateReferencedFunctionInstances) already guarantees non-null
      // (#848)
      generateFunctionInitializer(mv, mapping, assignments);

      for (String assignment : assignments)
      {
        generateDependencyAssignment(mv, functionName, functionDescriptor, assignment);
      }

    }
  }

  private ClassVisitor generateDerivativeMethod(ClassVisitor classVisitor)
  {
    assert functionClass.isInterface() : functionClass + " is not an interface";

    assert rootNode != null : "rootNode is null";

    var mv = classVisitor.visitMethod(Opcodes.ACC_PUBLIC,
                                      "derivative",
                                      Compiler.getMethodDescriptor(functionClass),
                                      null,
                                      null);
    mv.visitCode();
    Compiler.annotateWithOverride(mv);

    mv.visitLdcInsn(Type.getType(domainType));
    mv.visitLdcInsn(Type.getType(coDomainType));
    mv.visitLdcInsn(Type.getType(functionClass));
    mv.visitLdcInsn("_diff" + className);
    try
    {
      mv.visitLdcInsn(String.format("diff(%s,%s)", rootNode.toString(), independentVariable));

      // mv.visitLdcInsn(rootNode.differentiate().toString());
    }
    catch (Throwable e)
    {
      mv.visitLdcInsn("TODO: implement differentiation of " + getExpression());

    }

    loadThisFieldOntoStack(mv, "context", Context.class);

    Compiler.invokeStaticMethod(mv,
                                Function.class,
                                "express",
                                Function.class,
                                Class.class,
                                Class.class,
                                Class.class,
                                String.class,
                                String.class,
                                Context.class);
    Compiler.generateReturnFromMethod(mv);
    return classVisitor;
  }

  protected ClassVisitor
            generateDomainTypeMethod(ClassVisitor classVisitor) throws CompilerException
  {
    return generateTypeMethod(classVisitor,
                              "domainType",
                              Type.getType(domainType),
                              getDomainTypeMethodSignature());
  }

  public void logVariables()
  {
    accept(containingExpression -> log.debug("#{}: logVariables: independentVariable={} indeterminateVariables={} upstreamExpression={}",
                                             System.identityHashCode(containingExpression),
                                             containingExpression.independentVariable,
                                             containingExpression.indeterminateVariables,
                                             containingExpression.upstreamExpression));

  }

  protected ClassVisitor
            generateEvaluationMethod(ClassVisitor classVisitor) throws CompilerException
  {
    if (rootNode == null)
    {
      parse(true);
    }

    Label startLabel = new Label();
    Label endLabel   = new Label();

    var   mv         = visitEvaluationMethod(classVisitor);
    mv.visitCode();

    if (orderLimited())
    {
      generateAssertionThatOrderIsLessThanOrEqualTo1(mv);
    }

    designateLabel(mv, startLabel);
    Compiler.annotateWithOverride(mv);
    if (needsInitializer())
    {
      generateConditionalInitializater(mv);
    }

    rootNode.isResult = true;
    if (isFunctional())
    {
      generateFunctionalElement(mv);
    }
    else
    {
      rootNode.generate(mv, coDomainType);
    }

    designateLabel(mv, endLabel);
    declareEvaluateMethodsLocalVariableArguments(mv, startLabel, endLabel);
    Compiler.generateReturnFromMethod(mv);
    return classVisitor;
  }

  /**
   * Generate the code when the {@link #coDomainType} is an interface so that the
   * return value is itself a {@link Function}, in this case the result argument
   * is ignored since there {@link Function} is immutable
   * 
   * TODO: fix the generic types on this and revisit this.
   * 
   * TODO: the generated toString() of this method should show the value instead
   * of the variable name if it is declared in an upstream expression (in which
   * case the value is known)
   * 
   * 
   * @param mv
   * @return initialized this{@link #newFunctionalExpression()}
   */
  protected Expression<Object, Object, Function<?, ?>> generateFunctionalElement(MethodVisitor mv)
  {
    var functional = newFunctionalExpression();
    functionalDependsOnIndependentVariable = false;
    functionalIndependentVariable          = null;

    if (independentVariable != null)
    {
      functionalIndependentVariable = independentVariable.spliceInto(functional).asVariable();
    }

    if (!indeterminateVariables.isEmpty())
    {
      for (var indeterminantVariable : indeterminateVariables)
      {
        var functionalIndeterminateVariable = indeterminantVariable.spliceInto(functional)
                                                                   .asVariable();
        functionalIndeterminateVariables.push(functionalIndependentVariable);
        functionalDependsOnIndeterminateVariable = functionalDependsOnIndeterminateVariable
                      || functional.rootNode.dependsOn(functionalIndeterminateVariable);
      }
    }

    functional.generate();

    if (functionalIndependentVariable != null)
    {
      functionalDependsOnIndependentVariable =
                                             functional.rootNode.dependsOn(functionalIndependentVariable);
    }

    constructNewObject(mv, functional.className);
    duplicateTopOfTheStack(mv);
    invokeDefaultConstructor(mv, functional.className);

    if (functionalDependsOnIndependentVariable)
    {
      copyIndependentVariableToFunctionalByValue(mv, functional, functionalIndependentVariable);
    }

    // Propagate ascendent input variables (e.g. 'n' from grandparent scope)
    // that the functional references but that are NOT the current expression's
    // independent variable (already handled above).
    propagateAscendentInputVariablesToFunctional(mv, functional);

    if (context != null)
    {
      propagateContext(mv, functional);
    }

    invokeInitializationMethod(mv, functional);

    return functional.compile();
  }

  /**
   * Propagates ascendent input variables from this expression's fields to a newly
   * constructed functional instance via copy-by-value (.set()), with null-check
   * and allocation if the destination field is null.
   *
   * This runs inside the evaluate() method where the functional instance is on
   * top of the operand stack. For each variable that the functional references
   * from an ancestor scope (and that is a field on this class), we generate:
   *
   * if (funcInst.varName == null) funcInst.varName = new VarType();
   * funcInst.varName.set(this.varName);
   *
   * @param mv         the MethodVisitor for the evaluate method being generated
   * @param functional the functional expression whose instance needs the
   *                   variables
   */
  protected void propagateAscendentInputVariablesToFunctional(MethodVisitor mv,
                                                              Expression<?, ?, ?> functional)
  {
    for (var entry : functional.referencedVariables.entrySet())
    {
      String                varName = entry.getKey();
      VariableNode<?, ?, ?> varNode = entry.getValue();

      // Only propagate upstream input variables
      if (varNode.isIndependent || varNode.isIndeterminate)
      {
        continue;
      }

      // Skip the current expression's independent variable — it lives in the
      // evaluate parameter slot, not as a field on this class. Already handled
      // by propagateIndependentVariableToFunctional.
      if (independentVariable != null && varName.equals(independentVariable.getName()))
      {
        continue;
      }

      // Skip context variables — propagated separately by propagateContext
      if (context != null && context.getVariable(varName) != null)
      {
        continue;
      }

      Class<?> varType = varNode.type();
      if (varType == null || varType.equals(Object.class))
      {
        continue;
      }

      if (trace)
      {
        log.debug("propagateAscendentInputVariablesToFunctional: {} of type {} to {}",
                  varName,
                  varType,
                  functional.className);
      }

      String fieldDescriptor = varType.descriptorString();

      // ── Stack: ..., funcInst ──

      // Null-check: if funcInst.varName == null, allocate a new instance
      Label  fieldNotNull    = new Label();
      duplicateTopOfTheStack(mv); // funcInst, funcInst
      getField(mv, functional.className, varName, fieldDescriptor); // funcInst, field|null
      mv.visitJumpInsn(IFNONNULL, fieldNotNull); // funcInst

      // Null branch: funcInst.varName = new VarType()
      duplicateTopOfTheStack(mv); // funcInst, funcInst
      generateNewObjectInstruction(mv, varType); // funcInst, funcInst, new
      duplicateTopOfTheStack(mv); // funcInst, funcInst, new, new
      invokeDefaultConstructor(mv, varType); // funcInst, funcInst, new
      putField(mv, functional.className, varName, varType); // funcInst

      designateLabel(mv, fieldNotNull); // funcInst

      // Copy by value: funcInst.varName.set(this.varName)
      duplicateTopOfTheStack(mv); // funcInst, funcInst
      getField(mv, functional.className, varName, fieldDescriptor); // funcInst, field (non-null)
      loadThisFieldOntoStack(mv, varName, varType); // funcInst, field, this.var
      generateVirtualMethodInvocation(mv, varType, "set", varType, varType); // funcInst, retVal
      pop(mv); // funcInst
    }
  }

  public VariableNode<D, C, F> getIndeterminateVariable()
  {
    return indeterminateVariables.isEmpty() ? null : indeterminateVariables.peek();
  }

  protected MethodVisitor generateFunctionInitializer(MethodVisitor mv,
                                                      FunctionMapping<?, ?, ?> nestedFunction,
                                                      List<String> assignments)
  {
    assert nestedFunction != null : "nestedFunction shan't be null";
    if (trace)
    {
      log.debug(String.format("generateFunctionInitializer for className=%s functionName=%s: nestedFunction=%s, assignments=%s )",
                              className,
                              functionName,
                              nestedFunction.functionName,
                              assignments));
    }

    ;

    if (nestedFunction.instance != null && nestedFunction.isGenerated())
    {
      // filter using the declarationPredicate if its trying to write to variables
      // that weren't in the context at the time of the functions compilation and/or
      // the function doesnt reference the specific variables so their values must not
      // be attempted to be injected
      var variableStream         = context.variableClassStream();
      var nestedExpression       = nestedFunction.expression;
      var declaredVariableStream =
                                 variableStream.filter(variable -> nestedExpression.hasDeclaredVariable(variable.getLeft()));
      initializeReferencedFunctionVariableReferences(loadThisOntoStack(mv),
                                                     className,
                                                     Type.getInternalName(nestedFunction.type()),
                                                     nestedFunction.functionName,
                                                     declaredVariableStream);
    }
    else
    {
      referencedFunctions.put(nestedFunction.functionName, nestedFunction);
    }

    return mv;
  }

  /**
   * 
   * @param varName
   * @return true if {@link #declaredVariables} contains varName
   */
  public boolean hasDeclaredVariable(String name)
  {
    return declaredVariables.contains(name);
  }

  protected ClassVisitor generateGetContextMethod(ClassVisitor classVisitor)
  {
    var methodVisitor = classVisitor.visitMethod(Opcodes.ACC_PUBLIC,
                                                 "getContext",
                                                 Compiler.getMethodDescriptor(Context.class),
                                                 null,
                                                 null);

    methodVisitor.visitCode();
    Compiler.annotateWithOverride(methodVisitor);

    Compiler.getFieldFromThis(methodVisitor, className, "context", Context.class);

    Compiler.generateReturnFromMethod(methodVisitor);
    return classVisitor;
  }

  protected ClassVisitor generateGetNameMethod(ClassVisitor classVisitor)
  {
    var methodVisitor = classVisitor.visitMethod(Opcodes.ACC_PUBLIC,
                                                 "getName",
                                                 Compiler.getMethodDescriptor(String.class),
                                                 null,
                                                 null);

    methodVisitor.visitCode();
    Compiler.annotateWithOverride(methodVisitor);

    if (functionName != null)
    {
      methodVisitor.visitLdcInsn(functionName);
    }
    else
    {
      methodVisitor.visitInsn(Opcodes.ACONST_NULL);
    }
    Compiler.generateReturnFromMethod(methodVisitor);
    return classVisitor;
  }

  protected MethodVisitor generateInitializationCode(MethodVisitor mv)
  {
    generateCodeToThrowErrorIfAlreadyInitialized(mv);
    if (trace)
    {
      log.debug("generateInitializationCode for className={} functionName={}: referencedFunctions={}",
                className,
                functionName,
                referencedFunctions.keySet());
    }
    addChecksForNullVariableReferences(mv);

    // Phase 1: Ensure all referenced function instances are constructed
    // (null-check + new). This must happen before context wiring.
    generateReferencedFunctionInstances(mv);

    // Phase 2: Wire context and upstream variables to the now-existing
    // nested function instances, BEFORE dependency initialization which
    // may call methods (hypergeometric init/evaluate) that use them.
    propagateAscendentInputVariablesToNestedFunctions(mv);

    // Phase 3: Initialize in proper dependency order.
    // The duplicate constructReferencedFunctionInstanceIfItIsNull call
    // was removed from generateDependencyAssignments since Phase 1
    // already guarantees non-null (#848).
    if (dependencies != null)
    {
      dependencies.forEach(dependency -> generateDependencyAssignments(mv, dependency));
    }

    try
    {
      insideInitializer = true;
      initializers.forEach(initializer -> initializer.accept(mv));
    }
    finally
    {
      insideInitializer = false;
    }

    if (recursive)
    {
      generateSelfReference(mv);
    }
    generateCodeToSetIsInitializedToTrue(mv);
    return mv;
  }

  /**
   * Propagates the parent's context and upstream input variables (variables from
   * ancestor expressions) to nested operand functions that reference them.
   *
   * For child arg classes whose constructors no longer create their own Context
   * (see #842), this method assigns this.context to each arg's context field
   * before any variable propagation occurs.
   *
   * IMPORTANT: This method runs inside the initialize() method, which has NO
   * input parameter (only 'this' in slot 0). Therefore, it must NOT attempt to
   * propagate the current expression's independent variable, because that
   * variable is NOT a field on the generated class — it exists only as the
   * evaluate() method's input parameter (slot 1). The independent variable is
   * propagated at evaluate-time by NAryOperationNode.propagateInputToOperand and
   * similar mechanisms.
   */
  protected void propagateAscendentInputVariablesToNestedFunctions(MethodVisitor mv)
  {
    // For each referenced function (nested operand functions)
    for (var funcEntry : referencedFunctions.entrySet())
    {
      String                   funcFieldName = funcEntry.getKey();
      FunctionMapping<?, ?, ?> funcMapping   = funcEntry.getValue();

      // Skip if this is a self-reference or not a generated expression
      if (funcFieldName.equals(functionName) || funcMapping.expression == null)
      {
        continue;
      }

      Expression<?, ?, ?> nestedExpr = funcMapping.expression;
      if (nestedExpr == null)
      {
        continue;
      }

      String funcTypeDesc    = funcMapping.functionFieldDescriptor();
      String nestedClassName = funcMapping.functionName;

      // Share parent's context with child arg class (#842)
      if (nestedExpr.upstreamExpression != null)
      {
        String contextTypeDesc = Context.class.descriptorString();
        // Generate: this.<funcFieldName>.context = this.context
        loadThisOntoStack(mv);
        mv.visitFieldInsn(GETFIELD, className, funcFieldName, funcTypeDesc);
        loadThisOntoStack(mv);
        mv.visitFieldInsn(GETFIELD, className, "context", contextTypeDesc);
        mv.visitFieldInsn(PUTFIELD, nestedClassName, "context", contextTypeDesc);
      }

      // Check each variable referenced by the nested expression
      for (var varEntry : nestedExpr.referencedVariables.entrySet())
      {
        String                varName = varEntry.getKey();
        VariableNode<?, ?, ?> varNode = varEntry.getValue();

        // Skip independent variables and indeterminates of the nested expression
        if (varNode.isIndependent || varNode.isIndeterminate)
        {
          continue;
        }

        // Skip if already declared as upstream independent variable
        if (upstreamExpression != null && upstreamExpression.independentVariable != null
                      && varName.equals(upstreamExpression.independentVariable.getName()))
        {
          continue;
        }

        // Skip context variables (they are propagated separately)
        if (context != null && context.getVariable(varName) != null)
        {
          continue;
        }

        // CRITICAL: Skip the current expression's independent variable.
        // It is NOT a field on this generated class — it only exists as the
        // evaluate() input parameter. Attempting to GETFIELD it here (inside
        // initialize(), which has no input parameter) causes VerifyError.
        // The independent variable is propagated at evaluate-time instead.
        if (independentVariable != null && varName.equals(independentVariable.getName()))
        {
          continue;
        }

        // This is an upstream input variable - propagate it
        Class<?> varType = varNode.type();
        if (varType != null && !varType.equals(Object.class))
        {
          if (trace)
          {
            log.debug("propagateAscendentInputVariables: propagating {} to {} in {}",
                      varName,
                      funcFieldName,
                      className);
          }

          String varTypeDesc = varType.descriptorString();

          // Generate: this.<funcFieldName>.<varName> = this.<varName>
          loadThisOntoStack(mv);
          mv.visitFieldInsn(GETFIELD, className, funcFieldName, funcTypeDesc);
          loadThisOntoStack(mv);
          mv.visitFieldInsn(GETFIELD, className, varName, varTypeDesc);
          mv.visitFieldInsn(PUTFIELD, nestedClassName, varName, varTypeDesc);
        }
      }
    }
  }

  protected ClassVisitor generateInitializationMethod(ClassVisitor classVisitor)
  {
    var methodVisitor = classVisitor.visitMethod(Opcodes.ACC_PUBLIC,
                                                 nameOfInitializerFunction,
                                                 "()V",
                                                 null,
                                                 null);
    Compiler.annotateWithOverride(methodVisitor);

    try
    {
      methodVisitor.visitCode();
      generateInitializationCode(methodVisitor);

    }
    finally
    {
      Compiler.generateReturnFromVoidMethod(methodVisitor);
    }

    return classVisitor;
  }

  private ClassVisitor generateIntegralMethod(ClassVisitor classVisitor)
  {
    assert functionClass.isInterface() : functionClass + " is not an interface";

    assert rootNode != null : "rootNode is null";

    var mv = classVisitor.visitMethod(Opcodes.ACC_PUBLIC,
                                      "integral",
                                      Compiler.getMethodDescriptor(functionClass),
                                      null,
                                      null);
    mv.visitCode();
    Compiler.annotateWithOverride(mv);

    mv.visitLdcInsn(Type.getType(domainType));
    mv.visitLdcInsn(Type.getType(coDomainType));
    mv.visitLdcInsn(Type.getType(functionClass));
    mv.visitLdcInsn("_int" + functionName);
    mv.visitLdcInsn(String.format("int(%s,%s)", rootNode.toString(), independentVariable));

    if (context != null)
    {
      loadThisFieldOntoStack(mv, "context", Context.class);

      Compiler.invokeStaticMethod(mv,
                                  Function.class,
                                  "express",
                                  Function.class,
                                  Class.class,
                                  Class.class,
                                  Class.class,
                                  String.class,
                                  String.class,
                                  Context.class);
    }
    else
    {
      Compiler.invokeStaticMethod(mv,
                                  Function.class,
                                  "express",
                                  Function.class,
                                  Class.class,
                                  Class.class,
                                  Class.class,
                                  String.class,
                                  String.class);

    }

    Compiler.generateReturnFromMethod(mv);

    return classVisitor;
  }

  protected MethodVisitor generateIntermediateVariableInitializers(MethodVisitor methodVisitor)
  {
    for (var intermediateVariable : sortedIntermediateVariables())
    {
      intermediateVariable.generateInitializer(methodVisitor);
    }
    return methodVisitor;
  }

  protected void generateInvocationOfDefaultNoArgConstructor(MethodVisitor methodVisitor,
                                                             boolean object)
  {
    loadThisOntoStack(methodVisitor);
    methodVisitor.visitMethodInsn(INVOKESPECIAL,
                                  object ? Type.getInternalName(Object.class)
                                         : className.replace(".", "/"),
                                  "<init>",
                                  "()V",
                                  false);
  }

  protected MethodVisitor generateLiteralConstantInitializers(MethodVisitor methodVisitor)
  {
    for (var literal : getSortedLiteralConstantNodes())
    {
      literal.generateLiteralConstantInitializer(methodVisitor);
    }
    return methodVisitor;
  }

  protected ClassVisitor generatePolynomialMethod(ClassVisitor classVisitor, String operation)
  {

    assert functionClass.isInterface() : functionClass + " is not an interface";

    assert rootNode != null : "rootNode is null";

    var methodVisitor = classVisitor.visitMethod(Opcodes.ACC_PUBLIC,
                                                 operation,
                                                 Compiler.getMethodDescriptor(Function.class),
                                                 null,
                                                 null);
    methodVisitor.visitCode();
    Compiler.annotateWithOverride(methodVisitor);

    methodVisitor.visitVarInsn(ALOAD, 0);
    methodVisitor.visitMethodInsn(INVOKEVIRTUAL,
                                  className,
                                  "evaluate",
                                  Compiler.getMethodDescriptor(Object.class),
                                  false);
    methodVisitor.visitTypeInsn(CHECKCAST, Type.getInternalName(coDomainType));

    methodVisitor.visitMethodInsn(INVOKEVIRTUAL,
                                  Type.getInternalName(coDomainType),
                                  operation,
                                  Compiler.getMethodDescriptor(coDomainType),
                                  false);
    Compiler.generateReturnFromMethod(methodVisitor);
    return classVisitor;
  }

  public void generateReferencedFunctionInstances(MethodVisitor mv)
  {
    referencedFunctions.values()
                       .forEach(mapping -> constructReferencedFunctionInstanceIfItIsNull(mv,
                                                                                         mapping));
  }

  protected MethodVisitor generateSelfReference(MethodVisitor mv)
  {
    constructNewObject(loadThisOntoStack(mv), functionName);
    invokeDefaultConstructor(duplicateTopOfTheStack(mv), functionName);
    FunctionMapping<?, ?, ?> mapping = referencedFunctions.get(functionName);
    assert mapping != null : "no function mapping for " + functionName;
    putField(mv, className, functionName, mapping.functionFieldDescriptor());
    initializeReferencedFunctionVariableReferences(loadThisOntoStack(mv),
                                                   className,
                                                   functionName,
                                                   functionName,
                                                   context.variableClassStream());
    return mv;
  }

  public MethodVisitor generateSetResultInvocation(MethodVisitor mv, Class<?> inputType)
  {
    loadResultParameter(mv);
    cast(mv, coDomainType);
    swap(mv);
    return invokeSetMethod(mv, inputType, coDomainType);
  }

  /**
   * TODO: need to generate instructions so that the toString() uses String.format
   * to include the value (only if it was part of the independent variable because
   * thats the only its valued is fixed for the duration of the instance of the
   * class, if its just a Context variable then it can change between invocations
   *
   * @param classVisitor
   * @return
   */
  protected ClassVisitor generateToStringMethod(ClassVisitor classVisitor)
  {

    var methodVisitor = classVisitor.visitMethod(Opcodes.ACC_PUBLIC,
                                                 "toString",
                                                 Compiler.getMethodDescriptor(String.class),
                                                 null,
                                                 null);

    methodVisitor.visitCode();

    String name = "";
    if (functionName != null && !functionName.isEmpty())
    {
      name = functionName + ":";
    }
    updateStringRepresentation();
    String arrow  = getExpression().contains("➔")
                  || independentVariable == null ? "" : (independentVariable.getName() + "➔");

    String string = String.format("%s%s%s", name, arrow, getExpression());
    methodVisitor.visitLdcInsn(string);

    if (Expression.trace)
    {
      log.debug("generateToStringMethod(): functionName='{}' independentVariable='{}' name='{}' arrow='{}' string='{}'",
                functionName,
                independentVariable,
                name,
                arrow,
                string);
    }

    Compiler.generateReturnFromMethod(methodVisitor);
    return classVisitor;
  }

  protected String getStringRepresentation()
  {
    String name = (functionName != null) ? (functionName + ":") : "";
    updateStringRepresentation();
    String arrow  = getExpression().contains("➔")
                  || independentVariable == null ? "" : (independentVariable.getName() + "➔");
    String string = String.format("%s%s%s", name, arrow, getExpression());

    if (Expression.trace)
    {
      log.debug("generateToStringMethod(): functionName='{}' independentVariable='{}' name='{}' arrow='{}' string='{}'",
                functionName,
                independentVariable,
                name,
                arrow,
                string);
    }
    return string;
  }

  private ClassVisitor generateTypeMethod(ClassVisitor classVisitor,
                                          String which,
                                          Type type,
                                          String methodSignature)
  {
    var mv = classVisitor.visitMethod(Opcodes.ACC_PUBLIC,
                                      which,
                                      Compiler.getMethodDescriptor(Class.class),
                                      methodSignature,
                                      null);

    Compiler.annotateWithOverride(mv);
    mv.visitCode();
    mv.visitLdcInsn(type);
    Compiler.generateReturnFromMethod(mv);
    return classVisitor;
  }

  protected ClassVisitor generateTypesetMethod(ClassVisitor classVisitor)
  {

    return Compiler.generateTypesetMethod(classVisitor, typeset());
  }

  @Override
  public F get()
  {
    return instantiate();
  }

  protected String getCoDomainTypeMethodSignature()
  {
    return Compiler.getTypeMethodSignature(coDomainType);
  }

  public AtomicInteger getConstantCounter(Class<?> type)
  {
    AtomicInteger counter = constantCounts.get(type);
    if (counter == null)
    {
      counter = new AtomicInteger();
      constantCounts.put(type, counter);
    }
    return counter;
  }

  protected String getDomainTypeMethodSignature()
  {
    return Compiler.getTypeMethodSignature(domainType);
  }

  private String getEvaluationMethodSignature()
  {
    return Compiler.getMethodDescriptor(coDomainType,
                                        domainType,
                                        int.class,
                                        int.class,
                                        coDomainType);
  }

  protected String getFunctionClassTypeSignature(Class<? extends Function<?, ?>> functionClass)
  {
    return Compiler.getFunctionClassTypeSignature(functionClass,
                                                  domainType,
                                                  coDomainType,
                                                  implementedInterfaces);
  }

  public VariableNode<D, C, F> getIndependentVariable()
  {
    return independentVariable;
  }

  protected String getInputName()
  {
    var indeterminantVariable = getIndeterminateVariable();
    if (indeterminantVariable != null)
    {
      return indeterminantVariable.getName();
    }
    else if (independentVariable != null)
    {
      return independentVariable.getName();
    }
    return null;
  }

  public VariableNode<D, C, F> getInputVariable()
  {
    var indeterminantVariable = getIndeterminateVariable();
    return indeterminantVariable != null ? indeterminantVariable : independentVariable;
  }

  public String getNextConstantFieldName(Class<?> type)
  {
    return "c"
           + getVariablePrefix(type)
           + String.format("%04d", getConstantCounter(type).getAndIncrement());
  }

  public String getNextIntermediateVariableFieldName(String name, Class<?> type)
  {
    if (context == null)
    {
      context = new Context();
    }
    var prefix  = name + getVariablePrefix(type);
    var counter = context.intermediateVariableCounters.get(prefix);
    if (counter == null)
    {
      context.intermediateVariableCounters.put(prefix, counter = new AtomicInteger(1));
    }
    return prefix + String.format("%04d", counter.getAndIncrement());
  }

  public VariableNode<D, C, F> getReference(String reference)
  {
    return referencedVariables.get(reference);
  }

  protected ArrayList<LiteralConstantNode<D, C, F>> getSortedLiteralConstantNodes()
  {
    if (literalConstantNodes == null)
    {
      literalConstantNodes = new ArrayList<>(literalConstants.values().stream().toList());
      Collections.sort(literalConstantNodes, (a, b) -> a.fieldName.compareTo(b.fieldName));
      return literalConstantNodes;
    }
    return literalConstantNodes;
  }

  @SuppressWarnings("unchecked")
  public <Q extends Named> Q getVariable(VariableReference<D, C, F> reference)
  {
    return context == null ? null : (Q) context.variables.get(reference.name);
  }

  public boolean hasIndeterminateVariable()
  {
    return (domainType.equals(Object.class)
                  && thisOrAnyAscendentExpressionHasIndeterminantVariable());
  }

  public boolean hasIntermediateVariable(String string)
  {
    return intermediateVariables.containsKey(string);
  }

  public boolean hasScalarCodomain()
  {
    return coDomainType.equals(Real.class) || coDomainType.equals(Complex.class)
                  || coDomainType.equals(Fraction.class) || coDomainType.equals(Integer.class)
                  || coDomainType.equals(ComplexFraction.class)
                  || coDomainType.equals(GaussianInteger.class);
  }

  protected String[] implementedInterfaces()
  {
    return Stream.concat(Stream.of(genericFunctionClassInternalName),
                         Stream.of(implementedInterfaces).map(Type::getInternalName))
                 .toArray(n -> new String[n]);
  }

  /**
   * Propagates {@link VariableReference}s from this function to a nested function
   * specified
   * 
   * @param mv
   * @param generatedFunctionClassInternalName
   * @param fieldType
   * @param functionFieldName                  name of the field to have its
   *                                           variables injected from this one
   * @param variables
   */
  protected void
            initializeReferencedFunctionVariableReferences(MethodVisitor mv,
                                                           String generatedFunctionClassInternalName,
                                                           String fieldType,
                                                           String functionFieldName,
                                                           Stream<OrderedPair<String, Class<?>>> variables)
  {
    var    functionMapping = context.functions.get(functionFieldName);
    String typeDesc        = functionMapping.functionFieldDescriptor(false);

    variables.forEach(variable -> linkSharedVariableToReferencedFunction(mv,
                                                                         functionMapping,
                                                                         generatedFunctionClassInternalName,
                                                                         fieldType,
                                                                         functionFieldName,
                                                                         typeDesc,
                                                                         variable));
  }

  protected void injectReferences(F f)
  {
    if (trace)
    {
      log.debug("Injecting references into " + this.functionName);
    }

    if (context != null)
    {
      context.injectReferences(f);
    }
  }

  public TextTree<Node<D, C, F>> inspect(F f)
  {
    return new TextTree<>(syntaxTree(),
                          f);
  }

  public F instantiate()
  {

    instance = newInstance();

    injectReferences(instance);

    return instance;
  }

  protected void invokeInitializationMethod(MethodVisitor mv,
                                            Expression<Object, Object, Function<?, ?>> function)
  {
    duplicateTopOfTheStack(mv);
    Compiler.invokeMethod(mv, function.className, "initialize", "()V", false);
  }

  /**
   * 
   * @return true if this{@link #coDomainType} is an interface (that extends
   *         {@link Function})
   */
  public boolean isFunctional()
  {
    // return Function.class.isAssignableFrom(coDomainType);
    return coDomainType.isInterface();
  }

  public boolean isInterfaceFunctional()
  {
    return Function.class.isAssignableFrom(coDomainType);
    // return coDomainType.isInterface();
  }

  /**
   * Returns the current code point at the parser's position. For BMP characters
   * this is identical to {@code character}; for supplementary characters it reads
   * the full surrogate pair.
   */
  public int currentCodePoint()
  {
    if (position < 0 || position >= getExpression().length())
    {
      return Character.MIN_VALUE;
    }
    return getExpression().codePointAt(position);
  }

  /**
   * Checks whether the current code point at the parser position is an identifier
   * character. Uses code-point-aware lookup to support supplementary Unicode
   * characters such as U+107A5 (𐞥).
   */
  public boolean isIdentifierCharacter()
  {
    int cp = currentCodePoint();
    return isIdentifyingCharacter(cp, false) || isSubscript(character) || isSuperscriptLetter(cp);
  }

  /**
   * Advances the parser position by one Unicode code point. For supplementary
   * characters (surrogate pairs), advances by two {@code char} positions.
   */
  protected char nextCharacter()
  {
    ++position;
    if (position < getExpression().length())
    {
      int cp = getExpression().codePointAt(position);
      // For supplementary characters, 'character' holds the high surrogate.
      // All comparisons in the tokenizer that matter for supplementary chars
      // go through currentCodePoint() / isIdentifierCharacter() instead.
      character = getExpression().charAt(position);
    }
    else
    {
      character = Character.MIN_VALUE;
    }
    return character;
  }

  /**
   * Skips forward by the char-count of the current code point. Used after
   * identifying a supplementary character to advance past both surrogates.
   */
  protected void advancePastCurrentCodePoint()
  {
    int cp        = currentCodePoint();
    int charCount = Character.charCount(cp);
    // Advance (charCount - 1) extra positions since nextCharacter() already
    // moved forward by 1.
    for (int i = 1; i < charCount; i++)
    {
      ++position;
    }
    if (position < getExpression().length())
    {
      character = getExpression().charAt(position);
    }
    else
    {
      character = Character.MIN_VALUE;
    }
  }

  /**
   * Parses an identifier name starting from {@code startPos}. Uses code-point
   * iteration to correctly handle supplementary Unicode characters.
   */
  protected String parseName(int startPos)
  {
    boolean entirelySubscripted   = true;
    boolean entirelySuperscripted = true;
    while (position < getExpression().length())
    {
      int     cp       = getExpression().codePointAt(position);
      boolean isLetter = isIdentifyingCharacter(cp, true);

      if (isLetter || (entirelySubscripted && !isLetter && isSubscript(character))
                    || (entirelySuperscripted && !isLetter && isSuperscriptLetter(cp)))
      {
        // Advance past the full code point (1 char for BMP, 2 for supplementary)
        int charCount = Character.charCount(cp);
        position += charCount;
        if (position < getExpression().length())
        {
          character = getExpression().charAt(position);
        }
        else
        {
          character = Character.MIN_VALUE;
        }
        if (isLetter)
        {
          entirelySubscripted = false;
        }
      }
      else
      {
        break;
      }
    }
    var substring = getExpression().substring(startPos, position).trim();
    return Parser.subscriptAndSuperscriptsToRegular(substring);
  }

  /**
   * Checks that no numeric digits appear in the input variable name. Uses
   * code-point iteration for supplementary character safety.
   */
  protected boolean assureNoNumbersInTheInputVariable(String inputVariableName,
                                                      boolean isInputVariableSpecified)
  {
    for (int i = 0; i < inputVariableName.length();)
    {
      int cp = inputVariableName.codePointAt(i);
      if (!Parser.isIdentifyingCharacter(cp, false))
      {
        isInputVariableSpecified = false;
      }
      i += Character.charCount(cp);
    }
    return isInputVariableSpecified;
  }

  public boolean isNullaryFunction()
  {
    return domainType.equals(Object.class);
  }

  public HashSet<String>                                                declaredVariables              =
                                                                                          new HashSet<>();

  private final Predicate<? super Entry<String, VariableNode<D, C, F>>> upstreamInputVariablePredicate =
                                                                                                       entry ->
                                                                                                                                                                                                            {
                                                                                                                                                                                                              String varName = entry
                                                                                                                                              .getKey();
                                                                                                                                                                                                              VariableNode<D, C, F> varNode = entry
                                                                                                                                              .getValue();

                                                                                                                                                                                                              // Skip
                                                                                                                                                                                                              // if
                                                                                                                                                                                                              // this
                                                                                                                                                                                                              // is
                                                                                                                                                                                                              // the
                                                                                                                                                                                                              // independent
                                                                                                                                                                                                              // variable
                                                                                                                                                                                                              // or
                                                                                                                                                                                                              // an
                                                                                                                                                                                                              // indeterminate
                                                                                                                                                                                                              if (varNode.isIndependent
                                                                                                                                                                                                                            || varNode.isIndeterminate)
                                                                                                                                                                                                              {
                                                                                                                                                                                                                return false;
                                                                                                                                                                                                              }

                                                                                                                                                                                                              // Skip
                                                                                                                                                                                                              // if
                                                                                                                                                                                                              // already
                                                                                                                                                                                                              // declared
                                                                                                                                                                                                              // as
                                                                                                                                                                                                              // upstream
                                                                                                                                                                                                              // independent
                                                                                                                                                                                                              // variable
                                                                                                                                                                                                              if (upstreamExpression
                                                                                                                                                                                                                            != null)
                                                                                                                                                                                                              {
                                                                                                                                                                                                                VariableNode<?, ?, ?> upstreamIndependentVariable =
                                                                                                                                                                                                                                                                  upstreamExpression.independentVariable;
                                                                                                                                                                                                                if (upstreamIndependentVariable
                                                                                                                                                                                                                              != null
                                                                                                                                                                                                                              && varName.equals(upstreamIndependentVariable.getName()))
                                                                                                                                                                                                                {
                                                                                                                                                                                                                  return false;
                                                                                                                                                                                                                }
                                                                                                                                                                                                              }

                                                                                                                                                                                                              // Skip
                                                                                                                                                                                                              // context
                                                                                                                                                                                                              // variables
                                                                                                                                                                                                              // (they
                                                                                                                                                                                                              // will
                                                                                                                                                                                                              // be
                                                                                                                                                                                                              // declared
                                                                                                                                                                                                              // below)
                                                                                                                                                                                                              if (context != null
                                                                                                                                                                                                                            && context.getVariable(varName)
                                                                                                                                                                                                                                          != null)
                                                                                                                                                                                                              {
                                                                                                                                                                                                                return false;
                                                                                                                                                                                                              }
                                                                                                                                                                                                              return true;
                                                                                                                                                                                                            };

  public final HashMap<String, AtomicInteger>                           intermediateVariableCounters   =
                                                                                                     new HashMap<>();

  protected void
            linkSharedVariableToReferencedFunction(MethodVisitor mv,
                                                   FunctionMapping<Object, Object, Function<?, ?>> functionMapping,
                                                   String generatedFunctionClassInternalName,
                                                   String fieldType,
                                                   String functionFieldName,
                                                   String typeDesc,
                                                   OrderedPair<String, Class<?>> variable)
  {
    String   variableName     = variable.getLeft();
    Class<?> variableType     = variable.getRight();
    String   variableTypeDesc = variableType.descriptorString();
    String   nestedClassName  = functionMapping.functionName;

    Label    labelElse        = new Label();
    Label    labelEnd         = new Label();

    // ── if (this.func.var == null) ──────────────────────────────
    Compiler.getFieldFromThis(mv, generatedFunctionClassInternalName, functionFieldName, typeDesc);
    Compiler.getField(mv, nestedClassName, variableName, variableTypeDesc);
    mv.visitJumpInsn(IFNONNULL, labelElse);

    // ── null branch: this.func.var = this.var ───────────────────
    Compiler.getFieldFromThis(mv, generatedFunctionClassInternalName, functionFieldName, typeDesc);
    Compiler.getFieldFromThis(mv,
                              generatedFunctionClassInternalName,
                              variableName,
                              variableTypeDesc);
    Compiler.putField(mv, nestedClassName, variableName, variableTypeDesc);
    Compiler.jumpTo(mv, labelEnd);

    // ── else branch: this.func.var.set(this.var) ────────────────
    mv.visitLabel(labelElse);
    Compiler.getFieldFromThis(mv, generatedFunctionClassInternalName, functionFieldName, typeDesc);
    Compiler.getField(mv, nestedClassName, variableName, variableTypeDesc);
    Compiler.getFieldFromThis(mv,
                              generatedFunctionClassInternalName,
                              variableName,
                              variableTypeDesc);
    Compiler.invokeSetMethod(mv, variableType, variableType);
    Compiler.pop(mv);

    mv.visitLabel(labelEnd);
  }

  public Node<D, C, F> literal(int i)
  {
    return newConstant(i);
  }

  public Node<D, C, F> literal(String i)
  {
    return newLiteralConstant(i);
  }

  protected MethodVisitor
            loadFieldOntoStack(MethodVisitor methodVisitor, String fieldName, Class<?> fieldType)
  {
    if (verboseTrace)
    {
      System.out.format("Expression(#%s).loadFieldOntoStack(fieldName=%s, fieldDescriptor=%s)\n",
                        System.identityHashCode(this),
                        fieldName,
                        fieldType.descriptorString());
    }
    assert fieldName != null : "fieldName is null";
    assert fieldType != null : "fieldType is null";

    methodVisitor.visitFieldInsn(GETFIELD, className, fieldName, fieldType.descriptorString());
    return methodVisitor;
  }

  public MethodVisitor
         loadFieldOntoStack(MethodVisitor methodVisitor, String fieldName, String fieldDescriptor)
  {
    if (verboseTrace)
    {
      log.debug(String.format("Expression(#%s).loadFieldOntoStack(fieldName=%s, fieldDescriptor=%s)\n",
                              System.identityHashCode(this),
                              fieldName,
                              fieldDescriptor));
    }
    methodVisitor.visitFieldInsn(GETFIELD, className, fieldName, fieldDescriptor);
    return methodVisitor;
  }

  public MethodVisitor loadThisFieldOntoStack(MethodVisitor mv, String name, Class<?> referenceType)
  {
    return loadFieldOntoStack(loadThisOntoStack(mv), name, referenceType);
  }

  public MethodVisitor loadThisFieldOntoStack(MethodVisitor mv, String name, String referenceType)
  {
    return loadFieldOntoStack(loadThisOntoStack(mv), name, referenceType);
  }

  protected Node<D, C, F> multiplyAndDivide(Node<D, C, F> node)
  {
    while (true)
    {
      if (nextCharacterRepresentsMultiplication())
      {
        Node<D, C, F> exponentiated = exponentiate();
        assert exponentiated != null : "exponentiate() returned null to be multiplied at position="
                                       + position;
        node = node.mul(exponentiated);
      }
      else if (nextCharacterRepresentsDivision())
      {
        Node<D, C, F> exponentiated = exponentiate();
        assert exponentiated != null : "exponentiate() returned null to be divided at position="
                                       + position;
        node = node.div(exponentiated);
      }
      else
      {
        return node;
      }
    }
  }

  protected boolean nextCharacterRepresentsSubtraction()
  {
    return nextCharacterIs('-', '₋', '−');
  }

  protected boolean nextCharacterRepresentsAddition()
  {
    return nextCharacterIs('+', '₊');
  }

  protected boolean nextCharacterRepresentsDivision()
  {
    return !characterAfterNextIs('∂') && nextCharacterIs('⁄', '/', '÷');
  }

  protected boolean nextCharacterRepresentsMultiplication()
  {
    return nextCharacterIs('*', '×', 'ₓ', '⋅', '·');
  }

  protected boolean needsCloseMethod()
  {
    return !literalConstants.isEmpty() | !intermediateVariables.isEmpty();
  }

  /**
   * 
   * @return true if this {@link Expression} has context variables, registered
   *         initializers, dependencies, referencedFunctions, or references itself
   */
  public boolean needsInitializer()
  {
    boolean contextHasVariables       = context != null && !context.variables.isEmpty();
    boolean hasRegisteredInitializers = !initializers.isEmpty();
    boolean hasDependencies           = dependencies != null && !dependencies.isEmpty();
    boolean hasReferencedFunctions    = !referencedFunctions.isEmpty();
    return contextHasVariables || hasRegisteredInitializers || hasDependencies || recursive
                  || hasReferencedFunctions;
  }

  @SuppressWarnings("unchecked")
  public <N extends Named> N newCoDomainInstance()
  {
    try
    {
      return (N) coDomainType.getConstructor().newInstance();
    }
    catch (Throwable e)
    {
      Utensils.throwOrWrap(e);
      return null;
    }
  }

  @SuppressWarnings("unchecked")
  public <N extends Named> N newDomainInstance()
  {
    try
    {
      return (N) domainType.getConstructor().newInstance();
    }
    catch (Throwable e)
    {
      Utensils.throwOrWrap(e);
      return null;
    }
  }

  protected Expression<Object, Object, Function<?, ?>> newFunctionalExpression()
  {
    Class<?>                        funcDomain   = null;
    Class<?>                        funcCoDomain = null;
    Class<? extends Function<?, ?>> funcClass    = null;

    if (RealFunction.class.equals(coDomainType))
    {
      funcDomain   = Real.class;
      funcCoDomain = Real.class;
      funcClass    = RealFunction.class;
    }
    else if (RealFunctional.class.equals(coDomainType))
    {
      funcDomain   = Real.class;
      funcCoDomain = RealFunction.class;
      funcClass    = RealFunctional.class;
    }
    else if (ComplexFunctional.class.equals(coDomainType))
    {
      funcDomain   = Complex.class;
      funcCoDomain = ComplexFunction.class;
      funcClass    = ComplexFunctional.class;
    }
    else if (ComplexFunction.class.equals(coDomainType))
    {
      funcDomain   = Complex.class;
      funcCoDomain = Complex.class;
      funcClass    = ComplexFunction.class;
    }
    else if (RealToComplexFunction.class.equals(coDomainType))
    {
      funcDomain   = Real.class;
      funcCoDomain = Complex.class;
      funcClass    = RealToComplexFunction.class;
    }
    else if (RealSequence.class.equals(coDomainType))
    {
      funcDomain   = Integer.class;
      funcCoDomain = Real.class;
      funcClass    = RealSequence.class;
    }
    else if (ComplexSequence.class.equals(coDomainType))
    {
      funcDomain   = Integer.class;
      funcCoDomain = Complex.class;
      funcClass    = ComplexSequence.class;
    }
    else
    {
      throw new UnsupportedOperationException("TODO: implement "
                                              + coDomainType
                                              + " codomain functional");
    }

    var functionalExpression = new Expression<Object, Object, Function<?, ?>>(funcDomain,
                                                                              funcCoDomain,
                                                                              funcClass);
    functionalExpression.upstreamExpression = this;
    if (context == null)
    {
      context = new Context();
    }

    functionalExpression.context = context;

    // Isolate stack to prevent dummy vars (t) leaking
    functionalExpression.clearIndeterminateVariables();
    var indeterminantVariable = getIndeterminateVariable(); // p (functional lambda)
    if (indeterminantVariable != null)
    {
      functionalExpression.independentVariable =
                                               indeterminantVariable.spliceInto(functionalExpression)
                                                                    .asVariable();
      // functionalExpression.indeterminateVariables.push(functionalExpression.independentVariable);
    }

    rootNode.isResult                      = true;

    functionalExpression.className         = className + "func";
    functionalExpression.functionName      = functionName + "func";

    functionalExpression.rootNode          = rootNode.spliceInto(functionalExpression);
    functionalExpression.rootNode.isResult = rootNode.isResult;
    functionalExpression.updateStringRepresentation();
    return functionalExpression;
  }

  private F newInstance()
  {
    if (compiledClass == null)
    {
      compile();
    }
    try
    {
      return instance = compiledClass.getDeclaredConstructor().newInstance();
    }
    catch (Exception e)
    {
      Utensils.throwOrWrap(e);
      return null;
    }

  }

  public String newIntermediateVariable(Class<?> type)
  {
    return newIntermediateVariable("v", type);
  }

  public String newIntermediateVariable(String prefix, Class<?> type)
  {
    return newIntermediateVariable(prefix, type, true);
  }

  public String newIntermediateVariable(String prefix, Class<?> type, boolean initialize)
  {
    assert prefix != null : "name shan't be null";
    var intermediateVarName = getNextIntermediateVariableFieldName(prefix, type);
    return registerIntermediateVariable(intermediateVarName, type, initialize);
  }

  public LiteralConstantNode<D, C, F> newConstant(int i)
  {
    return new LiteralConstantNode<>(this,
                                     java.lang.Integer.toString(i));
  }

  public LiteralConstantNode<D, C, F> newLiteralConstant(String i)
  {
    return new LiteralConstantNode<>(this,
                                     i);
  }

  protected VariableNode<D, C, F> newVariable(int startPos, VariableReference<D, C, F> reference)
  {
    return new VariableNode<D, C, F>(this,
                                     reference,
                                     startPos,
                                     true);
  }

  public boolean nextCharacterIs(char... expectedCharacters)
  {
    skipSpaces();
    for (char expectedCharacter : expectedCharacters)
    {
      if (character == expectedCharacter)
      {
        previousCharacter = character;
        nextCharacter();
        return true;
      }
    }

    return false;
  }

  public Expression<D, C, F> optimize()
  {
    assert false : "TODO: expr compiler: Implement common subexpression elimination #518 https://github.com/crowlogic/arb4j/issues/518";

    return this;
  }

  protected boolean orderLimited()
  {
    return !(rootNode instanceof RiemannSiegelThetaFunctionNode);
  }

  public ElseNode<D, C, F> otherwise()
  {
    return new ElseNode<D, C, F>(this);
  }

  /**
   * @return this{@link #parseName(int)}(this{@link #position})
   */
  public String parseName()
  {
    return parseName(position);
  }

  /**
   * Calls this{@link #evaluateOptionalIndependentVariableSpecification()} before
   * calling this{@link #resolve()} and assigning the result to
   * this{@link #rootNode}
   * 
   * @param simplify TODO
   * 
   * @return this
   * @throws CompilerException
   */
  public Expression<D, C, F> parse(boolean simplify)
  {
    assert rootNode
                  == null : "parse must only be called before anything else has been parsed but rootNode="
                            + rootNode;
    evaluateOptionalIndependentVariableSpecification();
    nextCharacter();
    if (trace)
    {
      log.debug("#{}: parseRoot expression='{}'\n", System.identityHashCode(this), getExpression());
    }

    rootNode = resolve();
    assert rootNode != null : "parse(): resolve() returned null for expression='"
                              + getExpression()
                              + "'";

    if (position < getExpression().length() && character != '=')
    {
      throwUnexpectedCharacterException();
    }

    rootNode.isResult = true;

    if (simplify)
    {
      var simplifiedRootNode = rootNode.simplify();
      assert simplifiedRootNode
                    != null : rootNode
                              + "'s simplifiy method returned  null, its an instance of "
                              + rootNode.getClass();
      rootNode = simplifiedRootNode;
    }

    return this;
  }

  protected Node<D, C, F> parseSuperscript(Node<D, C, F> node, char superscript, String digit)
  {
    if (nextCharacterIs(superscript))
    {
      node = node.pow(newLiteralConstant(digit));
    }
    return node;
  }

  /**
   * Parse superscript digit characters as exponents. The ⁻¹ (U+207B U+00B9)
   * sequence is NOT consumed here when it appears immediately before '(' because
   * that denotes a compositional inverse and is handled by resolveIdentifier().
   */
  protected Node<D, C, F> parseSuperscripts(Node<D, C, F> node)
  {
    if (nextCharacterIs('⁻') && nextCharacterIs('¹'))
    {
      assert false : "implement superscripts properly?";
      return node.pow(negativeOne());
    }

    node = parseSuperscript(node, '⁰', "0");
    node = parseSuperscript(node, '¹', "1");
    node = parseSuperscript(node, '²', "2");
    node = parseSuperscript(node, '³', "3");
    node = parseSuperscript(node, '⁴', "4");
    node = parseSuperscript(node, '⁵', "5");
    node = parseSuperscript(node, '⁶', "6");
    node = parseSuperscript(node, '⁷', "7");
    node = parseSuperscript(node, '⁸', "8");
    node = parseSuperscript(node, '⁹', "9");
    return node;
  }

  public VariableReference<D, C, F> parseVariableReference()
  {
    return new VariableReference<>(parseName());
  }

  protected void propagateContext(MethodVisitor mv, Expression<?, ?, Function<?, ?>> function)
  {
    if (trace)
    {
      log.debug(String.format("Expression(#%s).propagateContextVariablesAndFunctions(function=%s)\n",
                              System.identityHashCode(this),
                              function));
    }
    propagateContextVariablesByReference(mv, function);
    propagateContextFunctionReferences(mv, function);
  }

  protected void
            propagateContextFunctionReference(MethodVisitor mv,
                                              Expression<?, ?, Function<?, ?>> function,
                                              Map.Entry<String, FunctionMapping<?, ?, ?>> entry)
  {

    var    fieldName = entry.getKey();
    String fieldType = entry.getValue().functionFieldDescriptor();

    if (referencedFunctions.containsKey(entry.getKey()))
    {
      loadThisFieldOntoStack(duplicateTopOfTheStack(mv), fieldName, fieldType);
      putField(mv, function.className, fieldName, fieldType);
    }
  }

  public void propagateContextFunctionReferences(MethodVisitor mv,
                                                 Expression<?, ?, Function<?, ?>> function)
  {
    Predicate<String> keyPredicate = key -> function.referencedFunctions.containsKey(key)
                  && !key.equals(functionName);

    if (Expression.trace)
    {
      log.debug("propagateContextFunctionReferences(function={}) functions={} functionsPropagated={}",
                function,
                context.functions.keySet(),
                context.functions.keySet().stream().filter(keyPredicate).toList());

    }
    if (functionName == null)
    {
      functionName = Parser.transformToJavaAcceptableCharacters(getExpression());
    }

    context.functionEntryStream()
           .filter(entry -> function.referencedFunctions.containsKey(entry.getKey())
                         && !entry.getKey().equals(functionName))
           .forEach(entry -> propagateContextFunctionReference(mv, function, entry));
  }

  public void propagateContextVariablesByReference(MethodVisitor mv,
                                                   Expression<?, ?, Function<?, ?>> function)
  {
    if (trace)
    {
      log.debug(String.format("Expression(#%s).propagateContextVariablesByReference(function=%s)\n",
                              System.identityHashCode(this),
                              function));
    }
    for (var entry : context.variableEntries())
    {
      var   fieldName = entry.getKey();
      Named val       = entry.getValue();
      // assert val != null : "entry is null " + entry;
      if (val != null)
      {
        var fieldType = val.getClass();
        loadThisFieldOntoStack(duplicateTopOfTheStack(mv), fieldName, fieldType);
        putField(mv, function.className, fieldName, fieldType);
      }
    }
  }

  protected void
            copyIndependentVariableToFunctionalByValue(MethodVisitor mv,
                                                       Expression<?, ?, Function<?, ?>> function,
                                                       VariableNode<?, ?, Function<?, ?>> independentVariableMappedToFunctional)
  {
    if (trace)
    {
      log.debug(String.format("Expression(#%s).copyIndependentVariableToFunctionalByValue(function=%s, independentVariableMappedToFunctional=%s)\n",
                              System.identityHashCode(this),
                              function,
                              independentVariableMappedToFunctional));
    }
    var    fieldName       = independentVariableMappedToFunctional.getName();
    String fieldDescriptor = domainType.descriptorString();

// Check if the destination field (function.fieldName) is null;
// if so, create a new instance before copying by value
    Label  fieldNotNull    = new Label();

    duplicateTopOfTheStack(mv);
// Stack: [funcInst, funcInst]
    mv.visitFieldInsn(GETFIELD, function.className, fieldName, fieldDescriptor);
// Stack: [funcInst, funcInst.field]
    mv.visitJumpInsn(IFNONNULL, fieldNotNull);
// Stack: [funcInst]

// Field is null: create a new instance and assign it to the field
    duplicateTopOfTheStack(mv);
// Stack: [funcInst, funcInst]
    generateNewObjectInstruction(mv, domainType);
// Stack: [funcInst, funcInst, newInstance]
    duplicateTopOfTheStack(mv);
// Stack: [funcInst, funcInst, newInstance, newInstance]
    invokeDefaultConstructor(mv, domainType);
// Stack: [funcInst, funcInst, newInstance]
    putField(mv, function.className, fieldName, domainType);
// Stack: [funcInst]

    mv.visitLabel(fieldNotNull);
// Stack: [funcInst] (both paths converge here)

// Copy by value: funcInst.fieldName.set(independentVariableValue)
    duplicateTopOfTheStack(mv);
// Stack: [funcInst, funcInst]
    mv.visitFieldInsn(GETFIELD, function.className, fieldName, fieldDescriptor);
// Stack: [funcInst, funcInst.field] (guaranteed non-null)
    independentVariable.generate(mv, domainType);
// Stack: [funcInst, funcInst.field, indepVarValue]
    generateVirtualMethodInvocation(mv, domainType, "set", domainType, domainType);
// Stack: [funcInst, returnValue]
    mv.visitInsn(Opcodes.POP);
// Stack: [funcInst]
  }

  /**
   * 
   * @param reference
   * @return true if reference is in this{@link #referencedVariables}
   */
  public boolean references(VariableReference<D, C, F> reference)
  {
    return referencedVariables.containsKey(reference.name);
  }

  public Expression<D, C, F> registerInitializer(Consumer<MethodVisitor> consumer)
  {
    initializers.add(consumer);
    return this;
  }

  public String
         registerIntermediateVariable(String intermediateVarName, Class<?> type, boolean initialize)
  {
    // assert !type.isInterface() : "cannot instantiate interface " + type;

    if (!isFunctional())
    {
      var newIntermediateVariable = new IntermediateVariable<>(this,
                                                               intermediateVarName,
                                                               type,
                                                               initialize);
      if (intermediateVariables.containsKey(intermediateVarName))
      {
        throw new CompilerException(String.format("an intermediate variable named %s already exists",
                                                  intermediateVarName));
      }

      intermediateVariables.put(intermediateVarName, newIntermediateVariable);
    }
    else
    {
      // if the coDomain is a functon, then it will be an interface and thus
      // no intermediate variables will be declared in this class, instead they are
      // declared in the class that will be returned
      return null;
    }

    return intermediateVarName;
  }

  @SuppressWarnings("hiding")
  public <A, B, Q extends Function<? extends A, ? extends B>>
         FunctionMapping<A, B, Q>
         registerSubexpression(Expression<A, B, Q> expr)
  {
    if (context == null)
    {
      context = new Context();
    }
    return context.registerFunctionMapping(expr.className,
                                           expr.instantiate(),
                                           expr.domainType,
                                           expr.coDomainType,
                                           Function.class,
                                           true,
                                           expr,
                                           null);
  }

  public String remaining()
  {
    return getExpression() == null ? null
                                   : getExpression().substring(Math.max(0, position),
                                                               getExpression().length());
  }

  protected void renameVariable(String from, String to)
  {
    if (trace)
    {
      log.debug(String.format("Expression(#%s).rename(from=%s, to=%s)\n",
                              System.identityHashCode(this),
                              from,
                              to));
    }
    if (independentVariable != null)
    {
      independentVariable.renameIfNamed(from, to);
    }
    var indeterminantVariable = getIndeterminateVariable();

    if (indeterminantVariable != null)
    {
      indeterminantVariable.renameIfNamed(from, to);
    }
  }

  public Expression<D, C, F> require(char... which)
  {
    return require(null, which);
  }

  /**
   * Requires each character of a string sequentially
   * 
   * @param msg
   * @return
   */
  public Expression<D, C, F> require(String msg)
  {
    for (char ch : msg.toCharArray())
    {
      require(ch);
    }
    return this;
  }

  public Expression<D, C, F> require(String msg, char... which)
  {
    if (!nextCharacterIs(which))
    {
      throwUnexpectedCharacterException(msg, which);
    }
    return this;
  }

  /**
   * Apply the order of operations except for parenthesis by first calling
   * this{@link #exponentiateMultiplyAndDivide()} then passing the result to
   * {@link #addAndSubtract(Node)}
   * 
   * @return the result of passing this{@link #exponentiateMultiplyAndDivide()} to
   *         this{@link #addAndSubtract(Node)}
   */
  public Node<D, C, F> resolve()
  {
    var node = exponentiateMultiplyAndDivide();
    return addAndSubtract(node);
  }

  protected <N extends Node<D, C, F>> N resolveAbsoluteValue(N node)
  {
    if (!inAbsoluteValue && nextCharacterIs('|'))
    {
      inAbsoluteValue = true;
      node            = resolve().abs();
      require('|');
      inAbsoluteValue = false;
    }
    return node;
  }

  protected Node<D, C, F> resolveCeiling(Node<D, C, F> node)
  {
    if (nextCharacterIs('⌈'))
    {
      node = new CeilingNode<>(this,
                               resolve());
      require('⌉');
    }
    return node;
  }

  protected Node<D, C, F> resolveFactorials(Node<D, C, F> node)
  {
    if (nextCharacterIs('!'))
    {
      return new FactorialNode<>(this,
                                 node);
    }
    if (nextCharacterIs('₍'))
    {
      return new AscendingFactorializationNode<>(node,
                                                 resolve(),
                                                 require('₎'));
    }
    if (nextCharacterIs('⋰'))
    {
      return new AscendingFactorializationNode<>(node,
                                                 resolve(),
                                                 this);
    }

    return node;
  }

  protected Node<D, C, F> resolveFloor(Node<D, C, F> node)
  {
    if (nextCharacterIs('⌊'))
    {
      node = new FloorNode<>(this,
                             resolve());
      require('⌋');
    }
    return node;
  }

  // boolean enableMittagLefflerFunction = false;

  protected Node<D, C, F> resolveFunction(int startPos, VariableReference<D, C, F> reference)
  {
    switch (reference.name)
    {

//    case "MittagLeffler":
//    case "mittagleffler":
//      if ( !enableMittagLefflerFunction )
//      {
//        continue;
//      }
//      return new MittagLefflerFunctionNode<>(this);
    case "Z":
      return new HardyZFunctionNode<>(this);
    case "ϑ":
    case "vartheta":
      return new RiemannSiegelThetaFunctionNode<>(this);
    case "ζ":
    case "zeta":
      return new ZetaFunctionNode<>(this);
    case "when":
      return new WhenNode<>(this);
    case "fracdiff":
      return new CaputoFractionalDerivativeNode<>(this);
    case "diff":
      return new DerivativeNode<>(this,
                                  true);
    case "int":
      return new IntegralNode<>(this,
                                true);
    case "sum":
      return new SumNode<>(this,
                           true);
    case "lim":
    case "limit":
      return new LimitNode<>(this);
    case "J":
      return new BesselFunctionNodeOfTheFirstKind<>(this);
    case "W":
      return new LambertWFunctionNode<>(this);
    case "j":
      return new SphericalBesselFunctionNodeOfTheFirstKind<>(this);
    case "R":
      return new LommelPolynomialNode<>(this);
    case "ℭ":
    case "binom":
    case "binomial":
      return new BinomialCoefficientNode<>(this);
    case "pFq":
    case "pfq":
      return new HypergeometricFunctionNode<>(this);
    case "Beta":
    case "beta":
      return new BetaFunctionNode<>(this);
    case "Γ":
    case "Gamma":
      return new GammaFunctionNode<>(this);
    case "lnGamma":
    case "lnΓ":
    case "logGamma":
    case "logΓ":
      return new LogGammaFunctionNode<>(this);
    case "si":
      return new SineIntegralNode<>(this);
    default:

      // Regular function call with parentheses
      return new FunctionNode<>(reference.name,
                                resolve(),
                                require(')'));
    }
  }

  Node<D, C, F> resolveFunctionDerivative(int startPos,
                                          VariableReference<D, C, F> functionReference)
  {
    var node = require('(').resolveFunction(startPos, functionReference);
    if (node.isFunction())
    {
      var inputVariableNode = node.asFunction().getInputVariableNode();
      if (inputVariableNode != null)
      {
        var splicedVariable = inputVariableNode.spliceInto(node.expression).asVariable();
        var derivative      = node.differentiate(splicedVariable);
        return derivative;
      }

    }

    // this should differentiate with respect to the argument variable of the
    // function and then apply the argument
    // to the derivative of the function, rather than differentiating with respect
    // to the independent or indeterminant
    // variable of the expression it is contained within
    return node.derivative();
  }

  Node<D, C, F> resolveFunctionSecondDerivative(int startPos, VariableReference<D, C, F> reference)
  {
    var firstDerivative = resolveFunctionDerivative(startPos, reference);
    return firstDerivative.derivative();
  }

  protected Node<D, C, F> resolveIdentifier() throws CompilerException
  {
    int startPos  = position;
    var reference = resolveVariableReference(startPos);

    if (nextCharacterIs('⁻'))
    {
      if (nextCharacterIs('¹'))
      {
        if (nextCharacterIs('('))
        {
          var argument = resolve();
          require(')');
          return new InverseFunctionNode<>(reference.name,
                                           argument,
                                           this);
        }
        else
        {
          return newVariable(startPos, reference).pow(newLiteralConstant("-1"));
        }
      }
    }

    if (nextCharacterIs('('))
    {
      return resolveFunction(startPos, reference);
    }

    if (nextCharacterIs(COMBINING_DOT_ABOVE))
    {
      return resolveFunctionDerivative(startPos, reference);
    }

    if (nextCharacterIs(COMBINING_TWO_DOTS_ABOVE))
    {
      return resolveFunctionSecondDerivative(startPos, reference);
    }

    return resolveSymbolicLiteralConstantKeywordOrVariable(startPos, reference);
  }

  protected Node<D, C, F> resolvePostfixOperators(Node<D, C, F> node)
  {
    node = resolveFactorials(node);
    node = resolveFloor(node);
    node = resolveCeiling(node);
    node = resolveAbsoluteValue(node);
    if (nextCharacterIs('('))
    {
      node = new FunctionalEvaluationNode<>(this,
                                            node);
    }
    return node;
  }

  protected Node<D, C, F>
            resolveSymbolicLiteralConstantKeywordOrVariable(int startPos,
                                                            VariableReference<D, C, F> reference)
  {
    if (reference.isLiteralConstant())
    {
      return newLiteralConstant(reference.name);
    }
    else
    {
      return reference.isElse() ? otherwise() : newVariable(startPos, reference);
    }
  }

  public MethodVisitor setThisField(MethodVisitor mv, String fieldName, Class<?> fieldType)
  {
    return putField(mv, className, fieldName, fieldType);
  }

  /**
   * Sets this{@link #rootNode} to this{@link #rootNode}.{@link Node#simplify()}
   * 
   * @return this
   */
  public Expression<D, C, F> simplify()
  {
    rootNode = rootNode.simplify();
    setExpression(rootNode.toString());
    return this;
  }

  protected void skip(int n)
  {
    character = getExpression().charAt(position += n);
  }

  public void skipSpaces()
  {
    while (character == ' ')
    {
      nextCharacter();
    }
  }

  protected Collection<IntermediateVariable<D, C, F>> sortedIntermediateVariables()
  {
    var intermediateVariableValues = new ArrayList<>(intermediateVariables.values()
                                                                          .stream()
                                                                          .toList());
    Collections.sort(intermediateVariableValues, (a, b) -> a.name.compareTo(b.name));
    return intermediateVariableValues;
  }

  public Stream<IntermediateVariable<D, C, F>> sortedIntermediateVariableStream()
  {
    return sortedIntermediateVariables().stream();
  }

  protected Expression<D, C, F> storeInstructions(ClassVisitor classVisitor)
  {
    assert classVisitor != null : "classVisitor shan't be null";
    ClassVisitor lastClassVisitor = null;

    while (!(classVisitor instanceof ClassWriter classWriter))
    {
      assert classVisitor
                    != null : "ClassWriter not found because the last link in the delegate chain "
                              + lastClassVisitor
                              + " of type "
                              + lastClassVisitor.getClass()
                              + " had no delegate";
      classVisitor = (lastClassVisitor = classVisitor).getDelegate();
    }

    instructions = classWriter.toByteArray();

    return saveAndOptionallyDecompileClassFile();
  }

  protected Expression<D, C, F> saveAndOptionallyDecompileClassFile()
  {
    if (saveClasses)
    {

      File file = new File(Compiler.compiledClassDir,
                           className + ".class");
      writeBytecodes(file);

      if (decompileClasses)
      {
        Compiler.decompileClassFile(file);
      }

    }

    return this;
  }

  @SuppressWarnings("hiding")
  public <E, S, G extends Function<? extends E, ? extends S>>
         Expression<D, C, F>
         substitute(String variableToChange, Expression<E, S, G> substitution)
  {
    if (variableToChange.equals(substitution.toString()))
    {
      return this;
    }

    if (context == null)
    {
      context = new Context();
    }

    if (Expression.trace)
    {
      log.debug(String.format("Expression(#%s).substitute %s for %s into %s\n \n\n",
                              System.identityHashCode(this),
                              substitution,
                              variableToChange,
                              this));
    }

    var substituteInputVariable     = substitution.getInputVariable();
    var substituteInputVariableName = substituteInputVariable.getName();
    if (!variableToChange.equals(substituteInputVariableName))
    {
      substitution.renameVariable(substituteInputVariableName, variableToChange);
    }

    rootNode = rootNode.substitute(variableToChange, substitution.rootNode);

    updateStringRepresentation();

    return this;
  }

  @SuppressWarnings("hiding")
  public <E, S, G extends Function<? extends E, ? extends S>>
         Expression<D, C, F>
         substitute(String variableToChange, Node<E, S, G> substitution)
  {
    if (variableToChange.equals(substitution.toString()))
    {
      return this;
    }

    if (context == null)
    {
      context = new Context();
    }

    if (Expression.trace)
    {
      log.debug(String.format("Expression(#%s).substitute %s for %s into %s\n \n\n",
                              System.identityHashCode(this),
                              substitution,
                              variableToChange,
                              this));
    }

    rootNode = rootNode.substitute(variableToChange, substitution);

    updateStringRepresentation();

    return this;
  }

  public ExpressionTree<D, C, F> syntaxTree()
  {
    return new ExpressionTree<>(rootNode);
  }

  public boolean thisOrAnyAscendentExpressionHasIndeterminantVariable()
  {
    if (indeterminantTypes.contains(coDomainType))
    {
      return true;
    }
    return upstreamExpression != null
                  && upstreamExpression.thisOrAnyAscendentExpressionHasIndeterminantVariable();
  }

  protected void throwUnexpectedCharacterException()
  {
    throw new CompilerException(String.format("unexpected '%s'(0x%x) character at position=%s in expression '%s' of length %d, remaining='%s' where this='%s' from %s to %s\n",
                                              character,
                                              (int) character,
                                              position,
                                              getExpression(),
                                              getExpression().length(),
                                              remaining(),
                                              this,
                                              domainType,
                                              coDomainType));

  }

  protected void throwUnexpectedCharacterException(char... which)
  {
    throwUnexpectedCharacterException(null, which);
  }

  public void throwUnexpectedCharacterException(String msg, char... which)
  {
    StringBuilder sb = new StringBuilder();
    for (char ch : which)
    {
      sb.append(String.format("'%s'(%d)", ch, (int) ch));
    }
    String result = sb.toString() + " of len " + which.length;
    throw new CompilerException(format("Expecting %s %s at position %d but got char '%c' instead in expr='%s', remaining=%s%s\n",
                                       which.length > 1 ? "one of" : "",
                                       result,
                                       position,
                                       character == 0 ? '0' : character,
                                       getExpression(),
                                       remaining(),
                                       msg != null ? " syntax=\"" + msg : "",
                                       implementedInterfaces));
  }

  @Override
  public String toString()
  {

    String str = null;
    if (Object.class.equals(domainType))
    {
      str = rootNode != null ? rootNode.toString() : getExpression();
    }
    if (rootNode != null)
    {
      if (independentVariable == null)
      {
        str = rootNode.toString();
      }
      else
      {
        str = String.format("%s➔%s", independentVariable.getName(), rootNode.toString());
      }
    }
    else
    {
      str = getExpression();
    }
    if (functionName != null && !functionName.startsWith("_")
                  && !functionName.startsWith("operand"))
    {
      str = String.format("%s:%s", functionName, getExpression());
    }
    if (str == null || "null".equals(str))
    {
      updateStringRepresentation();
    }
    return str;
  }

  @Override
  public String typeset()
  {
    return rootNode == null ? null : rootNode.typeset();
  }

  public Expression<D, C, F> updateStringRepresentation()
  {
    if (rootNode == null)
    {

      return this;
    }
    if (independentVariable != null)
    {
      setExpression(String.format("%s➔%s", independentVariable.getName(), rootNode.toString()));
    }
    else
    {
      setExpression(rootNode.toString());
    }
    return this;
  }

  protected MethodVisitor visitEvaluationMethod(ClassVisitor classVisitor)
  {
    return classVisitor.visitMethod(Opcodes.ACC_PUBLIC,
                                    "evaluate",
                                    Compiler.evaluationMethodDescriptor,
                                    getEvaluationMethodSignature(),
                                    null);
  }

  /**
   * @param file
   * @return
   */
  protected Expression<D, C, F> writeBytecodes(File file)
  {
    Utensils.storeBytesInFile(file, instructions);
    return this;
  }

  @Override
  public void accept(Consumer<Expression<?, ?, ?>> t)
  {
    assert upstreamExpression != this;
    t.accept(this);

    if (upstreamExpression != null)
    {
      upstreamExpression.accept(t);
    }

  }

  public Map<String, VariableNode<D, C, F>> getReferencedVariables()
  {
    return Collections.unmodifiableMap(referencedVariables);
  }

  public VariableNode<D, C, F> registerReferencedVariable(VariableNode<D, C, F> variableNode)
  {
    return referencedVariables.put(variableNode.reference.name, variableNode);
  }

  public boolean isVariableReferenced(String variableName)
  {
    return referencedVariables.containsKey(variableName);
  }

  public boolean isVariableReferenced(VariableNode<D, C, F> variableNode)
  {
    return referencedVariables.containsKey(variableNode.reference.name);
  }

  public synchronized Context getContext()
  {
    if (context == null)
    {
      context = new Context();
    }
    return context;
  }

  public Collection<VariableNode<D, C, F>> getIndeterminateVariables()
  {
    return Collections.unmodifiableCollection(indeterminateVariables);
  }

  public void pushIndeterminateVariable(VariableNode<D, C, F> variableNode)
  {
    // assert isFunctional() || isInterfaceFunctional() : this + " is not a
    // functional";
    indeterminateVariables.push(variableNode);
  }

  public Expression<D, C, F> clearIndeterminateVariables()
  {
    // assert false : "TODO: is this necessary? #844";
    indeterminateVariables.clear();
    return this;
  }

  public Expression<D, C, F> registerReferencedFunction(String functionName2,
                                                        FunctionMapping<D, C, F> mapping)
  {
    referencedFunctions.put(functionName, mapping);
    return this;
  }

  public String getExpression()
  {
    return expression;
  }

  public void setExpression(String expression)
  {
    this.expression = expression;
  }

  public LinkedList<Expression<?, ?, ?>> getUpstreamExpressions()
  {
    var                 upstreamExpressions = new LinkedList<Expression<?, ?, ?>>();
    Expression<?, ?, ?> e                   = this;
    do
    {
      upstreamExpressions.add(e);
    }
    while ((e = e.upstreamExpression) != null);
    return upstreamExpressions;
  }

  public Stream<Expression<?, ?, ?>> stream()
  {
    return StreamSupport.stream(upstreamExpressionSpliterator(), false);
  }

  public Spliterator<Expression<?, ?, ?>> upstreamExpressionSpliterator()
  {
    return getUpstreamExpressions().spliterator();
  }

  public String toStringExtended()
  {
    return stream().map(Expression::toString).collect(Collectors.joining(" => "));
  }

  public LiteralConstantNode<D, C, F> one()
  {
    return newConstant(1);
  }

  public LiteralConstantNode<D, C, F> negativeOne()
  {
    return newConstant(-1);
  }

}
