package arb;

/**
 * This structure contains several fields, explained below. An
 * acb_calc_integrate_opt_t is defined as an array of
 * acb_calc_integrate_opt_struct of length 1, permitting it to be passed by
 * reference. An acb_calc_integrate_opt_t must be initialized before use, which
 * sets all fields to 0 or NULL. For fields that have not been set to other
 * values, the integration algorithm will choose defaults automatically (based
 * on the precision and accuracy goals). This structure will most likely be
 * extended in the future to accommodate more options.
 */
public class IntegrationOptions
{

  public int getDegreeLimit(int relAccuracyGoalBits, int prec)
  {
    int dl;
    dl = degLimit;
    if (dl <= 0)
    {
      dl = (int) (0.5 * Math.min(relAccuracyGoalBits, prec) + 60);    
    }
    return dl;
  }

  public int getEvaluationLimit(int prec)
  {
    int el;
    el = evalLimit;
    if (el <= 0)
    {
      el = 1000 * prec + prec * prec;
    }
    el = Math.max(el, 1);
    return el;
  }

  public int getDepthLimit(int prec)
  {
    int dl;
    dl = depthLimit;
    if (dl <= 0)
    {
      dl = 2 * prec;
    }
    dl = Math.max(dl, 1);
    return dl;
  }

  /**
   * Maximum quadrature degree for each subinterval. If a zero or negative value
   * is provided, the limit is set to a default value which currently equals ..
   * for Gauss-Legendre quadrature. A higher quadrature degree can be beneficial
   * for functions that are holomorphic on a large domain around the integration
   * path and yet behave irregularly, such as oscillatory entire functions. The
   * drawback of increasing the degree is that the precomputation time for
   * quadrature nodes increases.
   */
  public int     degLimit;

  /**
   * Maximum number of function evaluations. If a zero or negative value is
   * provided, the limit is set to a default value which currently equals This is
   * the main parameter used to limit the amount of work before aborting due to
   * possible slow convergence or non-convergence. A lower limit allows aborting
   * faster. A higher limit may be needed for integrands with many discontinuities
   * or many singularities close to the integration path. This limit is only taken
   * as a rough guideline, and the actual number of function evaluations may be
   * slightly higher depending on the actual subdivisions.
   */
  public int     evalLimit;

  /**
   * Maximum search depth for adaptive subdivision. Technically, this is not the
   * limit on the local bisection depth but the limit on the number of
   * simultaneously queued subintervals. If a zero or negative value is provided,
   * the limit is set to the default value
   * 
   * Warning: memory usage may increase in proportion to this limit.
   */
  public int     depthLimit;

  /**
   * By default (if set to 0), new subintervals generated by adaptive bisection
   * will be appended to the top of a stack. If set to 1, a binary heap will be
   * used to maintain a priority queue where the subintervals with larger error
   * have higher priority. This sometimes gives better results in case of
   * convergence failure, but can lead to a much larger array of subintervals
   * (requiring a higher depth_limit) when many global bisections are needed.
   */
  public boolean useHeap;

  /**
   * If set to 1, some information about the overall integration process is
   * printed to standard output. If set to 2, information about each subinterval
   * is printed.
   */
  public boolean verbose;
}