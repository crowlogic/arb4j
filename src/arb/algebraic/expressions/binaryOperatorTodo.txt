  switch (this.operator.opcode)
    {
    case POWER.opcode:
      return (float) Math.pow(this.a.evaluate(), this.b.evaluate());
    case MULTIPLY.opcode:
      return this.a.evaluate() * this.b.evaluate();
    case DIVIDE.opcode:
      return this.a.evaluate() / this.b.evaluate();
    case REMAINDER.opcode:
    case PLUS.opcode:
      return this.a.evaluate() + this.b.evaluate();
    case MINUS.opcode:
      return this.a.evaluate() - this.b.evaluate();
    case SHL.opcode:
      return (int) this.a.evaluate() << (int) this.b.evaluate();
    case SHR.opcode:
      return (int) this.a.evaluate() >>> (int) this.b.evaluate();
    case LT.opcode:
      return this.a.evaluate() < this.b.evaluate() ? 1 : 0;
    case LE.opcode:
      return this.a.evaluate() <= this.b.evaluate() ? 1 : 0;
    case GT.opcode:
      return this.a.evaluate() > this.b.evaluate() ? 1 : 0;
    case GE.opcode:
      return this.a.evaluate() >= this.b.evaluate() ? 1 : 0;
    case EQ.opcode:
      return this.a.evaluate() == this.b.evaluate() ? 1 : 0;
    case NE.opcode:
      return this.a.evaluate() != this.b.evaluate() ? 1 : 0;
    case BITWISE_AND.opcode:
      return (int) this.a.evaluate() & (int) this.b.evaluate();
    case BITWISE_OR.opcode:
      return (int) this.a.evaluate() | (int) this.b.evaluate();
    case BITWISE_XOR.opcode:
      return (int) this.a.evaluate() ^ (int) this.b.evaluate();
    case LOGICAL_AND.opcode:
      return this.a.evaluate() != 0 ? this.b.evaluate() : 0;
    case LOGICAL_OR.opcode:
      float cond = this.a.evaluate();
      return cond != 0 ? cond : this.b.evaluate();
    case ASSIGN.opcode:
      float rhs = this.b.evaluate();
      ((Variable) this.a).set(rhs);
      return rhs;
    case COMMA.opcode:
      this.a.evaluate();
      return this.b.evaluate();
    default:
      return 0;