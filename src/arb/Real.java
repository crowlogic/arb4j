/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package arb;

import static arb.IntegerConstants.*;
import static arb.arb.*;
import java.util.*;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import arb.stochastic.ProbabilityDistributionFunction;
import arb.Lockable;

/**
 * Real numbers are points on an infinitely long line known as the real number
 * line, where the points corresponding to integers are equally spaced. Any real
 * number can be determined by a possibly infinite decimal representation. The
 * real line is part of the complex plane, and the real numbers are part of the
 * complex numbers.<br>
 * 
 */

public class Real implements Comparable<Real>, Iterable<Real>, Field<Real>, Lockable {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public Real(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(Real obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        arbJNI.delete_Real(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  static { System.loadLibrary( "arblib" ); }

  @Override
  public void lock()
  {
    int status = arbJNI.mprotect(swigCPtr, BYTES * dim, Protections.PROT_READ.bitfield);
    assert status == 0 : "mprotect call failed. TODO: implement errno";
    locked = true;
  }

  @Override
  public void unlock()
  {
    int status = arbJNI.mprotect(swigCPtr, BYTES * dim, Protections.PROT_READ.bitfield | Protections.PROT_WRITE.bitfield);
    assert status == 0 : "mprotect call failed. TODO: implement errno";
    locked = false;
  }

  boolean locked = false;
  @Override
  public boolean locked()
  {
    return locked;
  }
  
  /**
   * @see {@link Real#log(int, Real)}
   * 
   * @param prec
   * @return log(prec,this)
   */
  public Real log(int prec)
  {
    return log(prec, this);
  }
  
  /**
   * Calls {@link Real#random(RandomState, int)} on each element of this
   * 
   * @param pdf
   * @param randomState
   * @param prec
   */
  public void randomlyGenerate(ProbabilityDistributionFunction pdf, RandomState randomState, int prec)
  {
    forEach(element -> element.random(randomState, prec));
  }
  
  /**
   * Self-referencing this{@link #add(int, int, Real)}
   * 
   * @param i
   * @param prec
   * @return
   */
  public Real add(int i, int prec)
  {
    return add(i, prec, this);
  }

  public Real sub(int x, int prec, Real res)
  {
    arb.arb_sub_si(res, this, x, prec);
    return res;
  }

  /**
   * Add an integer to this
   * 
   * @param d    possibly signed integer to add
   * @param prec precision
   * @param res  where to store the result
   * @return the result of the addition
   */
  public Real add(int d, int prec, Real res)
  {
    if (d > 0)
    {
      arb.arb_add_ui(res, this, d, prec);
    }
    else if (d < 0)
    {
      arb.arb_sub_ui(res, this, -d, prec);
    }
    return res;
  }
  
  public Real sub(int i, int prec)
  {
    return sub(i,prec,this);
  }
  
  public Real variance(int prec, Real result)
  {
    try ( Real mean = new Real())
    {
      return variance(prec, arithmeticMean(prec, mean), result);
    }
  }

  public Real variance(int prec, Real mean, Real result)
  {
    result.zero();
    try ( Real tmp = new Real(); Real elementMinusMeanSquared = new Real() )
    {
      for (Real element : this)
      {
        element.sub(mean, prec, tmp).pow(2, prec,elementMinusMeanSquared);
        result.add( elementMinusMeanSquared, prec );
      }
    }
    return result.div(dim, prec);
  }
  
  public Real standardDeviation(int prec, Real result)
  {
    try ( Real mean = new Real())
    {
      return standardDeviation(prec, arithmeticMean(prec, mean), result);
    }  
  }
  
  public Real standardDeviation(int prec, Real mean, Real result)
  {
    return variance(prec, mean, result).sqrt(prec);
  }
  
  
  @Override
  public int dim()
  {
    return dim;    
  }

  public Stream<Real> stream()
  {
    return StreamSupport.stream(Spliterators.spliterator(iterator(), dim, Spliterator.SIZED | Spliterator.ORDERED),
                                false);
  }
  
  public Real abs()
  {
    return abs(this);
  }
  
  @Override
  public Iterator<Real> iterator()
  {
    return new RealIterator(this);
  }
  
  /**
    * Copy constructor
    */
  public Real(Float div, Magnitude mag)
  {
    this();
    setMid(div);
    setRad(mag);
  }

  public Real pow(int i, int prec)
  {
    return pow(i,prec,this);
  }

  public Real(String string, int prec)
  {
    this();
    assign(string, prec);
  }
  
  public Real log(int prec, Real res)
  {
    arb.arb_log(res, this, prec);
    return res;    
  }

  
  public Real mul2e( int e, Real res )
  {
    arb_mul_2exp_si(res, this, e);
    return res;
  }

  /**
   * Sets this to a uniformly distributed (pseudo) random number
   * 
   * @param state the {@link RandomState}
   * @param bits  precision
   * @return uniformly distributed pseudo-random number
   */
  public Real random(RandomState state, int bits)
  {
    arb.arb_urandom(this, state, bits);
    return this;
  }
  
  public Real resize(int alloc)
  {
    swigCPtr = SWIGTYPE_p_void.getCPtr(arb.flint_realloc(new SWIGTYPE_p_void(swigCPtr,
                                                                                false),
                                                            2 * alloc * Real.BYTES));
    this.dim = alloc;                                                            
    return this;
  }

  @Override
  public Real abs(int prec, Real w)
  {
    arb.arb_abs(w, this);
    return w;
  }
  
  /**
   * Computes the (Normal Gaussian) error function using an automatic algorithm
   * choice. If z is too small to use the asymptotic expansion, a working
   * precision sufficient to circumvent cancellation in the hypergeometric series
   * is determined automatically, and a bound for the propagated error is computed
   * with acb_hypgeom_erf_propagated_error().
   * 
   * @param prec
   * @param res
   * @return {@link arb#arb_hypgeom_erf(Real, Real, int)}
   */
  public Real erf(int prec, Real res)
  {
    arb.arb_hypgeom_erf(res, this, prec);
    return res;
  }

  /**
   * Computes the complementary (Normal Gaussian) error function  1-this{@link #erf(int, Real)}
   * whilst avoiding the catastrophic cancellation for large positive z.
   * @param prec
   * @param res
   * @return {@link arb#arb_hypgeom_erf(Real, Real, int)}
   */
  public Real erfc(int prec, Real res)
  {
    arb.arb_hypgeom_erfc(res, this, prec);
    return res;
  }
    
 /**
   * The inverse of this{@link #erf(int, Real)}
   * 
   * @param prec
   * @param res
   * @return {@link arb#arb_hypgeom_erfinv(Real, Real, int)}
   */
  public Real erfinv(int prec, Real res)
  {
    arb.arb_hypgeom_erfinv(res, this, prec);
    return res;
  }

  /**
   * The inverse of this{@link #erfc(int, Real)}
   * 
   * @param prec
   * @param res
   * @return {@link arb#arb_hypgeom_ercfinv(Real, Real, int)}
   */
  public Real erfcinv(int prec, Real res)
  {
    arb.arb_hypgeom_erfcinv(res, this, prec);
    return res;
  }
      
  public Complex div(Complex divisor, int prec, Complex w)
  {  
    return mul( divisor.inv(prec, w), prec, w );   
  }

  public Real sech(int prec, Real w)
  {
    arb.arb_sech(w, this, prec);
    return w;
  }
  
  public Complex sub(Complex a, int prec, Complex res)
  {
    try ( Complex subtrahend = new Complex())
    {
      return add(a.neg(subtrahend), prec, res);
    }
  }
  
  public Complex add(Complex a, int prec, Complex res)
  {
    arb.acb_add_arb(res, a, this, prec);
    return res;
  }

  public Real neg()
  {
    return negate(this);
  }

  
  /**
   * Adds the magnitude to the radius of this 
   * 
   * @param err
   * @return
   */
  public Real addUncertainty(Magnitude err)
  {
    arb.arb_add_error_mag(this, err);
    return this;
  }
  
  public Real clear()
  {
    if ( swigCMemOwn )
    {
      swigCMemOwn = false;    
      arb_clear(this);
      for ( int i = 2; i < dim; i++ )
      {
        get(i).clear();
      }
    }
    return this;
  }
  
  /**
   * Compares the midpoint of this to another Real, disregarding the uncertainty
   * radius if they are not equal. If they are equal, then compare the radius
   */
  @Override
  public int compareTo(Real o)
  {
    int cmp = getMid().compareTo(o.getMid());
    if ( cmp == 0 )
    {
      cmp = getRad().compareTo(o.getRad());
    }
    return cmp;
  }
  
  public Real set(int i)
  {
    arb.arb_set_si(this, i);;
    return this;
  }

  public Real exp(int prec, Real res)
  {
    arb.arb_exp(res, this, prec);
    return res;
  }

  /**
   * @return {@link arb#arb_equal(Real, Real)} != 0
   */
  @Override
  public boolean equals(Object obj)
  {
    if ( !(obj instanceof Real))
    {
      return false;
    }
    Real that = (Real)obj;
    return arb.arb_equal(this, that) != 0;
  }
  
  /**
   * 
   * @param prec
   * @param interval
   * @return {@link arb#arb_get_interval_arf(Float, Float, Real, int)
   */
  public FloatInterval getInterval(int prec, FloatInterval interval)
  {
    arb.arb_get_interval_arf(interval.getA(), interval.getB(), this, prec);
    return interval;
  }
  
  /**
   * @return {@link arb#arb_allocated_bytes(Real)}
   */
  public int getAllocatedBytes()
  {
    return arb.arb_allocated_bytes(this);
  }
  
  public Real negate(Real res)
  {
    arb.arb_neg(res, this);
    return this;
  }
  
  public Real sqrt( int prec )  
  {
    return sqrt(prec,this);
  }
  
  public Real sqrt( int prec, Real res )
  {
    arb.arb_sqrt(res, this, prec);
    return res;
  }
  
 public boolean isFinite()
 {
   return arb.arb_is_finite(this) != 0;
 }

 public Real floor( int prec, Real res )
 {
   arb.arb_floor( res, this, prec );
   return res;
 }

 public Real ceil( int prec, Real res )
 {
   arb.arb_ceil( res, this, prec );
   return res;
 }
 
  /**
   * @return this after calling arb#arb_indeterminate(Real)
   */
  public Real indeterminate()
  {
    arb_indeterminate(this);
    return this;
  }
 
  public Real frac(int prec, Real res)
  {
    try (Real f = new Real() )
    {
      return sub(floor(prec, f), prec, res);
    }
  }
 
   public int dim = 1;
  
  public int size()
  {
    return dim;
  }
 
  public Real slice( int startInclusive, int endExclusive )
  {
    int sliceDim = endExclusive - startInclusive;
    Real array = new Real( swigCPtr + startInclusive * BYTES, false );
    array.elements = new Real[array.dim = sliceDim];
    return array;
  }
     
  public static Real newVector( int dim )
  {
    Real array = arb._arb_vec_init(dim);    
    array.dim = dim;
    array.elements = new Real[array.dim = dim];
    return array;
  }
 
  public Real cos(int prec, Real result )
  {
    arb.arb_cos(result, this, prec );
    return result;
  }

  public Real sin(int prec, Real result )
  {
    arb.arb_sin(result, this, prec );
    return result;
  }
 
  @Override
  public Real mul(int i, int prec, Real res)
  {
    arb.arb_mul_si(res, this, i, prec);
    return res;
  }
 
  public Complex mul(Complex exp, int prec, Complex r)
  {
    arb.acb_mul_arb(r, exp, this, prec );
    return r;
  }
  
  public Real tanh(Real result, int prec )
  {   
    arb.arb_tanh(result, this, prec );
    return result;
  }
  
  public Real swap(Real u)
  {
    arb.arb_swap(this, u);
    return this;
  }

  @Override
  public Real div(Real exp, int prec, Real r)
  {
    arb.arb_div(r, this, exp, prec );
    return r;
  }
  
  public Real nthHardyZero(int n, int prec) 
  {    
    arb.nthHardyZero(this, n, prec);
    return this;
  }
  
  public int relAccuracyBits()
  {
   return arb.arb_rel_accuracy_bits(this);
  }

  public Real sub(Real real, int prec, Real res)
  {
    arb.arb_sub(res, this, real, prec);
    return res;
  }

  public Real setIntervalMagnitude( Magnitude a, Magnitude b, int prec )
  {
    arb.arb_set_interval_mag(this, a, b, prec);
    return this;
  }
  
  public static final int BYTES = 48;
  
  public Real pi( int prec )
  {
    arb.arb_const_pi(this, prec);
    return this;
  }
  
  public Real init()
  {
    arb.arb_init(this);
    return this;
  }
  
  @Override
  public void close() 
  { 
    clear();
  }

  public Real add(Real d, int prec, Real res)
  {
    arb.arb_add(res, this, d, prec );
    return res;
  }
  
    public Real[] elements;
  
  public Real get(int index)
  {
    assert index < dim : String.format("index = %d >= dim = %d", index, dim);
    if (index == 0 && dim == 1)
    {
      return this;
    }
    Real element = elements[index];
    if (element == null)
    {
      element = elements[index] = new Real(swigCPtr + index * Real.BYTES,
                                           false);
    }
    return element;
  }
   
  public String toFixedString()
  {
    StringBuilder sb = new StringBuilder();
    sb.append("[");
    for (int i = 0; i < dim; i++)
    {
      if ( i > 0 )
      {
        sb.append(",\n ");
      }
      sb.append(String.format("%010.010f", get(i).doubleValue() ) );
    }
    sb.append("]");
    return sb.toString();
  }
  
  public String toString( )
  {
    return toString(digits());
  }
  
  public int digits()
  {
    try ( Magnitude d = new Magnitude()  )
    {
      getRad().inv(d);
      d.log(d);
      d.div(MagnitudeConstants.log10mag, d);
      return (int) d.doubleValue() + 2;
    }
  }  
    public boolean  printPrecision = false;
    
  public String toString(int digits)
  {
    digits = Math.min(20, Math.max(7, digits));
    
    if (dim == 1)
    {
      return arb.arb_get_str(this,
                             digits,
                             printPrecision ? IntegerConstants.ARB_STR_MORE : IntegerConstants.ARB_STR_NO_RADIUS);
    }
    else
    {
      StringBuilder sb = new StringBuilder();
      sb.append("[");
      for (int i = 0; i < dim; i++)
      {
        if (i > 0)
        {
          sb.append(",\n ");
        }
        sb.append(String.format("%s", get(i).toString(digits)));
      }
      sb.append("]");
      return sb.toString();
    }
  }
      
  public Real abs(Real res)  
  {
    arb.arb_abs(this, res);
    return res;
  }

        
  public Real set(Real real)
  {
     arb.arb_set( this, real );
     return this;    
  }
  
  public int bits()
  {
    return arb.arb_bits(this);
  }

  public Real posInf()
  {
    arb.arb_pos_inf(this);
    return this;
  }
  
  public Real negInf()
  {
    arb.arb_neg_inf(this);
    return this;
  }
  
  public Real zero()
  {
    arb.arb_zero(this);
    return this;
  }

  public Real one()
  {
    arb.arb_one(this);
    return this;
  }
         
  public Real set(String string, int prec)
  {
    arb.arb_set_str(this, string, prec);
    return this;
  }
  
  
  public boolean overlaps( Real interval )
  {
    return arb.arb_overlaps(this, interval) != 0;
  }
  
  public boolean contains( Real interval )
  {
    return arb.arb_contains(this, interval) != 0;
  }
  
  
  public Real assign( String string, int prec )
  {
    arb.arb_set_str(this, string, prec);
    return this;
  }
  
  public Real set(double d)
  {
    arb.arb_set_d(this, d);
    return this;
  }
  
  @Override
  public Real div(int k, int prec, Real res)
  {
    arb.arb_div_si(res, this, k, prec);
    return res;
  }
  
  public double doubleValue()
  {
    return getMid().doubleValue();
  }

  public double doubleValue(RoundingMode rm)
  {
    return getMid().doubleValue(rm);
  }
  
  /**
   * @return arb#arb_sgn_nonzero(Real)
   */
  public int sign()
  {
    return arb.arb_sgn_nonzero(this);
  }

  public boolean isPositive()
  {
    return arb.arb_is_positive(this) != 0;
  }

  public boolean isNegative()
  {
    return arb.arb_is_negative(this) != 0;
  }
  
  public boolean containsZero()
  {
    return arb.arb_contains_zero(this) != 0;
  }
  
  public Real set(FloatInterval interval, int prec)
  {
    Float a = interval.getA();
    Float b = interval.getB();

    /* [-inf, -inf] or [+inf, +inf] */
    if (a.isInfinite() && a.equals(b) )
    {
      setMid(a);
      getRad().zero();
      return this;
    }

    /* any nan -> [nan +/- inf] */
    if (a.isNotANumber() || b.isNotANumber() )
    {
      arb_indeterminate(this);
      return this;
    }

    /* [-inf, x] or [x, +inf] = [+/- inf] */
    if (arf_is_neg_inf(a) != 0 || arf_is_pos_inf(b) != 0)
    {
      arf_zero(getMid());
      mag_inf(getRad());
      return this;
    }

    try ( Float t = new Float();)
    {
      /* [(a + b) +/- (b - a)] / 2 */
      arf_sub(t, b, a, MAG_BITS, ARF_RND_UP);

      if (arf_sgn(t) < 0)
      {
        throw new IllegalArgumentException("endpoints are out of order");
      }

      arf_get_mag(getRad(), t);

      int inexact = arf_add(getMid(), a, b, prec, ARB_RND);
      if (inexact != 0)
      {
        Magnitude xrad = getRad();
        arf_mag_add_ulp(xrad, xrad, getMid(), prec);
      }

      arb_mul_2exp_si(this, this, -1);

      return this;
    }
  }

  /**
   * 
   * @param prec
   * @param r
   * @return the multiplicative inverse of r 
   */
  public Real inv( int prec, Real r )
  {
    arb.arb_inv(r, this, prec);
    return r;
  }

  /**
   * The secant of r is the multiplicative inverse of the cosine of r
   * 
   * @param prec
   * @param r
   * @return
   */
  public Real sec(int prec, Real r)
  {
    return cos(prec, r).inv(prec, r);
  }
  
  public Real pow(int i, int prec, Real r)
  {
    assert i >= 0;  
    arb.arb_pow_ui(r, this, i, prec);
    return r;
  }
  
  public Real tan(int prec, Real r)
  {
    arb.arb_tan(r, this, prec);
    return r;
  }
  
  public boolean isZero()
  {
    return arb_is_zero(this) != 0;
  }

  /**
   * Calls this{@link #setMid(Float)} and zeros out the radius
   * @param u value to set the midpoint of this real number ball to 
   * @return this
   */
  public Real set(Float u)
  {
    setMid(u);
    getRad().zero();
    return this;
  }  
   
  public Real mul(Real x, int prec, Real result)
  {
    arb.arb_mul(result, this, x, prec );
    return result;
  }
    

  public void setMid(Float value) {
    arbJNI.Real_mid_set(swigCPtr, this, Float.getCPtr(value), value);
  }

  public Float getMid() {
    long cPtr = arbJNI.Real_mid_get(swigCPtr, this);
    return (cPtr == 0) ? null : new Float(cPtr, false);
  }

  public void setRad(Magnitude value) {
    arbJNI.Real_rad_set(swigCPtr, this, Magnitude.getCPtr(value), value);
  }

  public Magnitude getRad() {
    long cPtr = arbJNI.Real_rad_get(swigCPtr, this);
    return (cPtr == 0) ? null : new Magnitude(cPtr, false);
  }

  public Real() {
    this(arbJNI.new_Real(), true);
  }

}
